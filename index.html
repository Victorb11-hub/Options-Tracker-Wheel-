<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Options Wheel Strategy Tracker</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #000;
            color: #fff;
            padding: 20px;
            line-height: 1.6;
        }

        .container {
            max-width: 1800px;
            margin: 0 auto;
        }

        h1 {
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 10px;
            letter-spacing: -1px;
        }

        .subtitle {
            color: #888;
            font-size: 1.1rem;
            margin-bottom: 30px;
        }

        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 30px;
            border-bottom: 1px solid #333;
        }

        .tab {
            background: none;
            color: #888;
            border: none;
            padding: 12px 24px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            border-bottom: 2px solid transparent;
            transition: all 0.2s;
        }

        .tab:hover {
            color: #fff;
        }

        .tab.active {
            color: #fff;
            border-bottom-color: #fff;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 40px;
        }

        .stat-card {
            background: #111;
            border: 1px solid #333;
            padding: 20px;
            border-radius: 8px;
        }

        .stat-label {
            color: #888;
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
        }

        .stat-value {
            font-size: 1.8rem;
            font-weight: 700;
            color: #fff;
        }

        .stat-value.positive {
            color: #00ff88;
        }

        .stat-value.negative {
            color: #ff4444;
        }

        .controls {
            background: #111;
            border: 1px solid #333;
            padding: 25px;
            border-radius: 8px;
            margin-bottom: 30px;
        }

        .form-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .form-group {
            display: flex;
            flex-direction: column;
        }

        label {
            color: #888;
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 5px;
        }

        input, select {
            background: #000;
            border: 1px solid #333;
            color: #fff;
            padding: 10px;
            border-radius: 4px;
            font-size: 1rem;
        }

        input:focus, select:focus {
            outline: none;
            border-color: #fff;
        }

        button {
            background: #fff;
            color: #000;
            border: none;
            padding: 12px 30px;
            border-radius: 4px;
            font-weight: 700;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.2s;
        }

        button:hover {
            background: #ddd;
        }

        button.secondary {
            background: #333;
            color: #fff;
        }

        button.secondary:hover {
            background: #444;
        }

        .table-container {
            background: #111;
            border: 1px solid #333;
            border-radius: 8px;
            overflow-x: auto;
            margin-bottom: 20px;
        }

        .table-header {
            padding: 20px;
            border-bottom: 1px solid #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .table-title {
            font-size: 1.3rem;
            font-weight: 700;
        }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        thead {
            background: #0a0a0a;
        }

        th {
            text-align: left;
            padding: 15px;
            color: #888;
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 600;
            border-bottom: 1px solid #333;
            white-space: nowrap;
        }

        td {
            padding: 15px;
            border-bottom: 1px solid #222;
            white-space: nowrap;
        }

        tr:hover {
            background: #0a0a0a;
        }

        .action-buttons {
            display: flex;
            gap: 10px;
        }

        .btn-small {
            padding: 5px 12px;
            font-size: 0.85rem;
            background: #333;
            color: #fff;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .btn-small:hover {
            background: #444;
        }

        .btn-small.danger {
            background: #ff4444;
        }

        .btn-small.danger:hover {
            background: #cc0000;
        }

        .btn-small.success {
            background: #00ff88;
            color: #000;
        }

        .btn-small.success:hover {
            background: #00dd77;
        }

        .type-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: 600;
        }

        .type-badge.put {
            background: #ff440033;
            color: #ff8888;
            border: 1px solid #ff4444;
        }

        .type-badge.call {
            background: #00ff8833;
            color: #88ffaa;
            border: 1px solid #00ff88;
        }

        .action-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: 600;
        }

        .action-badge.sell {
            background: #00ff8833;
            color: #88ffaa;
        }

        .action-badge.buy {
            background: #ff440033;
            color: #ff8888;
        }

        .status-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: 600;
        }

        .status-badge.open {
            background: #00ff8833;
            color: #88ffaa;
            border: 1px solid #00ff88;
        }

        .status-badge.closed {
            background: #88888833;
            color: #aaa;
            border: 1px solid #666;
        }

        .positive-value {
            color: #00ff88;
        }

        .negative-value {
            color: #ff4444;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: #111;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 30px;
            max-width: 600px;
            width: 90%;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .modal-title {
            font-size: 1.5rem;
            font-weight: 700;
        }

        .close-btn {
            background: none;
            color: #888;
            font-size: 1.5rem;
            padding: 0;
            width: 30px;
            height: 30px;
            cursor: pointer;
        }

        .close-btn:hover {
            color: #fff;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* Login/Signup Styles */
        .auth-container {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: #000;
        }

        .auth-box {
            background: #0a0a0a;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 40px;
            width: 100%;
            max-width: 400px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }

        .auth-title {
            font-size: 2rem;
            font-weight: bold;
            margin-bottom: 10px;
            color: #fff;
            text-align: center;
        }

        .auth-subtitle {
            color: #888;
            text-align: center;
            margin-bottom: 30px;
        }

        .auth-input {
            width: 100%;
            padding: 12px;
            margin-bottom: 15px;
            background: #000;
            border: 1px solid #333;
            border-radius: 4px;
            color: #fff;
            font-size: 1rem;
            box-sizing: border-box;
        }

        .auth-input:focus {
            outline: none;
            border-color: #00ff88;
        }

        .auth-button {
            width: 100%;
            padding: 12px;
            background: #00ff88;
            color: #000;
            border: none;
            border-radius: 4px;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            margin-bottom: 15px;
        }

        .auth-button:hover {
            background: #00cc6a;
        }

        .auth-link {
            text-align: center;
            color: #888;
        }

        .auth-link a {
            color: #00ff88;
            text-decoration: none;
            cursor: pointer;
        }

        .auth-link a:hover {
            text-decoration: underline;
        }

        .auth-error {
            background: #ff4444;
            color: #fff;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 15px;
            text-align: center;
        }

        .logout-button {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 8px 16px;
            background: #ff4444;
            color: #fff;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
            z-index: 1000;
        }

        .logout-button:hover {
            background: #cc0000;
        }

        .rolled-badge {
            display: inline-block;
            background: #4488ff;
            color: #fff;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: bold;
            margin-left: 8px;
            vertical-align: middle;
        }

        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <!-- Login/Signup Screen -->
    <div id="authScreen" class="auth-container">
        <div class="auth-box">
            <div id="loginForm">
                <h1 class="auth-title">Options Wheel Tracker</h1>
                <p class="auth-subtitle">Login to your account</p>
                <div id="loginError" class="auth-error hidden"></div>
                <input type="text" id="loginUsername" class="auth-input" placeholder="Username">
                <input type="password" id="loginPassword" class="auth-input" placeholder="Password">
                <button onclick="login()" class="auth-button">Login</button>
                <div class="auth-link">
                    Don't have an account? <a onclick="showSignup()">Sign up</a>
                </div>
            </div>

            <div id="signupForm" class="hidden">
                <h1 class="auth-title">Create Account</h1>
                <p class="auth-subtitle">Sign up for Options Wheel Tracker</p>
                <div id="signupError" class="auth-error hidden"></div>
                <input type="text" id="signupUsername" class="auth-input" placeholder="Username">
                <input type="password" id="signupPassword" class="auth-input" placeholder="Password">
                <input type="password" id="signupPasswordConfirm" class="auth-input" placeholder="Confirm Password">
                <button onclick="signup()" class="auth-button">Create Account</button>
                <div class="auth-link">
                    Already have an account? <a onclick="showLogin()">Login</a>
                </div>
            </div>
        </div>
    </div>

    <!-- Main Tracker (hidden until logged in) -->
    <div id="trackerApp" class="hidden">
        <button onclick="logout()" class="logout-button">Logout</button>
        
    <div class="container">
        <h1>Options Wheel Strategy Tracker</h1>
        <p class="subtitle">Track your puts and calls with automatic calculations</p>

        <div class="tabs">
            <button class="tab active" onclick="switchTab('dashboard')">Dashboard</button>
            <button class="tab" onclick="switchTab('open')">Open Positions</button>
            <button class="tab" onclick="switchTab('groups')">Closed Groups</button>
            <button class="tab" onclick="switchTab('all')">All Trades</button>
        </div>

        <div class="stats-grid">
            <div class="stat-card">
                <div class="stat-label">Total Collateral Needed</div>
                <div class="stat-value" id="totalCollateral">$0</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Total Premium Collected</div>
                <div class="stat-value positive" id="totalPremium">$0</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Total P&L</div>
                <div class="stat-value" id="totalPL">$0</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Overall % Return on Money Risked</div>
                <div class="stat-value positive" id="overallReturn">0%</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Open Positions</div>
                <div class="stat-value" id="openPositions">0</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Avg % Return (Open)</div>
                <div class="stat-value positive" id="avgReturn">0%</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Closed Positions</div>
                <div class="stat-value" id="closedPositions">0</div>
            </div>
        </div>

        <div class="controls">
            <div class="form-grid">
                <div class="form-group">
                    <label>Symbol</label>
                    <input type="text" id="symbol" placeholder="AAPL" style="text-transform: uppercase;">
                </div>
                <div class="form-group">
                    <label>Contracts</label>
                    <input type="number" id="contracts" placeholder="1" value="1">
                </div>
                <div class="form-group">
                    <label>Strike</label>
                    <input type="number" id="strike" placeholder="150.00" step="0.01">
                </div>
                <div class="form-group">
                    <label>Premium</label>
                    <input type="number" id="premium" placeholder="2.50" step="0.01">
                </div>
                <div class="form-group">
                    <label>Action</label>
                    <select id="action">
                        <option value="sell">Sell</option>
                        <option value="buy">Buy</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Type</label>
                    <select id="type">
                        <option value="put">Put</option>
                        <option value="call">Call</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Date Opened</label>
                    <input type="date" id="dateOpened">
                </div>
                <div class="form-group">
                    <label>Exp Date</label>
                    <input type="date" id="expDate">
                </div>
                <div class="form-group">
                    <label>Price at Action</label>
                    <input type="number" id="priceAtAction" placeholder="152.50" step="0.01">
                </div>
                <div class="form-group">
                    <label>Info/Notes</label>
                    <input type="text" id="info" placeholder="Optional notes">
                </div>
                <div class="form-group">
                    <label>Trade Ref #</label>
                    <input type="text" id="tradeRef" placeholder="e.g., TSLA-001">
                </div>
                <div class="form-group">
                    <label>Account</label>
                    <select id="account">
                        <option value="">Select Account...</option>
                        <option value="Main">Main</option>
                        <option value="IRA">IRA</option>
                        <option value="Roth IRA">Roth IRA</option>
                    </select>
                    <button type="button" onclick="addNewAccount()" style="margin-top: 5px; padding: 4px 8px; font-size: 0.9rem;">+ Add Account</button>
                </div>
            </div>
            <div style="display: flex; gap: 10px;">
                <button onclick="addTrade()">Add Position</button>
                <button class="secondary" onclick="clearForm()">Clear</button>
                <button class="secondary" onclick="exportData()">Export Data</button>
                <button class="secondary" onclick="importData()">Import Data</button>
                <button id="undoButton" class="secondary" onclick="undoDelete()" style="display: none; background: #ff8844; color: #000;">Undo Delete</button>
            </div>
        </div>

        <div class="tab-content active" id="dashboardTab">
            <div style="text-align: center; color: #666; padding: 40px; background: #111; border: 1px solid #333; border-radius: 8px;">
                Your key metrics are displayed at the top. Use the tabs above to view different sections.
            </div>
        </div>

        <div class="tab-content" id="openTab">
            <div class="table-container">
                <div class="table-header">
                    <div class="table-title">All Open Positions</div>
                </div>
                <table>
                    <thead>
                        <tr>
                            <th>Symbol</th>
                            <th>Contracts</th>
                            <th>Strike</th>
                            <th>Premium</th>
                            <th>Action</th>
                            <th>Type</th>
                            <th>Date <span style="cursor: pointer; user-select: none;" onclick="sortOpenTrades('dateOpened', 'asc')">▲</span><span style="cursor: pointer; user-select: none;" onclick="sortOpenTrades('dateOpened', 'desc')">▼</span></th>
                            <th>Exp Date</th>
                            <th>Cash Required</th>
                            <th>% Return</th>
                            <th>Price @ Action</th>
                            <th>% OTM</th>
                            <th>P&L</th>
                            <th>Info</th>
                            <th>Trade Ref #</th>
                            <th>Account</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody id="openTradesTableBody">
                        <tr>
                            <td colspan="17" style="text-align: center; color: #666; padding: 40px;">
                                No open positions. Add your first trade above.
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <div class="table-container" style="margin-top: 30px;">
                <div class="table-header">
                    <div class="table-title">Open Positions by Stock</div>
                    <div>
                        <select id="stockFilter" onchange="filterByStock()" style="padding: 8px 16px; background: #000; color: #fff; border: 1px solid #333; border-radius: 4px; font-size: 1rem;">
                            <option value="">Select a stock...</option>
                        </select>
                    </div>
                </div>
                <table>
                    <thead>
                        <tr>
                            <th>Symbol</th>
                            <th>Contracts</th>
                            <th>Strike</th>
                            <th>Premium</th>
                            <th>Action</th>
                            <th>Type</th>
                            <th>Date <span style="cursor: pointer; user-select: none;" onclick="sortFilteredTrades('dateOpened', 'asc')">▲</span><span style="cursor: pointer; user-select: none;" onclick="sortFilteredTrades('dateOpened', 'desc')">▼</span></th>
                            <th>Exp Date</th>
                            <th>Cash Required</th>
                            <th>% Return</th>
                            <th>Price @ Action</th>
                            <th>% OTM</th>
                            <th>P&L</th>
                            <th>Info</th>
                            <th>Trade Ref #</th>
                            <th>Account</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody id="filteredTradesTableBody">
                        <tr>
                            <td colspan="17" style="text-align: center; color: #666; padding: 40px;">
                                Select a stock from the dropdown above to view positions.
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <div class="table-container" style="margin-top: 30px;">
                <div class="table-header">
                    <div class="table-title">Open Positions by Expiration Date</div>
                </div>
                <table>
                    <thead>
                        <tr>
                            <th>Symbol</th>
                            <th>Contracts</th>
                            <th>Strike</th>
                            <th>Premium</th>
                            <th>Action</th>
                            <th>Type</th>
                            <th>Date <span style="cursor: pointer; user-select: none;" onclick="sortExpirationTrades('dateOpened', 'asc')">▲</span><span style="cursor: pointer; user-select: none;" onclick="sortExpirationTrades('dateOpened', 'desc')">▼</span></th>
                            <th>Exp Date</th>
                            <th>Days Till Exp</th>
                            <th>Cash Required</th>
                            <th>% Return</th>
                            <th>Price @ Action</th>
                            <th>% OTM</th>
                            <th>P&L</th>
                            <th>Info</th>
                            <th>Trade Ref #</th>
                            <th>Account</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody id="expirationTradesTableBody">
                        <tr>
                            <td colspan="18" style="text-align: center; color: #666; padding: 40px;">
                                No open positions.
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="tab-content" id="groupsTab">
            <div style="margin-bottom: 20px; display: flex; gap: 10px;">
                <button onclick="autoGroupByTradeRef()" style="background: #00ff88; color: #000;">Auto-Group by Trade Ref #</button>
                <button onclick="createNewGroup()">Create New Group</button>
                <button class="secondary" onclick="showGroupManager()">Manage Groups</button>
            </div>
            
            <div id="groupsList"></div>
        </div>

        <div class="tab-content" id="allTab">
            <div class="table-container">
                <div class="table-header">
                    <div class="table-title">All Trades (Open & Closed)</div>
                    <div style="display: flex; gap: 10px;">
                        <button onclick="filterAllTrades('all')" id="filterAllBtn" style="padding: 6px 16px; background: #00ff88; color: #000; border: none; border-radius: 20px; font-size: 0.9rem; cursor: pointer; font-weight: bold;">All Trades</button>
                        <button onclick="filterAllTrades('open')" id="filterOpenBtn" style="padding: 6px 16px; background: #333; color: #fff; border: none; border-radius: 20px; font-size: 0.9rem; cursor: pointer;">Open Trades</button>
                        <button onclick="filterAllTrades('closed')" id="filterClosedBtn" style="padding: 6px 16px; background: #333; color: #fff; border: none; border-radius: 20px; font-size: 0.9rem; cursor: pointer;">Closed Trades</button>
                        <button onclick="filterAllTrades('rolled')" id="filterRolledBtn" style="padding: 6px 16px; background: #333; color: #fff; border: none; border-radius: 20px; font-size: 0.9rem; cursor: pointer;">Rolled Trades</button>
                    </div>
                </div>
                <table>
                    <thead>
                        <tr>
                            <th>Status</th>
                            <th>Symbol</th>
                            <th>Contracts</th>
                            <th>Strike</th>
                            <th>Premium</th>
                            <th>Action</th>
                            <th>Type</th>
                            <th>Date Opened <span style="cursor: pointer; user-select: none;" onclick="sortAllTrades('dateOpened', 'asc')">▲</span><span style="cursor: pointer; user-select: none;" onclick="sortAllTrades('dateOpened', 'desc')">▼</span></th>
                            <th>Date Closed <span style="cursor: pointer; user-select: none;" onclick="sortAllTrades('dateClosed', 'asc')">▲</span><span style="cursor: pointer; user-select: none;" onclick="sortAllTrades('dateClosed', 'desc')">▼</span></th>
                            <th>Exp Date</th>
                            <th>Cash Required</th>
                            <th>% Return</th>
                            <th>P&L</th>
                            <th>Info</th>
                            <th>Trade Ref #</th>
                            <th>Account</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody id="allTradesTableBody">
                        <tr>
                            <td colspan="17" style="text-align: center; color: #666; padding: 40px;">
                                No trades yet.
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <div class="modal" id="closeModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">Close Position</div>
                <button class="close-btn" onclick="closeCloseModal()">×</button>
            </div>
            <div class="form-grid">
                <div class="form-group">
                    <label>Close Date</label>
                    <input type="date" id="closeDate">
                </div>
                <div class="form-group">
                    <label>Closing Premium (if bought back)</label>
                    <input type="number" id="closingPremium" placeholder="0.50" step="0.01" value="0">
                </div>
                <div class="form-group">
                    <label>Final Notes</label>
                    <input type="text" id="closingNotes" placeholder="Expired worthless, rolled, etc.">
                </div>
            </div>
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button class="success" onclick="confirmClose()">Close Position</button>
                <button class="secondary" onclick="closeCloseModal()">Cancel</button>
            </div>
        </div>
    </div>

    <div class="modal" id="rollModal">
        <div class="modal-content" style="max-width: 800px;">
            <div class="modal-header">
                <div class="modal-title">Roll Position</div>
                <button class="close-btn" onclick="closeRollModal()">×</button>
            </div>
            <p style="color: #888; margin-bottom: 20px;">Close the current position and open a new one</p>
            
            <h3 style="margin-bottom: 15px; color: #fff;">Close Current Position</h3>
            <div class="form-grid">
                <div class="form-group">
                    <label>Close Date</label>
                    <input type="date" id="rollCloseDate">
                </div>
                <div class="form-group">
                    <label>Closing Premium (paid to buy back)</label>
                    <input type="number" id="rollClosingPremium" placeholder="0.50" step="0.01">
                </div>
            </div>
            
            <h3 style="margin: 25px 0 15px 0; color: #fff;">Open New Position</h3>
            <div class="form-grid">
                <div class="form-group">
                    <label>New Strike</label>
                    <input type="number" id="rollNewStrike" placeholder="150.00" step="0.01">
                </div>
                <div class="form-group">
                    <label>New Premium (collected)</label>
                    <input type="number" id="rollNewPremium" placeholder="2.50" step="0.01">
                </div>
                <div class="form-group">
                    <label>New Exp Date</label>
                    <input type="date" id="rollNewExpDate">
                </div>
                <div class="form-group">
                    <label>Price at Roll</label>
                    <input type="number" id="rollPriceAtAction" placeholder="152.50" step="0.01">
                </div>
                <div class="form-group">
                    <label>Type</label>
                    <select id="rollNewType">
                        <option value="put">Put</option>
                        <option value="call">Call</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Roll Notes</label>
                    <input type="text" id="rollNotes" placeholder="Rolled up/out for credit">
                </div>
            </div>
            
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button style="background: #4488ff; color: #fff;" onclick="confirmRoll()">Complete Roll</button>
                <button class="secondary" onclick="closeRollModal()">Cancel</button>
            </div>
        </div>
    </div>

    <div class="modal" id="editModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">Edit Position</div>
                <button class="close-btn" onclick="closeEditModal()">×</button>
            </div>
            <div class="form-grid">
                <div class="form-group">
                    <label>Trade Ref #</label>
                    <input type="text" id="editTradeRef">
                </div>
                <div class="form-group">
                    <label>Symbol</label>
                    <input type="text" id="editSymbol" style="text-transform: uppercase;">
                </div>
                <div class="form-group">
                    <label>Contracts</label>
                    <input type="number" id="editContracts">
                </div>
                <div class="form-group">
                    <label>Strike</label>
                    <input type="number" id="editStrike" step="0.01">
                </div>
                <div class="form-group">
                    <label>Premium</label>
                    <input type="number" id="editPremium" step="0.01">
                </div>
                <div class="form-group">
                    <label>Action</label>
                    <select id="editAction">
                        <option value="sell">Sell</option>
                        <option value="buy">Buy</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Type</label>
                    <select id="editType">
                        <option value="put">Put</option>
                        <option value="call">Call</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Date Opened</label>
                    <input type="date" id="editDateOpened">
                </div>
                <div class="form-group">
                    <label>Exp Date</label>
                    <input type="date" id="editExpDate">
                </div>
                <div class="form-group">
                    <label>Price at Action</label>
                    <input type="number" id="editPriceAtAction" step="0.01">
                </div>
                <div class="form-group">
                    <label>Info/Notes</label>
                    <input type="text" id="editInfo">
                </div>
            </div>
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button onclick="saveEdit()">Save Changes</button>
                <button class="secondary" onclick="closeEditModal()">Cancel</button>
            </div>
        </div>
    </div>

    <div class="modal" id="accountModal">
        <div class="modal-content" style="max-width: 400px;">
            <div class="modal-header">
                <div class="modal-title">Add New Account</div>
                <button class="close-btn" onclick="closeAccountModal()">×</button>
            </div>
            <div class="form-group">
                <label>Account Name</label>
                <input type="text" id="newAccountName" placeholder="e.g., Robinhood, TD Ameritrade">
            </div>
            <div style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 20px;">
                <button class="secondary" onclick="closeAccountModal()">Cancel</button>
                <button onclick="saveNewAccount()">Add Account</button>
            </div>
        </div>
    </div>

    <div class="modal" id="groupModal">
        <div class="modal-content" style="max-width: 1000px;">
            <div class="modal-header">
                <div class="modal-title">Create Trade Group</div>
                <button class="close-btn" onclick="closeGroupModal()">×</button>
            </div>
            <div style="margin-bottom: 20px;">
                <label>Group Name</label>
                <input type="text" id="groupName" placeholder="e.g., TSLA 820 Roll" style="width: 100%; margin-top: 10px;">
            </div>
            <div style="margin-bottom: 20px;">
                <strong>Select trades to include in this group:</strong>
            </div>
            <div id="availableTrades" style="max-height: 400px; overflow-y: auto; margin-bottom: 20px;"></div>
            <div style="display: flex; gap: 10px;">
                <button onclick="saveGroup()">Create Group</button>
                <button class="secondary" onclick="closeGroupModal()">Cancel</button>
            </div>
        </div>
    </div>
    </div> <!-- End trackerApp -->

    <script>
        // Authentication System
        let currentUser = null;
        let users = JSON.parse(localStorage.getItem('trackerUsers')) || {};

        function showLogin() {
            document.getElementById('loginForm').classList.remove('hidden');
            document.getElementById('signupForm').classList.add('hidden');
            document.getElementById('loginError').classList.add('hidden');
            document.getElementById('signupError').classList.add('hidden');
        }

        function showSignup() {
            document.getElementById('loginForm').classList.add('hidden');
            document.getElementById('signupForm').classList.remove('hidden');
            document.getElementById('loginError').classList.add('hidden');
            document.getElementById('signupError').classList.add('hidden');
        }

        function login() {
            const username = document.getElementById('loginUsername').value.trim().toLowerCase();
            const password = document.getElementById('loginPassword').value;
            const errorDiv = document.getElementById('loginError');

            if (!username || !password) {
                errorDiv.textContent = 'Please enter username and password';
                errorDiv.classList.remove('hidden');
                return;
            }

            if (!users[username]) {
                errorDiv.textContent = 'Username not found';
                errorDiv.classList.remove('hidden');
                return;
            }

            if (users[username].password !== password) {
                errorDiv.textContent = 'Incorrect password';
                errorDiv.classList.remove('hidden');
                return;
            }

            // Successful login
            currentUser = username;
            localStorage.setItem('currentUser', username);
            showTrackerApp();
        }

        function signup() {
            const username = document.getElementById('signupUsername').value.trim().toLowerCase();
            const password = document.getElementById('signupPassword').value;
            const passwordConfirm = document.getElementById('signupPasswordConfirm').value;
            const errorDiv = document.getElementById('signupError');

            if (!username || !password || !passwordConfirm) {
                errorDiv.textContent = 'Please fill in all fields';
                errorDiv.classList.remove('hidden');
                return;
            }

            if (username.length < 3) {
                errorDiv.textContent = 'Username must be at least 3 characters';
                errorDiv.classList.remove('hidden');
                return;
            }

            if (password !== passwordConfirm) {
                errorDiv.textContent = 'Passwords do not match';
                errorDiv.classList.remove('hidden');
                return;
            }

            if (users[username]) {
                errorDiv.textContent = 'Username already exists';
                errorDiv.classList.remove('hidden');
                return;
            }

            // Create new user
            users[username] = {
                password: password,
                created: new Date().toISOString()
            };
            localStorage.setItem('trackerUsers', JSON.stringify(users));

            // Auto-login
            currentUser = username;
            localStorage.setItem('currentUser', username);
            showTrackerApp();
        }

        function logout() {
            if (confirm('Are you sure you want to logout?')) {
                currentUser = null;
                localStorage.removeItem('currentUser');
                document.getElementById('authScreen').classList.remove('hidden');
                document.getElementById('trackerApp').classList.add('hidden');
                showLogin();
                // Clear form fields
                document.getElementById('loginUsername').value = '';
                document.getElementById('loginPassword').value = '';
            }
        }

        function showTrackerApp() {
            document.getElementById('authScreen').classList.add('hidden');
            document.getElementById('trackerApp').classList.remove('hidden');
            // Load user's specific data
            loadUserData();
            loadCustomAccounts();
            setTodayDate();
            
            // Run data migrations
            runDataMigrations();
            
            renderOpenTrades();
            renderAllTrades();
            updateStats();
        }

        // Data Migration System
        function runDataMigrations() {
            if (!currentUser) return;
            
            const versionKey = getUserStorageKey('dataVersion');
            const currentVersion = parseInt(localStorage.getItem(versionKey)) || 1;
            
            console.log('Current data version:', currentVersion);
            console.log('Target data version:', CURRENT_DATA_VERSION);
            
            if (currentVersion < CURRENT_DATA_VERSION) {
                console.log('Running migrations from version', currentVersion, 'to', CURRENT_DATA_VERSION);
                
                // Migration 1 → 2: Mark existing rolled positions
                if (currentVersion < 2) {
                    migration_v2_markRolledTrades();
                }
                
                // Future migrations go here
                // if (currentVersion < 3) {
                //     migration_v3_someOtherFix();
                // }
                
                // Update version
                localStorage.setItem(versionKey, CURRENT_DATA_VERSION);
                console.log('Migrations complete! Data version now:', CURRENT_DATA_VERSION);
                
                // Save migrated data
                saveData();
            } else {
                console.log('Data is up to date, no migrations needed');
            }
        }

        // Migration v1 → v2: Mark existing rolled positions
        function migration_v2_markRolledTrades() {
            console.log('Running migration v2: Marking rolled trades');
            
            let markedCount = 0;
            
            // Mark open trades with "Rolled:" in info
            trades.forEach(trade => {
                if (trade.info && trade.info.toLowerCase().includes('rolled:') && !trade.isRolled) {
                    trade.isRolled = true;
                    markedCount++;
                    console.log('Marked as rolled:', trade.symbol, trade.strike, trade.dateOpened);
                }
            });
            
            // Also check closed trades
            closedTrades.forEach(trade => {
                if (trade.info && trade.info.toLowerCase().includes('rolled:') && !trade.isRolled) {
                    trade.isRolled = true;
                    markedCount++;
                    console.log('Marked closed trade as rolled:', trade.symbol, trade.strike, trade.dateOpened);
                }
            });
            
            // Check trades in groups
            tradeGroups.forEach(group => {
                if (group.trades && Array.isArray(group.trades)) {
                    group.trades.forEach(trade => {
                        if (trade.info && trade.info.toLowerCase().includes('rolled:') && !trade.isRolled) {
                            trade.isRolled = true;
                            markedCount++;
                            console.log('Marked group trade as rolled:', trade.symbol, trade.strike, trade.dateOpened);
                        }
                    });
                }
            });
            
            console.log('Migration v2 complete: Marked', markedCount, 'trades as rolled');
        }

        function checkAuth() {
            const savedUser = localStorage.getItem('currentUser');
            if (savedUser && users[savedUser]) {
                currentUser = savedUser;
                showTrackerApp();
            } else {
                document.getElementById('authScreen').classList.remove('hidden');
                document.getElementById('trackerApp').classList.add('hidden');
            }
        }

        // User-specific data storage
        function getUserStorageKey(key) {
            return `${currentUser}_${key}`;
        }

        function loadUserData() {
            trades = JSON.parse(localStorage.getItem(getUserStorageKey('wheelTrades'))) || [];
            closedTrades = JSON.parse(localStorage.getItem(getUserStorageKey('wheelClosedTrades'))) || [];
            tradeGroups = JSON.parse(localStorage.getItem(getUserStorageKey('wheelTradeGroups'))) || [];
            customAccounts = JSON.parse(localStorage.getItem(getUserStorageKey('customAccounts'))) || [];
        }

        function saveUserData() {
            localStorage.setItem(getUserStorageKey('wheelTrades'), JSON.stringify(trades));
            localStorage.setItem(getUserStorageKey('wheelClosedTrades'), JSON.stringify(closedTrades));
            localStorage.setItem(getUserStorageKey('wheelTradeGroups'), JSON.stringify(tradeGroups));
            localStorage.setItem(getUserStorageKey('customAccounts'), JSON.stringify(customAccounts));
        }

        // Original variables
        let trades = [];
        let closedTrades = [];
        let tradeGroups = []; // Groups of related trades (open + close)
        let customAccounts = []; // User-defined account names
        let editingIndex = -1;
        
        // Data version for migrations
        const CURRENT_DATA_VERSION = 2;
        let editingFromArray = 'open'; // Track which array we're editing from
        let editingFromGroup = -1; // Track if editing from a group
        let closingIndex = -1;
        let rollingIndex = -1; // Track which position is being rolled
        let currentTab = 'dashboard';
        
        // Sort state
        let openTradesSortField = 'dateOpened';
        let openTradesSortOrder = 'desc'; // 'asc' or 'desc'
        let allTradesSortField = 'dateOpened';
        let allTradesSortOrder = 'desc';
        let allTradesFilter = 'all'; // 'all', 'open', 'closed', 'rolled'
        let groupsSortField = 'dateOpened';
        let groupsSortOrder = 'desc';
        let filteredTradesSortField = 'dateOpened';
        let filteredTradesSortOrder = 'desc';
        let expirationTradesSortField = 'expDate';
        let expirationTradesSortOrder = 'asc'; // Expiration should default to soonest first
        
        // Undo functionality
        let lastDeletedTrade = null;
        let lastDeletedFrom = null; // 'open', 'closed', or 'group'
        let lastDeletedGroupInfo = null; // Store group info if deleted from group

        // Load data from localStorage on page load
        window.onload = function() {
            checkAuth(); // Check authentication and show appropriate screen
        };

        function setTodayDate() {
            const today = new Date().toISOString().split('T')[0];
            document.getElementById('dateOpened').value = today;
            document.getElementById('closeDate').value = today;
        }

        function switchTab(tabName) {
            currentTab = tabName;
            
            // Update tab buttons
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });
            event.target.classList.add('active');
            
            // Update content
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            document.getElementById(tabName + 'Tab').classList.add('active');
            
            // Render appropriate table
            if (tabName === 'all') {
                renderAllTrades();
            } else if (tabName === 'groups') {
                renderGroups();
            }
        }

        function addTrade() {
            const tradeRef = document.getElementById('tradeRef').value.trim();
            const symbol = document.getElementById('symbol').value.toUpperCase().trim();
            const contracts = parseInt(document.getElementById('contracts').value);
            const strike = parseFloat(document.getElementById('strike').value);
            const premium = parseFloat(document.getElementById('premium').value);
            const action = document.getElementById('action').value;
            const type = document.getElementById('type').value;
            const dateOpened = document.getElementById('dateOpened').value;
            const expDate = document.getElementById('expDate').value;
            const priceAtAction = parseFloat(document.getElementById('priceAtAction').value);
            const info = document.getElementById('info').value;
            const account = document.getElementById('account').value;

            if (!symbol || !contracts || !strike || !premium || !dateOpened || !expDate || !priceAtAction) {
                alert('Please fill in all required fields');
                return;
            }

            const trade = {
                id: Date.now() + Math.random(), // Unique ID
                tradeRef: tradeRef || '', // Trade reference number
                account: account || '', // Account name
                groupId: `${symbol}-${strike}-${type}-${expDate}`, // Group related trades
                symbol,
                contracts,
                strike,
                premium,
                action,
                type,
                dateOpened,
                expDate,
                priceAtAction,
                info,
                status: 'open'
            };

            trades.push(trade);
            saveData();
            renderTables();
            updateStats();
            clearForm();
        }

        function clearForm() {
            document.getElementById('tradeRef').value = '';
            document.getElementById('symbol').value = '';
            document.getElementById('contracts').value = '1';
            document.getElementById('strike').value = '';
            document.getElementById('premium').value = '';
            document.getElementById('priceAtAction').value = '';
            document.getElementById('info').value = '';
            document.getElementById('account').value = '';
            setTodayDate();
        }

        function addNewAccount() {
            console.log('addNewAccount called - opening modal');
            document.getElementById('newAccountName').value = '';
            document.getElementById('accountModal').classList.add('active');
        }

        function closeAccountModal() {
            document.getElementById('accountModal').classList.remove('active');
        }

        function saveNewAccount() {
            const accountName = document.getElementById('newAccountName').value.trim();
            console.log('Saving account:', accountName);
            
            if (!accountName) {
                alert('Please enter an account name');
                return;
            }
            
            if (customAccounts.includes(accountName)) {
                alert(`Account "${accountName}" already exists!`);
                return;
            }
            
            customAccounts.push(accountName);
            console.log('Added to customAccounts:', customAccounts);
            saveCustomAccounts();
            populateAccountDropdowns();
            document.getElementById('account').value = accountName;
            closeAccountModal();
            alert(`Account "${accountName}" added successfully!`);
        }

        function populateAccountDropdowns() {
            const dropdowns = ['account'];
            dropdowns.forEach(id => {
                const dropdown = document.getElementById(id);
                if (dropdown) {
                    const currentValue = dropdown.value;
                    dropdown.innerHTML = '<option value="">Select Account...</option>' +
                        '<option value="Main">Main</option>' +
                        '<option value="IRA">IRA</option>' +
                        '<option value="Roth IRA">Roth IRA</option>' +
                        customAccounts.map(acc => `<option value="${acc}">${acc}</option>`).join('');
                    dropdown.value = currentValue;
                }
            });
        }

        function saveCustomAccounts() {
            if (currentUser) {
                localStorage.setItem(getUserStorageKey('customAccounts'), JSON.stringify(customAccounts));
            } else {
                localStorage.setItem('customAccounts', JSON.stringify(customAccounts));
            }
        }

        function loadCustomAccounts() {
            const key = currentUser ? getUserStorageKey('customAccounts') : 'customAccounts';
            const saved = localStorage.getItem(key);
            if (saved) {
                try {
                    customAccounts = JSON.parse(saved);
                    if (!Array.isArray(customAccounts)) customAccounts = [];
                } catch (e) {
                    customAccounts = [];
                }
            }
            populateAccountDropdowns();
        }

        function calculateCashRequired(trade) {
            if (trade.type === 'put' && trade.action === 'sell') {
                return trade.strike * trade.contracts * 100;
            }
            return 0;
        }

        function calculateReturnPercent(trade) {
            const cashRequired = calculateCashRequired(trade);
            const totalPremium = trade.premium * trade.contracts * 100;
            
            // For BUY actions, this is a cost (negative return)
            const multiplier = trade.action === 'buy' ? -1 : 1;
            
            if (cashRequired === 0) {
                const stockValue = trade.strike * trade.contracts * 100;
                return ((multiplier * totalPremium / stockValue) * 100).toFixed(2);
            }
            
            return ((multiplier * totalPremium / cashRequired) * 100).toFixed(2);
        }

        function calculateOTM(trade) {
            if (trade.type === 'put') {
                const diff = ((trade.priceAtAction - trade.strike) / trade.strike * 100);
                return diff.toFixed(2);
            } else {
                const diff = ((trade.strike - trade.priceAtAction) / trade.priceAtAction * 100);
                return diff.toFixed(2);
            }
        }

        function calculatePL(trade) {
            const premiumCollected = trade.premium * trade.contracts * 100;
            const closingCost = (trade.closingPremium || 0) * trade.contracts * 100;
            
            if (trade.action === 'sell') {
                // For closed positions, calculate actual P&L
                if (trade.status === 'closed') {
                    return premiumCollected - closingCost;
                }
                
                // For open positions, just show premium collected
                // (We don't know current market value, so can't calculate unrealized P&L)
                return premiumCollected;
            } else {
                // For BUY positions, premium paid is a cost
                return -premiumCollected;
            }
        }

        function renderTables() {
            renderOpenTrades();
            if (currentTab === 'groups') {
                renderGroups();
            } else if (currentTab === 'all') {
                renderAllTrades();
            }
        }

        function sortFilteredTrades(field, order) {
            filteredTradesSortField = field;
            filteredTradesSortOrder = order;
            filterByStock(); // Re-render with new sort
        }

        function sortExpirationTrades(field, order) {
            expirationTradesSortField = field;
            expirationTradesSortOrder = order;
            renderTradesByExpiration(); // Re-render with new sort
        }

        function sortOpenTrades(field, order) {
            openTradesSortField = field;
            openTradesSortOrder = order;
            renderOpenTrades();
        }

        function renderOpenTrades() {
            const tbody = document.getElementById('openTradesTableBody');
            if (!tbody) {
                console.error('openTradesTableBody not found');
                return;
            }
            
            if (trades.length === 0) {
                tbody.innerHTML = `
                    <tr>
                        <td colspan="15" style="text-align: center; color: #666; padding: 40px;">
                            No open positions. Add your first trade above.
                        </td>
                    </tr>
                `;
                
                // Clear stock filter dropdown
                const stockFilter = document.getElementById('stockFilter');
                if (stockFilter) {
                    stockFilter.innerHTML = '<option value="">Select a stock...</option>';
                }
                
                // Clear filtered table
                const filteredTbody = document.getElementById('filteredTradesTableBody');
                if (filteredTbody) {
                    filteredTbody.innerHTML = `
                        <tr>
                            <td colspan="15" style="text-align: center; color: #666; padding: 40px;">
                                No open positions available.
                            </td>
                        </tr>
                    `;
                }
                return;
            }

            // Sort by the selected field and order
            const sortedTrades = [...trades].sort((a, b) => {
                const aDate = new Date(a[openTradesSortField]);
                const bDate = new Date(b[openTradesSortField]);
                if (openTradesSortOrder === 'asc') {
                    return aDate - bDate;
                } else {
                    return bDate - aDate;
                }
            });

            tbody.innerHTML = sortedTrades.map((trade) => {
                const actualIndex = trades.indexOf(trade);
                const cashRequired = calculateCashRequired(trade);
                const returnPercent = calculateReturnPercent(trade);
                const otm = calculateOTM(trade);
                const pl = calculatePL(trade);

                return `
                    <tr>
                        <td><strong>${trade.symbol}</strong>${trade.isRolled ? '<span class="rolled-badge">Rolled</span>' : ''}</td>
                        <td>${trade.contracts}</td>
                        <td>$${trade.strike.toFixed(2)}</td>
                        <td>$${trade.premium.toFixed(2)}</td>
                        <td><span class="action-badge ${trade.action}">${trade.action.toUpperCase()}</span></td>
                        <td><span class="type-badge ${trade.type}">${trade.type.toUpperCase()}</span></td>
                        <td>${formatDate(trade.dateOpened)}</td>
                        <td>${formatDate(trade.expDate)}</td>
                        <td>${cashRequired > 0 ? '$' + cashRequired.toLocaleString() : '-'}</td>
                        <td class="${parseFloat(returnPercent) >= 0 ? 'positive-value' : 'negative-value'}">${returnPercent}%</td>
                        <td>$${trade.priceAtAction.toFixed(2)}</td>
                        <td class="${parseFloat(otm) >= 0 ? 'positive-value' : 'negative-value'}">${otm}%</td>
                        <td class="${pl >= 0 ? 'positive-value' : 'negative-value'}">$${pl.toFixed(2)}</td>
                        <td style="max-width: 150px; overflow: hidden; text-overflow: ellipsis;">${trade.info || '-'}</td>
                        <td style="color: #00ff88;"><strong>${trade.tradeRef || '-'}</strong></td>
                        <td>${trade.account || '-'}</td>
                        <td>
                            <div class="action-buttons">
                                <button class="btn-small" onclick="editTrade(${actualIndex})">Edit</button>
                                <button class="btn-small" style="background: #4488ff; color: #fff;" onclick="openRollModal(${actualIndex})">Roll</button>
                                <button class="btn-small success" onclick="openCloseModal(${actualIndex})">Close</button>
                                <button class="btn-small danger" onclick="deleteTrade(${actualIndex})">Delete</button>
                            </div>
                        </td>
                    </tr>
                `;
            }).join('');
            
            // Populate stock filter dropdown
            populateStockFilter();
            
            // Also render by expiration
            renderTradesByExpiration();
        }

        function populateStockFilter() {
            const stockFilter = document.getElementById('stockFilter');
            if (!stockFilter) return;
            
            // Get unique symbols from open trades
            const symbols = [...new Set(trades.map(t => t.symbol))].sort();
            
            stockFilter.innerHTML = '<option value="">Select a stock...</option>' + 
                symbols.map(symbol => `<option value="${symbol}">${symbol}</option>`).join('');
        }

        function calculateDaysToExpiration(expDate) {
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            const exp = new Date(expDate + 'T00:00:00');
            const diffTime = exp - today;
            const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
            return diffDays;
        }

        function renderTradesByExpiration() {
            const tbody = document.getElementById('expirationTradesTableBody');
            if (!tbody) return;

            if (trades.length === 0) {
                tbody.innerHTML = `
                    <tr>
                        <td colspan="18" style="text-align: center; color: #666; padding: 40px;">
                            No open positions.
                        </td>
                    </tr>
                `;
                return;
            }

            // Sort by the selected field and order
            const sortedTrades = [...trades].sort((a, b) => {
                const aDate = new Date(a[expirationTradesSortField]);
                const bDate = new Date(b[expirationTradesSortField]);
                if (expirationTradesSortOrder === 'asc') {
                    return aDate - bDate;
                } else {
                    return bDate - aDate;
                }
            });

            tbody.innerHTML = sortedTrades.map((trade) => {
                const actualIndex = trades.indexOf(trade);
                const cashRequired = calculateCashRequired(trade);
                const returnPercent = calculateReturnPercent(trade);
                const otm = calculateOTM(trade);
                const pl = calculatePL(trade);
                const daysToExp = calculateDaysToExpiration(trade.expDate);
                
                // Color code days to expiration
                let daysColor = '#00ff88'; // green (11+ days)
                if (daysToExp <= 7) {
                    daysColor = '#ff4444'; // red (7 days or less)
                } else if (daysToExp >= 8 && daysToExp <= 10) {
                    daysColor = '#888888'; // grey (8-10 days)
                }

                return `
                    <tr>
                        <td><strong>${trade.symbol}</strong>${trade.isRolled ? '<span class="rolled-badge">Rolled</span>' : ''}</td>
                        <td>${trade.contracts}</td>
                        <td>$${trade.strike.toFixed(2)}</td>
                        <td>$${trade.premium.toFixed(2)}</td>
                        <td><span class="action-badge ${trade.action}">${trade.action.toUpperCase()}</span></td>
                        <td><span class="type-badge ${trade.type}">${trade.type.toUpperCase()}</span></td>
                        <td>${formatDate(trade.dateOpened)}</td>
                        <td>${formatDate(trade.expDate)}</td>
                        <td style="color: ${daysColor}; font-weight: bold; font-size: 1.1rem;">${daysToExp}</td>
                        <td>${cashRequired > 0 ? '$' + cashRequired.toLocaleString() : '-'}</td>
                        <td class="${parseFloat(returnPercent) >= 0 ? 'positive-value' : 'negative-value'}">${returnPercent}%</td>
                        <td>$${trade.priceAtAction.toFixed(2)}</td>
                        <td class="${parseFloat(otm) >= 0 ? 'positive-value' : 'negative-value'}">${otm}%</td>
                        <td class="${pl >= 0 ? 'positive-value' : 'negative-value'}">$${pl.toFixed(2)}</td>
                        <td style="max-width: 150px; overflow: hidden; text-overflow: ellipsis;">${trade.info || '-'}</td>
                        <td style="color: #00ff88;"><strong>${trade.tradeRef || '-'}</strong></td>
                        <td>${trade.account || '-'}</td>
                        <td>
                            <div class="action-buttons">
                                <button class="btn-small" onclick="editTrade(${actualIndex})">Edit</button>
                                <button class="btn-small" style="background: #4488ff; color: #fff;" onclick="openRollModal(${actualIndex})">Roll</button>
                                <button class="btn-small success" onclick="openCloseModal(${actualIndex})">Close</button>
                                <button class="btn-small danger" onclick="deleteTrade(${actualIndex})">Delete</button>
                            </div>
                        </td>
                    </tr>
                `;
            }).join('');
        }

        function filterByStock() {
            const stockFilter = document.getElementById('stockFilter');
            const selectedSymbol = stockFilter.value;
            const filteredTbody = document.getElementById('filteredTradesTableBody');
            
            if (!filteredTbody) return;
            
            if (!selectedSymbol) {
                filteredTbody.innerHTML = `
                    <tr>
                        <td colspan="17" style="text-align: center; color: #666; padding: 40px;">
                            Select a stock from the dropdown above to view positions.
                        </td>
                    </tr>
                `;
                return;
            }
            
            // Filter trades by selected symbol
            const filteredTrades = trades.filter(t => t.symbol === selectedSymbol);
            
            if (filteredTrades.length === 0) {
                filteredTbody.innerHTML = `
                    <tr>
                        <td colspan="17" style="text-align: center; color: #666; padding: 40px;">
                            No positions found for ${selectedSymbol}.
                        </td>
                    </tr>
                `;
                return;
            }
            
            // Sort filtered trades
            filteredTrades.sort((a, b) => {
                const aDate = new Date(a[filteredTradesSortField]);
                const bDate = new Date(b[filteredTradesSortField]);
                if (filteredTradesSortOrder === 'asc') {
                    return aDate - bDate;
                } else {
                    return bDate - aDate;
                }
            });
            
            // Calculate totals for this symbol
            let symbolCollateral = 0;
            let symbolPL = 0;
            let html = '';
            
            filteredTrades.forEach((trade, index) => {
                const actualIndex = trades.indexOf(trade);
                const cashRequired = calculateCashRequired(trade);
                const returnPercent = calculateReturnPercent(trade);
                const otm = calculateOTM(trade);
                const pl = calculatePL(trade);
                
                symbolCollateral += cashRequired;
                symbolPL += pl;

                // Current open position row
                html += `
                    <tr style="background: #0a0a0a;">
                        <td><strong>${trade.symbol}</strong>${trade.isRolled ? '<span class="rolled-badge">Rolled</span>' : ''}</td>
                        <td>${trade.contracts}</td>
                        <td>$${trade.strike.toFixed(2)}</td>
                        <td>$${trade.premium.toFixed(2)}</td>
                        <td><span class="action-badge ${trade.action}">${trade.action.toUpperCase()}</span></td>
                        <td><span class="type-badge ${trade.type}">${trade.type.toUpperCase()}</span></td>
                        <td>${formatDate(trade.dateOpened)}</td>
                        <td>${formatDate(trade.expDate)}</td>
                        <td>${cashRequired > 0 ? '$' + cashRequired.toLocaleString() : '-'}</td>
                        <td class="${parseFloat(returnPercent) >= 0 ? 'positive-value' : 'negative-value'}">${returnPercent}%</td>
                        <td>$${trade.priceAtAction.toFixed(2)}</td>
                        <td class="${parseFloat(otm) >= 0 ? 'positive-value' : 'negative-value'}">${otm}%</td>
                        <td class="${pl >= 0 ? 'positive-value' : 'negative-value'}">$${pl.toFixed(2)}</td>
                        <td style="max-width: 150px; overflow: hidden; text-overflow: ellipsis;">${trade.info || '-'}</td>
                        <td style="color: #00ff88;"><strong>${trade.tradeRef || '-'}</strong></td>
                        <td>${trade.account || '-'}</td>
                        <td>
                            <div class="action-buttons">
                                <button class="btn-small" onclick="editTrade(${actualIndex})">Edit</button>
                                <button class="btn-small" style="background: #4488ff; color: #fff;" onclick="openRollModal(${actualIndex})">Roll</button>
                                <button class="btn-small success" onclick="openCloseModal(${actualIndex})">Close</button>
                                <button class="btn-small danger" onclick="deleteTrade(${actualIndex})">Delete</button>
                            </div>
                        </td>
                    </tr>
                `;
                
                // Find roll history for this position
                const rollHistory = findRollHistory(trade);
                
                console.log('Roll history for', trade.symbol, trade.strike, ':', rollHistory.length, 'trades');
                
                if (rollHistory.length > 0) {
                    // Calculate cumulative P&L for this roll chain
                    let rollPL = 0;
                    
                    // Add current open position premium (if sold)
                    if (trade.action === 'sell') {
                        rollPL += trade.premium * trade.contracts * 100;
                        console.log('Current position premium:', trade.premium * trade.contracts * 100);
                    }
                    
                    // Calculate P&L from all history trades
                    rollHistory.forEach(histTrade => {
                        const amount = histTrade.premium * histTrade.contracts * 100;
                        if (histTrade.action === 'sell') {
                            rollPL += amount;
                            console.log('History SELL:', amount);
                        } else {
                            rollPL -= amount;
                            console.log('History BUY:', -amount);
                        }
                    });
                    
                    console.log('Total Roll P/L:', rollPL);
                    
                    html += `
                        <tr style="background: #1a1a1a; border-top: 1px solid #444; border-bottom: 1px solid #444;">
                            <td colspan="12" style="padding: 12px 15px;">
                                <strong style="color: #888;">Roll History</strong>
                            </td>
                            <td colspan="5" style="padding: 12px 15px; text-align: right;">
                                <strong style="color: #fff;">Current Roll P/L: </strong>
                                <strong class="${rollPL >= 0 ? 'positive-value' : 'negative-value'}" style="font-size: 1.1rem;">
                                    ${rollPL >= 0 ? '+' : ''}$${rollPL.toFixed(2)}
                                </strong>
                            </td>
                        </tr>
                    `;
                    
                    rollHistory.forEach(historyTrade => {
                        const histCashRequired = calculateCashRequired(historyTrade);
                        const histReturnPercent = calculateReturnPercent(historyTrade);
                        const histOtm = calculateOTM(historyTrade);
                        const histPl = calculatePL(historyTrade);
                        
                        html += `
                            <tr style="background: #050505; opacity: 0.7;">
                                <td style="padding-left: 30px;">${historyTrade.symbol}</td>
                                <td>${historyTrade.contracts}</td>
                                <td>$${historyTrade.strike.toFixed(2)}</td>
                                <td>$${historyTrade.premium.toFixed(2)}</td>
                                <td><span class="action-badge ${historyTrade.action}">${historyTrade.action.toUpperCase()}</span></td>
                                <td><span class="type-badge ${historyTrade.type}">${historyTrade.type.toUpperCase()}</span></td>
                                <td>${formatDate(historyTrade.dateOpened)}</td>
                                <td>${formatDate(historyTrade.expDate)}</td>
                                <td>${histCashRequired > 0 ? '$' + histCashRequired.toLocaleString() : '-'}</td>
                                <td class="${parseFloat(histReturnPercent) >= 0 ? 'positive-value' : 'negative-value'}">${histReturnPercent}%</td>
                                <td>$${historyTrade.priceAtAction.toFixed(2)}</td>
                                <td class="${parseFloat(histOtm) >= 0 ? 'positive-value' : 'negative-value'}">${histOtm}%</td>
                                <td class="${histPl >= 0 ? 'positive-value' : 'negative-value'}">$${histPl.toFixed(2)}</td>
                                <td style="max-width: 150px; overflow: hidden; text-overflow: ellipsis;">${historyTrade.info || '-'}</td>
                                <td style="color: #00ff88;"><strong>${historyTrade.tradeRef || '-'}</strong></td>
                                <td>${historyTrade.account || '-'}</td>
                                <td style="color: #666;">ROLLED</td>
                            </tr>
                        `;
                    });
                }
                
                // Add spacing between different positions
                html += `<tr style="height: 20px; background: #000;"><td colspan="17"></td></tr>`;
            });
            
            // Add totals row
            html += `
                <tr style="background: #0a0a0a; font-weight: bold; border-top: 2px solid #fff;">
                    <td colspan="8" style="text-align: right; padding: 15px;"><strong>${selectedSymbol} Totals:</strong></td>
                    <td>$${symbolCollateral.toLocaleString()}</td>
                    <td>-</td>
                    <td>-</td>
                    <td>-</td>
                    <td class="${symbolPL >= 0 ? 'positive-value' : 'negative-value'}">$${symbolPL.toFixed(2)}</td>
                    <td colspan="4">-</td>
                </tr>
            `;
            
            filteredTbody.innerHTML = html;
        }

        function findRollHistory(currentTrade) {
            const history = [];
            const processedGroups = new Set();
            
            console.log('Finding roll history for:', currentTrade.symbol, currentTrade.strike, currentTrade.dateOpened);
            
            // Function to recursively find all related roll groups
            function findRelatedGroups(symbol) {
                tradeGroups.forEach(group => {
                    if (processedGroups.has(group.id)) return;
                    if (!group.trades || !Array.isArray(group.trades)) return;
                    
                    // Check if this group contains the symbol and is a roll group
                    const hasMatchingSymbol = group.trades.some(t => t.symbol === symbol);
                    const isRollGroup = group.name.includes('Roll') || 
                                       group.trades.some(t => t.info && (t.info.includes('Roll') || t.info.includes('roll')));
                    
                    if (hasMatchingSymbol && isRollGroup) {
                        console.log('Found roll group:', group.name);
                        processedGroups.add(group.id);
                        
                        // Add all trades from this group except the current open one
                        group.trades.forEach(t => {
                            // Don't add the exact current trade
                            const isCurrent = t.symbol === currentTrade.symbol && 
                                            t.strike === currentTrade.strike && 
                                            t.dateOpened === currentTrade.dateOpened &&
                                            t.expDate === currentTrade.expDate &&
                                            t.premium === currentTrade.premium &&
                                            t.status === 'open';
                            
                            if (!isCurrent) {
                                // Check if this trade isn't already in history
                                const alreadyAdded = history.some(h => 
                                    h.symbol === t.symbol &&
                                    h.strike === t.strike &&
                                    h.dateOpened === t.dateOpened &&
                                    h.premium === t.premium &&
                                    h.action === t.action
                                );
                                
                                if (!alreadyAdded) {
                                    console.log('Adding to history:', t.symbol, t.strike, t.action, t.premium, t.dateOpened);
                                    history.push(t);
                                }
                            }
                        });
                    }
                });
            }
            
            // Find all related roll groups for this symbol
            findRelatedGroups(currentTrade.symbol);
            
            console.log('Total history trades found:', history.length);
            
            // Sort by date (oldest first)
            history.sort((a, b) => new Date(a.dateOpened) - new Date(b.dateOpened));
            
            return history;
        }

        function renderClosedTrades() {
            const tbody = document.getElementById('closedTradesTableBody');
            if (!tbody) return; // Exit if element doesn't exist yet
            
            if (closedTrades.length === 0) {
                tbody.innerHTML = `
                    <tr>
                        <td colspan="14" style="text-align: center; color: #666; padding: 40px;">
                            No closed positions yet.
                        </td>
                    </tr>
                `;
                return;
            }

            tbody.innerHTML = closedTrades.map((trade, index) => {
                const cashRequired = calculateCashRequired(trade);
                const returnPercent = calculateReturnPercent(trade);
                const pl = calculatePL(trade);

                return `
                    <tr>
                        <td><strong>${trade.symbol}</strong></td>
                        <td>${trade.contracts}</td>
                        <td>$${trade.strike.toFixed(2)}</td>
                        <td>$${trade.premium.toFixed(2)}</td>
                        <td><span class="action-badge ${trade.action}">${trade.action.toUpperCase()}</span></td>
                        <td><span class="type-badge ${trade.type}">${trade.type.toUpperCase()}</span></td>
                        <td>${formatDate(trade.dateOpened)}</td>
                        <td>${formatDate(trade.dateClosed)}</td>
                        <td>${formatDate(trade.expDate)}</td>
                        <td>${cashRequired > 0 ? '$' + cashRequired.toLocaleString() : '-'}</td>
                        <td class="${parseFloat(returnPercent) >= 0 ? 'positive-value' : 'negative-value'}">${returnPercent}%</td>
                        <td class="${pl >= 0 ? 'positive-value' : 'negative-value'}">$${pl.toFixed(2)}</td>
                        <td style="max-width: 200px; overflow: hidden; text-overflow: ellipsis;">${trade.closingNotes || trade.info || '-'}</td>
                        <td>
                            <div class="action-buttons">
                                <button class="btn-small" onclick="reopenTrade(${index})">Reopen</button>
                                <button class="btn-small danger" onclick="deleteClosedTrade(${index})">Delete</button>
                            </div>
                        </td>
                    </tr>
                `;
            }).join('');
        }

        function sortAllTrades(field, order) {
            allTradesSortField = field;
            allTradesSortOrder = order;
            renderAllTrades();
        }

        function filterAllTrades(filterType) {
            allTradesFilter = filterType;
            
            // Update button styles
            document.getElementById('filterAllBtn').style.background = filterType === 'all' ? '#00ff88' : '#333';
            document.getElementById('filterAllBtn').style.color = filterType === 'all' ? '#000' : '#fff';
            document.getElementById('filterOpenBtn').style.background = filterType === 'open' ? '#00ff88' : '#333';
            document.getElementById('filterOpenBtn').style.color = filterType === 'open' ? '#000' : '#fff';
            document.getElementById('filterClosedBtn').style.background = filterType === 'closed' ? '#00ff88' : '#333';
            document.getElementById('filterClosedBtn').style.color = filterType === 'closed' ? '#000' : '#fff';
            document.getElementById('filterRolledBtn').style.background = filterType === 'rolled' ? '#00ff88' : '#333';
            document.getElementById('filterRolledBtn').style.color = filterType === 'rolled' ? '#000' : '#fff';
            
            renderAllTrades();
        }

        function renderAllTrades() {
            const tbody = document.getElementById('allTradesTableBody');
            if (!tbody) return; // Exit if element doesn't exist yet
            
            // Collect all trades from all sources
            const openTrades = trades.map(t => ({...t, isOpen: true}));
            const closedTradesArray = closedTrades.map(t => ({...t, isOpen: false}));
            
            // Also get trades from groups that might not be in closedTrades
            const groupTrades = [];
            tradeGroups.forEach(group => {
                if (group.trades && Array.isArray(group.trades)) {
                    group.trades.forEach(trade => {
                        // Check if this trade is already in openTrades or closedTrades
                        const alreadyExists = openTrades.some(t => 
                            t.symbol === trade.symbol && 
                            t.dateOpened === trade.dateOpened && 
                            t.strike === trade.strike &&
                            t.premium === trade.premium &&
                            t.action === trade.action
                        ) || closedTradesArray.some(t => 
                            t.symbol === trade.symbol && 
                            t.dateOpened === trade.dateOpened && 
                            t.strike === trade.strike &&
                            t.premium === trade.premium &&
                            t.action === trade.action
                        );
                        
                        if (!alreadyExists) {
                            groupTrades.push({...trade, isOpen: trade.status === 'open'});
                        }
                    });
                }
            });
            
            const allTrades = [...openTrades, ...closedTradesArray, ...groupTrades];
            
            console.log('renderAllTrades - Open trades:', openTrades.length);
            console.log('renderAllTrades - Closed trades:', closedTradesArray.length);
            console.log('renderAllTrades - Group trades (unique):', groupTrades.length);
            console.log('renderAllTrades - Total allTrades:', allTrades.length);
            console.log('All trades data:', allTrades);
            
            // Apply filter
            let filteredTrades = allTrades;
            if (allTradesFilter === 'open') {
                filteredTrades = allTrades.filter(t => t.isOpen);
            } else if (allTradesFilter === 'closed') {
                filteredTrades = allTrades.filter(t => !t.isOpen);
            } else if (allTradesFilter === 'rolled') {
                // Find all Trade Ref #s that have at least one rolled position
                const rolledTradeRefs = new Set();
                allTrades.forEach(t => {
                    if (t.isRolled && t.tradeRef && t.tradeRef.trim()) {
                        rolledTradeRefs.add(t.tradeRef);
                    }
                });
                
                // Show all trades that either:
                // 1. Are marked as rolled, OR
                // 2. Share a Trade Ref # with a rolled position
                filteredTrades = allTrades.filter(t => {
                    if (t.isRolled) return true; // Always show rolled positions
                    if (t.tradeRef && t.tradeRef.trim() && rolledTradeRefs.has(t.tradeRef)) {
                        return true; // Show trades with same Trade Ref as rolled positions
                    }
                    return false;
                });
            }
            
            if (filteredTrades.length === 0) {
                tbody.innerHTML = `
                    <tr>
                        <td colspan="17" style="text-align: center; color: #666; padding: 40px;">
                            No trades found for this filter.
                        </td>
                    </tr>
                `;
                return;
            }

            // Sort by the selected field and order
            filteredTrades.sort((a, b) => {
                let aValue, bValue;
                
                if (allTradesSortField === 'dateClosed') {
                    // For dateClosed, treat null/undefined as very old dates for sorting
                    aValue = a.dateClosed ? new Date(a.dateClosed) : new Date('1900-01-01');
                    bValue = b.dateClosed ? new Date(b.dateClosed) : new Date('1900-01-01');
                } else {
                    aValue = new Date(a[allTradesSortField]);
                    bValue = new Date(b[allTradesSortField]);
                }
                
                if (allTradesSortOrder === 'asc') {
                    return aValue - bValue;
                } else {
                    return bValue - aValue;
                }
            });

            tbody.innerHTML = filteredTrades.map((trade, index) => {
                const cashRequired = calculateCashRequired(trade);
                const returnPercent = calculateReturnPercent(trade);
                const pl = calculatePL(trade);
                const statusBadge = trade.isOpen ? 
                    '<span class="status-badge open">OPEN</span>' : 
                    '<span class="status-badge closed">CLOSED</span>';

                return `
                    <tr>
                        <td>${statusBadge}</td>
                        <td><strong>${trade.symbol}</strong>${trade.isRolled ? '<span class="rolled-badge">Rolled</span>' : ''}</td>
                        <td>${trade.contracts}</td>
                        <td>$${trade.strike.toFixed(2)}</td>
                        <td>$${trade.premium.toFixed(2)}</td>
                        <td><span class="action-badge ${trade.action}">${trade.action.toUpperCase()}</span></td>
                        <td><span class="type-badge ${trade.type}">${trade.type.toUpperCase()}</span></td>
                        <td>${formatDate(trade.dateOpened)}</td>
                        <td>${trade.dateClosed ? formatDate(trade.dateClosed) : '-'}</td>
                        <td>${formatDate(trade.expDate)}</td>
                        <td>${cashRequired > 0 ? '$' + cashRequired.toLocaleString() : '-'}</td>
                        <td class="${parseFloat(returnPercent) >= 0 ? 'positive-value' : 'negative-value'}">${returnPercent}%</td>
                        <td class="${pl >= 0 ? 'positive-value' : 'negative-value'}">$${pl.toFixed(2)}</td>
                        <td style="max-width: 200px; overflow: hidden; text-overflow: ellipsis;">${trade.closingNotes || trade.info || '-'}</td>
                        <td style="color: #00ff88;"><strong>${trade.tradeRef || '-'}</strong></td>
                        <td>${trade.account || '-'}</td>
                        <td>
                            <div class="action-buttons">
                                <button class="btn-small" onclick="editTradeFromAll(${index}, ${trade.isOpen})">Edit</button>
                                ${trade.isOpen ? `
                                    <button class="btn-small" style="background: #4488ff; color: #fff;" onclick="rollTradeFromAll(${index})">Roll</button>
                                    <button class="btn-small success" onclick="closeTradeFromAll(${index})">Close</button>
                                ` : ''}
                                <button class="btn-small danger" onclick="deleteTradeFromAll(${index}, ${trade.isOpen})">Delete</button>
                            </div>
                        </td>
                    </tr>
                `;
            }).join('');
        }

        function sortGroupTrades(groupIndex, field, order) {
            const group = tradeGroups[groupIndex];
            if (group && group.trades) {
                group.trades.sort((a, b) => {
                    const aDate = new Date(a[field]);
                    const bDate = new Date(b[field]);
                    if (order === 'asc') {
                        return aDate - bDate;
                    } else {
                        return bDate - aDate;
                    }
                });
                saveData();
                renderGroups();
            }
        }

        function renderGroups() {
            const container = document.getElementById('groupsList');
            if (!container) return; // Exit if container doesn't exist yet
            
            // Filter out any invalid groups
            tradeGroups = tradeGroups.filter(g => g.trades && Array.isArray(g.trades) && g.trades.length > 0);
            
            if (tradeGroups.length === 0) {
                container.innerHTML = `
                    <div style="text-align: center; color: #666; padding: 40px; background: #111; border: 1px solid #333; border-radius: 8px;">
                        No trade groups yet. Click "Create New Group" to group related trades.
                    </div>
                `;
                return;
            }

            container.innerHTML = tradeGroups.map((group, groupIndex) => {
                // Calculate total profit for the group
                let totalProfit = 0;
                if (!group.trades || !Array.isArray(group.trades)) {
                    console.error('Invalid group trades:', group);
                    return '';
                }
                
                group.trades.forEach(trade => {
                    const amount = trade.premium * trade.contracts * 100;
                    if (trade.action === 'sell') {
                        totalProfit += amount;
                    } else {
                        totalProfit -= amount;
                    }
                });

                const cashRequired = group.trades[0].strike * group.trades[0].contracts * 100;
                const percentReturn = ((totalProfit / cashRequired) * 100).toFixed(2);

                return `
                    <div class="table-container" style="margin-bottom: 30px;">
                        <div class="table-header">
                            <div class="table-title">${group.name}</div>
                            <div style="display: flex; gap: 10px; align-items: center;">
                                <div style="font-size: 1.5rem; font-weight: 700; color: ${totalProfit >= 0 ? '#00ff88' : '#ff4444'};">
                                    Profit: $${totalProfit.toFixed(2)} (${percentReturn}%)
                                </div>
                                <button class="btn-small" onclick="editGroup(${groupIndex})">Edit</button>
                                <button class="btn-small danger" onclick="deleteGroup(${groupIndex})">Delete</button>
                            </div>
                        </div>
                        <table>
                            <thead>
                                <tr>
                                    <th>Symbol</th>
                                    <th>Contracts</th>
                                    <th>Strike</th>
                                    <th>Premium</th>
                                    <th>Action</th>
                                    <th>Type</th>
                                    <th>Date <span style="cursor: pointer; user-select: none;" onclick="sortGroupTrades(${groupIndex}, 'dateOpened', 'asc')">▲</span><span style="cursor: pointer; user-select: none;" onclick="sortGroupTrades(${groupIndex}, 'dateOpened', 'desc')">▼</span></th>
                                    <th>Exp Date</th>
                                    <th>Cash Required</th>
                                    <th>% Return</th>
                                    <th>Price @ Action</th>
                                    <th>% OTM</th>
                                    <th>P&L</th>
                                    <th>Info</th>
                                    <th>Trade Ref #</th>
                                    <th>Account</th>
                                    <th>Actions</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${group.trades.map((trade, tradeIndex) => {
                                    const cashReq = calculateCashRequired(trade);
                                    const returnPercent = calculateReturnPercent(trade);
                                    const otm = calculateOTM(trade);
                                    const pl = calculatePL(trade);
                                    
                                    return `
                                        <tr>
                                            <td><strong>${trade.symbol}</strong></td>
                                            <td>${trade.contracts}</td>
                                            <td>$${trade.strike.toFixed(2)}</td>
                                            <td class="${trade.action === 'sell' ? 'positive-value' : 'negative-value'}">
                                                $${trade.premium.toFixed(2)}
                                            </td>
                                            <td><span class="action-badge ${trade.action}">${trade.action.toUpperCase()}</span></td>
                                            <td><span class="type-badge ${trade.type}">${trade.type.toUpperCase()}</span></td>
                                            <td>${formatDate(trade.dateOpened)}</td>
                                            <td>${formatDate(trade.expDate)}</td>
                                            <td>${cashReq > 0 ? '$' + cashReq.toLocaleString() : '-'}</td>
                                            <td class="${parseFloat(returnPercent) >= 0 ? 'positive-value' : 'negative-value'}">${returnPercent}%</td>
                                            <td>$${trade.priceAtAction.toFixed(2)}</td>
                                            <td class="${parseFloat(otm) >= 0 ? 'positive-value' : 'negative-value'}">${otm}%</td>
                                            <td class="${pl >= 0 ? 'positive-value' : 'negative-value'}">$${pl.toFixed(2)}</td>
                                            <td>${trade.info || '-'}</td>
                                            <td style="color: #00ff88;"><strong>${trade.tradeRef || '-'}</strong></td>
                                            <td>${trade.account || '-'}</td>
                                            <td>
                                                <div class="action-buttons">
                                                    <button class="btn-small" onclick="editTradeFromGroup(${groupIndex}, ${tradeIndex})">Edit</button>
                                                    ${trade.status === 'open' ? `
                                                        <button class="btn-small" style="background: #4488ff; color: #fff;" onclick="rollTradeFromGroup(${groupIndex}, ${tradeIndex})">Roll</button>
                                                        <button class="btn-small success" onclick="closeTradeFromGroup(${groupIndex}, ${tradeIndex})">Close</button>
                                                    ` : ''}
                                                    <button class="btn-small danger" onclick="deleteTradeFromGroup(${groupIndex}, ${tradeIndex})">Delete</button>
                                                </div>
                                            </td>
                                        </tr>
                                    `;
                                }).join('')}
                            </tbody>
                        </table>
                    </div>
                `;
            }).join('');
        }

        function autoGroupByTradeRef() {
            console.log('Auto-group called');
            // Only collect CLOSED trades
            const allClosedTrades = closedTrades;
            console.log('Total closed trades:', allClosedTrades.length);
            console.log('All closed trades:', allClosedTrades);
            
            // Filter trades that have a tradeRef
            const tradesWithRef = allClosedTrades.filter(t => t.tradeRef && t.tradeRef.trim() !== '');
            console.log('Closed trades with ref:', tradesWithRef.length);
            console.log('Closed trades with ref data:', tradesWithRef);
            
            if (tradesWithRef.length === 0) {
                alert('No closed trades with Trade Ref # found. Please add Trade Ref # to your trades first.');
                return;
            }
            
            // Group by tradeRef
            const grouped = {};
            tradesWithRef.forEach(trade => {
                const ref = trade.tradeRef.trim();
                if (!grouped[ref]) {
                    grouped[ref] = [];
                }
                grouped[ref].push({...trade});
            });
            
            console.log('Grouped:', grouped);
            console.log('Number of groups:', Object.keys(grouped).length);
            
            // Clear existing groups and create new ones
            tradeGroups = [];
            
            // Create groups
            Object.keys(grouped).forEach(ref => {
                const tradesInGroup = grouped[ref];
                console.log('Creating group for:', ref, 'with', tradesInGroup.length, 'trades');
                tradeGroups.push({
                    id: Date.now() + Math.random(),
                    name: `Trade Ref: ${ref}`,
                    trades: tradesInGroup,
                    created: new Date().toISOString()
                });
            });
            
            console.log('Final tradeGroups:', tradeGroups);
            
            saveData();
            renderGroups();
            updateStats();
            alert(`Created ${Object.keys(grouped).length} groups from closed trades with Trade Ref #!`);
        }

        function createNewGroup() {
            document.getElementById('groupName').value = '';
            renderAvailableTrades();
            document.getElementById('groupModal').classList.add('active');
        }

        function renderAvailableTrades() {
            const container = document.getElementById('availableTrades');
            const allTrades = [...trades, ...closedTrades];
            
            if (allTrades.length === 0) {
                container.innerHTML = '<p style="color: #666;">No trades available to group.</p>';
                return;
            }

            container.innerHTML = `
                <table style="width: 100%; border-collapse: collapse;">
                    <thead>
                        <tr style="background: #0a0a0a;">
                            <th style="padding: 10px; text-align: left;">
                                <input type="checkbox" id="selectAll" onchange="toggleSelectAll()" style="width: auto;">
                            </th>
                            <th style="padding: 10px; text-align: left; color: #888;">Symbol</th>
                            <th style="padding: 10px; text-align: left; color: #888;">Strike</th>
                            <th style="padding: 10px; text-align: left; color: #888;">Premium</th>
                            <th style="padding: 10px; text-align: left; color: #888;">Action</th>
                            <th style="padding: 10px; text-align: left; color: #888;">Type</th>
                            <th style="padding: 10px; text-align: left; color: #888;">Date</th>
                            <th style="padding: 10px; text-align: left; color: #888;">Exp</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${allTrades.map((trade, index) => `
                            <tr style="border-bottom: 1px solid #222;">
                                <td style="padding: 10px;">
                                    <input type="checkbox" class="trade-checkbox" data-index="${index}" style="width: auto;">
                                </td>
                                <td style="padding: 10px;"><strong>${trade.symbol}</strong></td>
                                <td style="padding: 10px;">$${trade.strike.toFixed(2)}</td>
                                <td style="padding: 10px;" class="${trade.action === 'sell' ? 'positive-value' : 'negative-value'}">
                                    $${trade.premium.toFixed(2)}
                                </td>
                                <td style="padding: 10px;"><span class="action-badge ${trade.action}">${trade.action.toUpperCase()}</span></td>
                                <td style="padding: 10px;"><span class="type-badge ${trade.type}">${trade.type.toUpperCase()}</span></td>
                                <td style="padding: 10px;">${formatDate(trade.dateOpened)}</td>
                                <td style="padding: 10px;">${formatDate(trade.expDate)}</td>
                            </tr>
                        `).join('')}
                    </tbody>
                </table>
            `;
        }

        function toggleSelectAll() {
            const selectAll = document.getElementById('selectAll').checked;
            document.querySelectorAll('.trade-checkbox').forEach(cb => {
                cb.checked = selectAll;
            });
        }

        function saveGroup() {
            const groupName = document.getElementById('groupName').value.trim();
            if (!groupName) {
                alert('Please enter a group name');
                return;
            }

            const allTrades = [...trades, ...closedTrades];
            const selectedTrades = [];
            
            document.querySelectorAll('.trade-checkbox:checked').forEach(cb => {
                const index = parseInt(cb.dataset.index);
                selectedTrades.push({...allTrades[index]});
            });

            if (selectedTrades.length === 0) {
                alert('Please select at least one trade');
                return;
            }

            const group = {
                id: Date.now(),
                name: groupName,
                trades: selectedTrades,
                created: new Date().toISOString()
            };

            tradeGroups.push(group);
            saveData();
            renderGroups();
            updateStats();
            closeGroupModal();
        }

        function closeGroupModal() {
            document.getElementById('groupModal').classList.remove('active');
        }

        function editGroup(index) {
            // TODO: Implement edit group functionality
            alert('Edit group functionality coming soon');
        }

        function showGroupManager() {
            // TODO: Implement group manager
            alert('Group manager coming soon');
        }

        function deleteGroup(index) {
            if (true) { // Temporarily removing confirm
                tradeGroups.splice(index, 1);
                saveData();
                renderGroups();
                updateStats();
                alert('Group deleted successfully');
            }
        }

        function editTradeFromGroup(groupIndex, tradeIndex) {
            const group = tradeGroups[groupIndex];
            const trade = group.trades[tradeIndex];
            
            // Set editing context
            editingFromGroup = groupIndex;
            
            // Find which array this trade is in
            const openIndex = trades.findIndex(t => 
                t.symbol === trade.symbol && 
                t.dateOpened === trade.dateOpened && 
                t.strike === trade.strike &&
                t.premium === trade.premium
            );
            
            if (openIndex !== -1) {
                editingIndex = openIndex;
                editingFromArray = 'open';
            } else {
                const closedIndex = closedTrades.findIndex(t => 
                    t.symbol === trade.symbol && 
                    t.dateOpened === trade.dateOpened && 
                    t.strike === trade.strike &&
                    t.premium === trade.premium
                );
                if (closedIndex !== -1) {
                    editingIndex = closedIndex;
                    editingFromArray = 'closed';
                }
            }
            
            populateEditModal(trade);
            document.getElementById('editModal').classList.add('active');
        }

        function deleteTradeFromGroup(groupIndex, tradeIndex) {
            if (true) { // Temporarily removing confirm
                console.log('Deleting trade from group:', groupIndex, 'trade index:', tradeIndex);
                
                const group = tradeGroups[groupIndex];
                const tradeToDelete = group.trades[tradeIndex];
                
                // Save for undo
                lastDeletedTrade = {...tradeToDelete};
                lastDeletedFrom = 'group';
                lastDeletedGroupInfo = {
                    groupIndex: groupIndex,
                    tradeIndex: tradeIndex,
                    groupName: group.name
                };
                
                // Remove from group
                group.trades.splice(tradeIndex, 1);
                
                // If group has no trades left, delete the entire group
                if (group.trades.length === 0) {
                    tradeGroups.splice(groupIndex, 1);
                    alert('Trade deleted. Group was empty so it was also removed.');
                }
                
                // Also remove from the underlying trades or closedTrades arrays
                // Check if it's in open trades
                const openIndex = trades.findIndex(t => 
                    t.symbol === tradeToDelete.symbol && 
                    t.dateOpened === tradeToDelete.dateOpened && 
                    t.strike === tradeToDelete.strike &&
                    t.premium === tradeToDelete.premium
                );
                if (openIndex !== -1) {
                    trades.splice(openIndex, 1);
                    console.log('Also removed from open trades');
                }
                
                // Check if it's in closed trades
                const closedIndex = closedTrades.findIndex(t => 
                    t.symbol === tradeToDelete.symbol && 
                    t.dateOpened === tradeToDelete.dateOpened && 
                    t.strike === tradeToDelete.strike &&
                    t.premium === tradeToDelete.premium
                );
                if (closedIndex !== -1) {
                    closedTrades.splice(closedIndex, 1);
                    console.log('Also removed from closed trades');
                }
                
                saveData();
                renderGroups();
                renderOpenTrades();
                if (currentTab === 'all') {
                    renderAllTrades();
                }
                updateStats();
                showUndoButton();
                alert('Trade deleted successfully from group');
            }
        }

        function rollTradeFromGroup(groupIndex, tradeIndex) {
            console.log('rollTradeFromGroup called:', groupIndex, tradeIndex);
            const group = tradeGroups[groupIndex];
            const tradeToRoll = group.trades[tradeIndex];
            
            console.log('Trade to roll:', tradeToRoll);
            
            // Find the actual index in the open trades array
            if (tradeToRoll.status === 'open') {
                const openIndex = trades.findIndex(t => 
                    t.symbol === tradeToRoll.symbol && 
                    t.dateOpened === tradeToRoll.dateOpened && 
                    t.strike === tradeToRoll.strike &&
                    t.premium === tradeToRoll.premium
                );
                console.log('Found openIndex:', openIndex);
                if (openIndex !== -1) {
                    openRollModal(openIndex);
                } else {
                    console.error('Could not find trade in open trades array');
                    alert('Error: Could not find this trade in open positions.');
                }
            } else {
                alert('This trade is not open and cannot be rolled.');
            }
        }

        function closeTradeFromGroup(groupIndex, tradeIndex) {
            console.log('closeTradeFromGroup called:', groupIndex, tradeIndex);
            const group = tradeGroups[groupIndex];
            const tradeToClose = group.trades[tradeIndex];
            
            console.log('Trade to close:', tradeToClose);
            
            // Find the actual index in the open trades array
            if (tradeToClose.status === 'open') {
                const openIndex = trades.findIndex(t => 
                    t.symbol === tradeToClose.symbol && 
                    t.dateOpened === tradeToClose.dateOpened && 
                    t.strike === tradeToClose.strike &&
                    t.premium === tradeToClose.premium
                );
                console.log('Found openIndex:', openIndex);
                if (openIndex !== -1) {
                    openCloseModal(openIndex);
                } else {
                    console.error('Could not find trade in open trades array');
                    alert('Error: Could not find this trade in open positions.');
                }
            } else {
                alert('This trade is not open and cannot be closed.');
            }
        }

        function showUndoButton() {
            const undoButton = document.getElementById('undoButton');
            if (undoButton) {
                undoButton.style.display = 'inline-block';
            }
        }

        function hideUndoButton() {
            const undoButton = document.getElementById('undoButton');
            if (undoButton) {
                undoButton.style.display = 'none';
            }
        }

        function undoDelete() {
            if (!lastDeletedTrade) {
                alert('Nothing to undo');
                return;
            }

            console.log('Undoing delete from:', lastDeletedFrom);

            if (lastDeletedFrom === 'open') {
                trades.push(lastDeletedTrade);
                renderOpenTrades();
            } else if (lastDeletedFrom === 'closed') {
                closedTrades.push(lastDeletedTrade);
            } else if (lastDeletedFrom === 'group' && lastDeletedGroupInfo) {
                // Restore to the group
                const group = tradeGroups[lastDeletedGroupInfo.groupIndex];
                if (group) {
                    group.trades.splice(lastDeletedGroupInfo.tradeIndex, 0, lastDeletedTrade);
                }
                
                // Also restore to the appropriate array
                if (lastDeletedTrade.status === 'open') {
                    trades.push(lastDeletedTrade);
                } else {
                    closedTrades.push(lastDeletedTrade);
                }
                
                renderGroups();
                renderOpenTrades();
            }

            if (currentTab === 'all') {
                renderAllTrades();
            }

            saveData();
            updateStats();
            
            // Clear undo data
            lastDeletedTrade = null;
            lastDeletedFrom = null;
            lastDeletedGroupInfo = null;
            hideUndoButton();
            
            alert('Delete undone successfully!');
        }

        function updateStats() {
            let totalCollateral = 0;
            let totalPremium = 0;
            let totalPL = 0;
            let totalReturns = 0;

            trades.forEach(trade => {
                const cashReq = calculateCashRequired(trade);
                totalCollateral += cashReq;
                
                const premium = trade.premium * trade.contracts * 100;
                if (trade.action === 'sell') {
                    totalPremium += premium;
                }
                totalPL += calculatePL(trade);
                totalReturns += parseFloat(calculateReturnPercent(trade));
            });

            closedTrades.forEach(trade => {
                const premium = trade.premium * trade.contracts * 100;
                if (trade.action === 'sell') {
                    totalPremium += premium;
                }
                totalPL += calculatePL(trade);
            });

            const avgReturn = trades.length > 0 ? (totalReturns / trades.length).toFixed(2) : 0;
            
            // Calculate overall return: Sum of all % returns from closed groups
            let overallReturn = 0;
            tradeGroups.forEach(group => {
                if (!group.trades || !Array.isArray(group.trades) || group.trades.length === 0) {
                    return;
                }
                
                // Calculate profit for this group
                let groupProfit = 0;
                group.trades.forEach(trade => {
                    const amount = trade.premium * trade.contracts * 100;
                    if (trade.action === 'sell') {
                        groupProfit += amount;
                    } else {
                        groupProfit -= amount;
                    }
                });
                
                // Calculate % return for this group
                const groupCashRequired = group.trades[0].strike * group.trades[0].contracts * 100;
                if (groupCashRequired > 0) {
                    const groupReturnPercent = (groupProfit / groupCashRequired) * 100;
                    overallReturn += groupReturnPercent;
                }
            });
            
            overallReturn = overallReturn.toFixed(2);

            // Update stats
            document.getElementById('totalCollateral').textContent = `$${totalCollateral.toLocaleString()}`;
            document.getElementById('totalPremium').textContent = `$${totalPremium.toLocaleString()}`;
            document.getElementById('totalPL').textContent = `$${totalPL.toFixed(2)}`;
            document.getElementById('totalPL').className = `stat-value ${totalPL >= 0 ? 'positive' : 'negative'}`;
            document.getElementById('overallReturn').textContent = `${overallReturn}%`;
            document.getElementById('overallReturn').className = `stat-value ${parseFloat(overallReturn) >= 0 ? 'positive' : 'negative'}`;
            document.getElementById('openPositions').textContent = trades.length;
            document.getElementById('avgReturn').textContent = `${avgReturn}%`;
            document.getElementById('closedPositions').textContent = tradeGroups.length; // Show number of closed groups
        }

        function formatDate(dateString) {
            const date = new Date(dateString + 'T00:00:00');
            return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
        }

        function editTrade(index) {
            editingIndex = index;
            editingFromArray = 'open';
            editingFromGroup = -1;
            populateEditModal(trades[index]);
            document.getElementById('editModal').classList.add('active');
        }

        function populateEditModal(trade) {
            document.getElementById('editTradeRef').value = trade.tradeRef || '';
            document.getElementById('editSymbol').value = trade.symbol;
            document.getElementById('editContracts').value = trade.contracts;
            document.getElementById('editStrike').value = trade.strike;
            document.getElementById('editPremium').value = trade.premium;
            document.getElementById('editAction').value = trade.action;
            document.getElementById('editType').value = trade.type;
            document.getElementById('editDateOpened').value = trade.dateOpened;
            document.getElementById('editExpDate').value = trade.expDate;
            document.getElementById('editPriceAtAction').value = trade.priceAtAction;
            document.getElementById('editInfo').value = trade.info || '';
        }

        function closeEditModal() {
            document.getElementById('editModal').classList.remove('active');
            editingIndex = -1;
            editingFromArray = 'open';
            editingFromGroup = -1;
        }

        function saveEdit() {
            if (editingIndex >= 0) {
                const updatedTrade = {
                    tradeRef: document.getElementById('editTradeRef').value.trim(),
                    symbol: document.getElementById('editSymbol').value.toUpperCase().trim(),
                    contracts: parseInt(document.getElementById('editContracts').value),
                    strike: parseFloat(document.getElementById('editStrike').value),
                    premium: parseFloat(document.getElementById('editPremium').value),
                    action: document.getElementById('editAction').value,
                    type: document.getElementById('editType').value,
                    dateOpened: document.getElementById('editDateOpened').value,
                    expDate: document.getElementById('editExpDate').value,
                    priceAtAction: parseFloat(document.getElementById('editPriceAtAction').value),
                    info: document.getElementById('editInfo').value
                };
                
                // Update groupId
                updatedTrade.groupId = `${updatedTrade.symbol}-${updatedTrade.strike}-${updatedTrade.type}-${updatedTrade.expDate}`;
                
                // Update the correct array
                if (editingFromArray === 'open') {
                    Object.assign(trades[editingIndex], updatedTrade);
                } else if (editingFromArray === 'closed') {
                    Object.assign(closedTrades[editingIndex], updatedTrade);
                }
                
                // If editing from a group, also update the trade in the group
                if (editingFromGroup >= 0) {
                    const group = tradeGroups[editingFromGroup];
                    // Find the trade in the group by matching original values
                    const tradeInGroup = group.trades.find(t => 
                        t.dateOpened === updatedTrade.dateOpened && 
                        t.strike === updatedTrade.strike
                    );
                    if (tradeInGroup) {
                        Object.assign(tradeInGroup, updatedTrade);
                    }
                }
                
                saveData();
                renderOpenTrades();
                if (currentTab === 'all') {
                    renderAllTrades();
                } else if (currentTab === 'groups') {
                    renderGroups();
                }
                updateStats();
                closeEditModal();
                alert('Trade updated successfully');
            }
        }

        function openCloseModal(index) {
            closingIndex = index;
            const trade = trades[index];
            document.getElementById('closeDate').value = new Date().toISOString().split('T')[0];
            document.getElementById('closingPremium').value = '0';
            document.getElementById('closingNotes').value = '';
            document.getElementById('closeModal').classList.add('active');
        }

        function closeCloseModal() {
            document.getElementById('closeModal').classList.remove('active');
            closingIndex = -1;
        }

        function openRollModal(index) {
            rollingIndex = index;
            const trade = trades[index];
            
            // Pre-fill with current values
            document.getElementById('rollCloseDate').value = new Date().toISOString().split('T')[0];
            document.getElementById('rollClosingPremium').value = '';
            document.getElementById('rollNewStrike').value = trade.strike;
            document.getElementById('rollNewPremium').value = '';
            document.getElementById('rollNewExpDate').value = '';
            document.getElementById('rollPriceAtAction').value = '';
            document.getElementById('rollNewType').value = trade.type;
            document.getElementById('rollNotes').value = '';
            
            document.getElementById('rollModal').classList.add('active');
        }

        function closeRollModal() {
            document.getElementById('rollModal').classList.remove('active');
            rollingIndex = -1;
        }

        function confirmRoll() {
            if (rollingIndex >= 0) {
                const originalTrade = trades[rollingIndex];
                const rollCloseDate = document.getElementById('rollCloseDate').value;
                const rollClosingPremium = parseFloat(document.getElementById('rollClosingPremium').value) || 0;
                const rollNewStrike = parseFloat(document.getElementById('rollNewStrike').value);
                const rollNewPremium = parseFloat(document.getElementById('rollNewPremium').value);
                const rollNewExpDate = document.getElementById('rollNewExpDate').value;
                const rollPriceAtAction = parseFloat(document.getElementById('rollPriceAtAction').value);
                const rollNewType = document.getElementById('rollNewType').value;
                const rollNotes = document.getElementById('rollNotes').value;
                
                // Validate inputs
                if (!rollNewStrike || !rollNewPremium || !rollNewExpDate || !rollPriceAtAction) {
                    alert('Please fill in all required fields for the new position');
                    return;
                }
                
                // 1. Mark original trade as closed
                originalTrade.status = 'closed';
                originalTrade.dateClosed = rollCloseDate;
                
                // 2. Create closing trade (buying back the original)
                const closingTrade = {
                    id: Date.now() + Math.random(),
                    tradeRef: originalTrade.tradeRef || '', // Inherit tradeRef
                    account: originalTrade.account || '', // Inherit account
                    groupId: originalTrade.groupId,
                    symbol: originalTrade.symbol,
                    contracts: originalTrade.contracts,
                    strike: originalTrade.strike,
                    premium: rollClosingPremium,
                    action: originalTrade.action === 'sell' ? 'buy' : 'sell',
                    type: originalTrade.type,
                    dateOpened: rollCloseDate,
                    expDate: originalTrade.expDate,
                    priceAtAction: rollPriceAtAction,
                    info: rollNotes ? `Roll close: ${rollNotes}` : 'Rolled - closing leg',
                    status: 'closed',
                    dateClosed: rollCloseDate,
                    isClosingTrade: true
                };
                
                // 3. Create new opening trade (selling the new option)
                const newOpeningTrade = {
                    id: Date.now() + Math.random() + 1,
                    tradeRef: originalTrade.tradeRef || '', // Inherit tradeRef
                    account: originalTrade.account || '', // Inherit account
                    groupId: `${originalTrade.symbol}-${rollNewStrike}-${rollNewType}-${rollNewExpDate}`,
                    symbol: originalTrade.symbol,
                    contracts: originalTrade.contracts,
                    strike: rollNewStrike,
                    premium: rollNewPremium,
                    action: 'sell',
                    type: rollNewType,
                    dateOpened: rollCloseDate,
                    expDate: rollNewExpDate,
                    priceAtAction: rollPriceAtAction,
                    info: rollNotes ? `Rolled: ${rollNotes}` : 'Rolled - new leg',
                    status: 'open',
                    isRolled: true // Mark this position as rolled
                };
                
                // Move original and closing to closed trades
                closedTrades.push(originalTrade);
                closedTrades.push(closingTrade);
                
                // Remove original from open trades
                trades.splice(rollingIndex, 1);
                
                // Add new opening trade to open trades
                trades.push(newOpeningTrade);
                
                // Find existing group with same Trade Ref # or create new one
                let existingGroup = null;
                if (originalTrade.tradeRef && originalTrade.tradeRef.trim()) {
                    // Look for a group containing trades with the same tradeRef
                    existingGroup = tradeGroups.find(g => 
                        g.trades && g.trades.some(t => t.tradeRef === originalTrade.tradeRef)
                    );
                }
                
                if (existingGroup) {
                    // Add to existing group (only the closed trades, not the new opening trade)
                    console.log('Adding roll to existing group:', existingGroup.name);
                    existingGroup.trades.push(originalTrade);
                    existingGroup.trades.push(closingTrade);
                    // Don't add newOpeningTrade to group - it stays in the open trades array
                } else {
                    // Create a new trade group for the roll (only closed trades)
                    console.log('Creating new roll group');
                    const rollGroup = {
                        id: Date.now(),
                        name: originalTrade.tradeRef ? `Trade Ref: ${originalTrade.tradeRef}` : `${originalTrade.symbol} Roll - ${originalTrade.strike} to ${rollNewStrike} ${rollNewType.toUpperCase()}`,
                        trades: [originalTrade, closingTrade],
                        created: new Date().toISOString()
                    };
                    
                    tradeGroups.push(rollGroup);
                }
                
                saveData();
                renderOpenTrades();
                if (currentTab === 'all') {
                    renderAllTrades();
                } else if (currentTab === 'groups') {
                    renderGroups();
                }
                updateStats();
                closeRollModal();
                alert('Position rolled successfully! Check Closed Groups to see the complete roll.');
            }
        }

        function confirmClose() {
            if (closingIndex >= 0) {
                const openingTrade = trades[closingIndex];
                const closeDate = document.getElementById('closeDate').value;
                const closingPremium = parseFloat(document.getElementById('closingPremium').value) || 0;
                const closingNotes = document.getElementById('closingNotes').value;
                
                // Mark the original trade as closed
                openingTrade.status = 'closed';
                openingTrade.dateClosed = closeDate;
                
                // Create a separate closing trade entry (buying back the option)
                const closingTrade = {
                    id: Date.now() + Math.random(),
                    tradeRef: openingTrade.tradeRef || '', // Inherit tradeRef
                    account: openingTrade.account || '', // Inherit account
                    groupId: openingTrade.groupId,
                    symbol: openingTrade.symbol,
                    contracts: openingTrade.contracts,
                    strike: openingTrade.strike,
                    premium: closingPremium,
                    action: openingTrade.action === 'sell' ? 'buy' : 'sell', // Opposite action
                    type: openingTrade.type,
                    dateOpened: closeDate,
                    expDate: openingTrade.expDate,
                    priceAtAction: openingTrade.priceAtAction,
                    info: closingNotes || 'Closing trade',
                    status: 'closed',
                    dateClosed: closeDate,
                    isClosingTrade: true
                };
                
                // Move opening trade to closed trades
                closedTrades.push(openingTrade);
                
                // Add closing trade to closed trades
                closedTrades.push(closingTrade);
                
                // Remove from open trades
                trades.splice(closingIndex, 1);
                
                // Find existing group with same Trade Ref # or create new one
                let existingGroup = null;
                if (openingTrade.tradeRef && openingTrade.tradeRef.trim()) {
                    // Look for a group containing trades with the same tradeRef
                    existingGroup = tradeGroups.find(g => 
                        g.trades && g.trades.some(t => t.tradeRef === openingTrade.tradeRef)
                    );
                }
                
                if (existingGroup) {
                    // Add to existing group
                    console.log('Adding close to existing group:', existingGroup.name);
                    existingGroup.trades.push(openingTrade);
                    existingGroup.trades.push(closingTrade);
                } else {
                    // Auto-create a new trade group with both trades
                    console.log('Creating new close group');
                    const group = {
                        id: Date.now(),
                        name: openingTrade.tradeRef ? `Trade Ref: ${openingTrade.tradeRef}` : `${openingTrade.symbol} ${openingTrade.strike} ${openingTrade.type.toUpperCase()} - ${formatDate(openingTrade.dateOpened)} to ${formatDate(closeDate)}`,
                        trades: [openingTrade, closingTrade],
                        created: new Date().toISOString()
                    };
                    
                    tradeGroups.push(group);
                }
                
                saveData();
                renderTables();
                renderOpenTrades();
                if (currentTab === 'all') {
                    renderAllTrades();
                } else if (currentTab === 'groups') {
                    renderGroups();
                }
                updateStats();
                closeCloseModal();
                alert('Position closed and group created successfully');
            }
        }

        function reopenTrade(index) {
            if (confirm('Reopen this position?')) {
                const trade = closedTrades[index];
                trade.status = 'open';
                delete trade.dateClosed;
                delete trade.closingPremium;
                delete trade.closingNotes;
                
                trades.push(trade);
                closedTrades.splice(index, 1);
                
                saveData();
                renderTables();
                updateStats();
            }
        }

        function removeTradeFromAllGroups(tradeToRemove) {
            // Find and remove this trade from all groups
            tradeGroups.forEach((group, groupIndex) => {
                if (!group.trades || !Array.isArray(group.trades)) return;
                
                // Find matching trade in this group
                const tradeIndex = group.trades.findIndex(t => 
                    t.symbol === tradeToRemove.symbol && 
                    t.dateOpened === tradeToRemove.dateOpened && 
                    t.strike === tradeToRemove.strike &&
                    t.premium === tradeToRemove.premium &&
                    t.action === tradeToRemove.action
                );
                
                if (tradeIndex !== -1) {
                    console.log('Removing trade from group:', group.name);
                    group.trades.splice(tradeIndex, 1);
                    
                    // If group is now empty, remove the entire group
                    if (group.trades.length === 0) {
                        console.log('Group is empty, removing group:', group.name);
                        tradeGroups.splice(groupIndex, 1);
                    }
                }
            });
        }

        function deleteTrade(index) {
            // Temporarily removing confirm to test if that's the issue
            if (true) { // Always proceed for now
                console.log('Deleting trade at index:', index);
                
                const tradeToDelete = trades[index];
                
                // Save for undo
                lastDeletedTrade = {...tradeToDelete};
                lastDeletedFrom = 'open';
                lastDeletedGroupInfo = null;
                
                // Remove from trades array
                trades.splice(index, 1);
                
                // Also remove from any groups
                removeTradeFromAllGroups(tradeToDelete);
                
                console.log('Trades after delete:', trades.length, 'trades remaining');
                saveData();
                renderOpenTrades();
                if (currentTab === 'all') {
                    renderAllTrades();
                } else if (currentTab === 'groups') {
                    renderGroups();
                }
                updateStats();
                showUndoButton();
                alert('Trade deleted successfully');
            }
        }

        function deleteClosedTrade(index) {
            if (confirm('Are you sure you want to delete this closed position? This cannot be undone.')) {
                const tradeToDelete = closedTrades[index];
                closedTrades.splice(index, 1);
                
                // Also remove from any groups
                removeTradeFromAllGroups(tradeToDelete);
                
                saveData();
                renderAllTrades();
                if (currentTab === 'groups') {
                    renderGroups();
                }
                updateStats();
            }
        }

        function deleteTradeFromAll(index, isOpen) {
            // Temporarily removing confirm to test
            if (true) { // Always proceed for now
                // Reconstruct allTrades EXACTLY as in renderAllTrades
                const openTrades = trades.map(t => ({...t, isOpen: true}));
                const closedTradesArray = closedTrades.map(t => ({...t, isOpen: false}));
                
                // Also get trades from groups that might not be in closedTrades
                const groupTrades = [];
                tradeGroups.forEach(group => {
                    if (group.trades && Array.isArray(group.trades)) {
                        group.trades.forEach(trade => {
                            const alreadyExists = openTrades.some(t => 
                                t.symbol === trade.symbol && 
                                t.dateOpened === trade.dateOpened && 
                                t.strike === trade.strike &&
                                t.premium === trade.premium &&
                                t.action === trade.action
                            ) || closedTradesArray.some(t => 
                                t.symbol === trade.symbol && 
                                t.dateOpened === trade.dateOpened && 
                                t.strike === trade.strike &&
                                t.premium === trade.premium &&
                                t.action === trade.action
                            );
                            
                            if (!alreadyExists) {
                                groupTrades.push({...trade, isOpen: trade.status === 'open'});
                            }
                        });
                    }
                });
                
                const allTrades = [...openTrades, ...closedTradesArray, ...groupTrades];
                
                // Sort by date opened (most recent first) - SAME AS renderAllTrades
                allTrades.sort((a, b) => new Date(b.dateOpened) - new Date(a.dateOpened));
                
                const tradeToDelete = allTrades[index];
                
                console.log('Deleting from All Trades, index:', index);
                console.log('Trade to delete:', tradeToDelete);
                
                if (!tradeToDelete) {
                    alert('Error: Could not find trade to delete');
                    return;
                }
                
                // Save for undo
                lastDeletedTrade = {...tradeToDelete};
                lastDeletedGroupInfo = null;
                
                if (tradeToDelete.isOpen) {
                    // Find and delete from open trades
                    const openIndex = trades.findIndex(t => 
                        t.symbol === tradeToDelete.symbol && 
                        t.dateOpened === tradeToDelete.dateOpened && 
                        t.strike === tradeToDelete.strike &&
                        t.premium === tradeToDelete.premium &&
                        t.action === tradeToDelete.action
                    );
                    console.log('Found in open trades at index:', openIndex);
                    if (openIndex !== -1) {
                        lastDeletedFrom = 'open';
                        trades.splice(openIndex, 1);
                    }
                } else {
                    // Find and delete from closed trades
                    const closedIndex = closedTrades.findIndex(t => 
                        t.symbol === tradeToDelete.symbol && 
                        t.dateOpened === tradeToDelete.dateOpened && 
                        t.strike === tradeToDelete.strike &&
                        t.premium === tradeToDelete.premium &&
                        t.action === tradeToDelete.action
                    );
                    console.log('Found in closed trades at index:', closedIndex);
                    if (closedIndex !== -1) {
                        lastDeletedFrom = 'closed';
                        closedTrades.splice(closedIndex, 1);
                    }
                }
                
                // Also remove from any groups
                removeTradeFromAllGroups(tradeToDelete);
                
                saveData();
                renderAllTrades();
                renderOpenTrades(); // Also update open positions view
                if (currentTab === 'groups') {
                    renderGroups();
                }
                updateStats();
                showUndoButton();
                alert('Trade deleted successfully');
            }
        }

        function editTradeFromAll(index, isOpen) {
            // Reconstruct allTrades EXACTLY as in renderAllTrades
            const openTrades = trades.map(t => ({...t, isOpen: true}));
            const closedTradesArray = closedTrades.map(t => ({...t, isOpen: false}));
            
            // Also get trades from groups
            const groupTrades = [];
            tradeGroups.forEach(group => {
                if (group.trades && Array.isArray(group.trades)) {
                    group.trades.forEach(trade => {
                        const alreadyExists = openTrades.some(t => 
                            t.symbol === trade.symbol && 
                            t.dateOpened === trade.dateOpened && 
                            t.strike === trade.strike &&
                            t.premium === trade.premium &&
                            t.action === trade.action
                        ) || closedTradesArray.some(t => 
                            t.symbol === trade.symbol && 
                            t.dateOpened === trade.dateOpened && 
                            t.strike === trade.strike &&
                            t.premium === trade.premium &&
                            t.action === trade.action
                        );
                        
                        if (!alreadyExists) {
                            groupTrades.push({...trade, isOpen: trade.status === 'open'});
                        }
                    });
                }
            });
            
            const allTrades = [...openTrades, ...closedTradesArray, ...groupTrades];
            
            // Sort by date opened (most recent first) - SAME AS renderAllTrades
            allTrades.sort((a, b) => new Date(b.dateOpened) - new Date(a.dateOpened));
            
            const tradeToEdit = allTrades[index];
            
            if (!tradeToEdit) {
                alert('Error: Could not find trade to edit');
                return;
            }
            
            // Find the actual index in the correct array
            if (tradeToEdit.isOpen) {
                const openIndex = trades.findIndex(t => 
                    t.symbol === tradeToEdit.symbol && 
                    t.dateOpened === tradeToEdit.dateOpened && 
                    t.strike === tradeToEdit.strike &&
                    t.premium === tradeToEdit.premium &&
                    t.action === tradeToEdit.action
                );
                if (openIndex !== -1) {
                    editingIndex = openIndex;
                    editingFromArray = 'open';
                    populateEditModal(trades[openIndex]);
                }
            } else {
                const closedIndex = closedTrades.findIndex(t => 
                    t.symbol === tradeToEdit.symbol && 
                    t.dateOpened === tradeToEdit.dateOpened && 
                    t.strike === tradeToEdit.strike &&
                    t.premium === tradeToEdit.premium &&
                    t.action === tradeToEdit.action
                );
                if (closedIndex !== -1) {
                    editingIndex = closedIndex;
                    editingFromArray = 'closed';
                    populateEditModal(closedTrades[closedIndex]);
                }
            }
            
            document.getElementById('editModal').classList.add('active');
        }

        function rollTradeFromAll(index) {
            console.log('rollTradeFromAll called with index:', index);
            const allTrades = [...trades.map(t => ({...t, isOpen: true})), ...closedTrades.map(t => ({...t, isOpen: false}))];
            console.log('allTrades length:', allTrades.length);
            
            // Sort by date opened (most recent first) - SAME AS renderAllTrades
            allTrades.sort((a, b) => new Date(b.dateOpened) - new Date(a.dateOpened));
            
            const tradeToRoll = allTrades[index];
            console.log('tradeToRoll:', tradeToRoll);
            
            // Find the actual index in the open trades array
            if (tradeToRoll && tradeToRoll.isOpen) {
                const openIndex = trades.findIndex(t => 
                    t.symbol === tradeToRoll.symbol && 
                    t.dateOpened === tradeToRoll.dateOpened && 
                    t.strike === tradeToRoll.strike &&
                    t.premium === tradeToRoll.premium
                );
                console.log('Found openIndex:', openIndex);
                if (openIndex !== -1) {
                    openRollModal(openIndex);
                } else {
                    console.error('Could not find trade in open trades array');
                    alert('Error: Could not find this trade. Please try from Open Positions tab.');
                }
            } else {
                console.error('Trade is not open or not found');
                alert('This trade is not open and cannot be rolled.');
            }
        }

        function closeTradeFromAll(index) {
            console.log('closeTradeFromAll called with index:', index);
            const allTrades = [...trades.map(t => ({...t, isOpen: true})), ...closedTrades.map(t => ({...t, isOpen: false}))];
            console.log('allTrades length:', allTrades.length);
            
            // Sort by date opened (most recent first) - SAME AS renderAllTrades
            allTrades.sort((a, b) => new Date(b.dateOpened) - new Date(a.dateOpened));
            
            const tradeToClose = allTrades[index];
            console.log('tradeToClose:', tradeToClose);
            
            // Find the actual index in the open trades array
            if (tradeToClose && tradeToClose.isOpen) {
                const openIndex = trades.findIndex(t => 
                    t.symbol === tradeToClose.symbol && 
                    t.dateOpened === tradeToClose.dateOpened && 
                    t.strike === tradeToClose.strike &&
                    t.premium === tradeToClose.premium
                );
                console.log('Found openIndex:', openIndex);
                if (openIndex !== -1) {
                    openCloseModal(openIndex);
                } else {
                    console.error('Could not find trade in open trades array');
                    alert('Error: Could not find this trade. Please try from Open Positions tab.');
                }
            } else {
                console.error('Trade is not open or not found');
                alert('This trade is not open and cannot be closed.');
            }
        }

        function saveData() {
            localStorage.setItem('wheelTrades', JSON.stringify(trades));
            localStorage.setItem('wheelClosedTrades', JSON.stringify(closedTrades));
            localStorage.setItem('wheelTradeGroups', JSON.stringify(tradeGroups));
        }

        function loadData() {
            const savedTrades = localStorage.getItem('wheelTrades');
            const savedClosedTrades = localStorage.getItem('wheelClosedTrades');
            const savedTradeGroups = localStorage.getItem('wheelTradeGroups');
            
            if (savedTrades) {
                try {
                    trades = JSON.parse(savedTrades);
                    if (!Array.isArray(trades)) trades = [];
                } catch (e) {
                    console.error('Error loading trades:', e);
                    trades = [];
                }
            }
            if (savedClosedTrades) {
                try {
                    closedTrades = JSON.parse(savedClosedTrades);
                    if (!Array.isArray(closedTrades)) closedTrades = [];
                } catch (e) {
                    console.error('Error loading closed trades:', e);
                    closedTrades = [];
                }
            }
            if (savedTradeGroups) {
                try {
                    tradeGroups = JSON.parse(savedTradeGroups);
                    if (!Array.isArray(tradeGroups)) tradeGroups = [];
                    // Filter out invalid groups
                    tradeGroups = tradeGroups.filter(g => g.trades && Array.isArray(g.trades) && g.trades.length > 0);
                } catch (e) {
                    console.error('Error loading trade groups:', e);
                    tradeGroups = [];
                }
            }
            
            renderTables();
            updateStats();
        }

        function exportData() {
            const data = {
                openTrades: trades,
                closedTrades: closedTrades,
                tradeGroups: tradeGroups,
                exportDate: new Date().toISOString()
            };
            const dataStr = JSON.stringify(data, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `wheel_trades_${new Date().toISOString().split('T')[0]}.json`;
            link.click();
        }

        function importData() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = (e) => {
                const file = e.target.files[0];
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const imported = JSON.parse(event.target.result);
                        if (confirm(`Import ${(imported.openTrades?.length || 0)} open and ${(imported.closedTrades?.length || 0)} closed trades? This will replace current data.`)) {
                            trades = imported.openTrades || imported || [];
                            closedTrades = imported.closedTrades || [];
                            tradeGroups = imported.tradeGroups || [];
                            saveData();
                            renderTables();
                            updateStats();
                        }
                    } catch (error) {
                        alert('Error importing file. Please check the file format.');
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        }
    </script>
</body>
</html>

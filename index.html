<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Options Wheel Strategy Tracker</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #000;
            color: #fff;
            padding: 20px;
            line-height: 1.6;
            transition: background-color 0.3s, color 0.3s;
        }

        body.light-mode {
            background: #f5f5f5;
            color: #000;
        }

        body.light-mode .stat-card,
        body.light-mode .controls,
        body.light-mode .table-container,
        body.light-mode .modal-content {
            background: #fff;
            border-color: #ddd;
        }

        body.light-mode table thead {
            background: #e8e8e8;
        }

        body.light-mode th,
        body.light-mode .stat-label,
        body.light-mode label {
            color: #666;
        }

        body.light-mode td {
            border-bottom-color: #e0e0e0;
        }

        body.light-mode tr:hover {
            background: #f9f9f9;
        }

        body.light-mode input,
        body.light-mode select {
            background: #fff;
            border-color: #ddd;
            color: #000;
        }

        body.light-mode button.secondary {
            background: #e0e0e0;
            color: #000;
        }

        body.light-mode .subtitle {
            color: #666;
        }

        .theme-toggle {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 60px;
            height: 30px;
            background: #333;
            border: none;
            border-radius: 15px;
            cursor: pointer;
            z-index: 1000;
            transition: all 0.3s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            padding: 0;
            position: relative;
            outline: none;
        }

        .theme-toggle::before {
            content: 'üåô';
            position: absolute;
            left: 3px;
            top: 50%;
            transform: translateY(-50%);
            width: 24px;
            height: 24px;
            background: #fff;
            border-radius: 50%;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        body.light-mode .theme-toggle {
            background: #ddd;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        body.light-mode .theme-toggle::before {
            content: '‚òÄÔ∏è';
            left: calc(100% - 27px);
            background: #000;
        }

        .theme-toggle:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
        }

        body.light-mode .theme-toggle:hover {
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
        }

        body.light-mode .container {
            color: #000;
        }

        body.light-mode .stat-card,
        body.light-mode .controls,
        body.light-mode .table-container,
        body.light-mode .modal-content {
            background: #fff;
            border-color: #ddd;
        }

        body.light-mode .table-header {
            border-color: #ddd;
        }

        body.light-mode thead {
            background: #f9f9f9;
        }

        body.light-mode th {
            color: #666;
            border-color: #ddd;
        }

        body.light-mode td {
            border-color: #eee;
        }

        body.light-mode tr:hover {
            background: #f9f9f9;
        }

        body.light-mode input,
        body.light-mode select {
            background: #fff;
            border-color: #ddd;
            color: #000;
        }

        body.light-mode .btn-small {
            background: #ddd;
            color: #000;
        }

        body.light-mode .btn-small:hover {
            background: #ccc;
        }

        body.light-mode .tab {
            color: #666;
        }

        body.light-mode .tab:hover,
        body.light-mode .tab.active {
            color: #000;
            border-bottom-color: #000;
        }

        body.light-mode .tabs {
            border-bottom-color: #ddd;
        }

        .dashboard-metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .metric-card {
            background: #111;
            border: 1px solid #333;
            padding: 25px;
            border-radius: 8px;
        }

        body.light-mode .metric-card {
            background: #fff;
            border-color: #ddd;
        }

        .metric-title {
            color: #888;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 15px;
            font-weight: 600;
        }

        .metric-value-large {
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 10px;
        }

        .metric-description {
            color: #666;
            font-size: 0.85rem;
            line-height: 1.4;
        }

        .allocation-bar {
            width: 100%;
            height: 8px;
            background: #222;
            border-radius: 4px;
            overflow: hidden;
            margin-top: 8px;
        }

        body.light-mode .allocation-bar {
            background: #e0e0e0;
        }

        .allocation-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff88, #00cc6a);
            border-radius: 4px;
            transition: width 0.3s;
        }

        .allocation-list {
            margin-top: 15px;
        }

        .allocation-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid #222;
        }

        body.light-mode .allocation-item {
            border-bottom-color: #eee;
        }

        .allocation-item:last-child {
            border-bottom: none;
        }

        .allocation-symbol {
            font-weight: 600;
            color: #00ff88;
        }

        .allocation-percent {
            color: #888;
            font-size: 0.9rem;
        }

        .container {
            max-width: 1800px;
            margin: 0 auto;
        }

        h1 {
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 10px;
            letter-spacing: -1px;
        }

        .subtitle {
            color: #888;
            font-size: 1.1rem;
            margin-bottom: 30px;
        }

        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 30px;
            border-bottom: 1px solid #333;
        }

        .tab {
            background: none;
            color: #888;
            border: none;
            padding: 12px 24px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            border-bottom: 2px solid transparent;
            transition: all 0.2s;
        }

        .tab:hover {
            color: #fff;
        }

        .tab.active {
            color: #fff;
            border-bottom-color: #fff;
        }

        .tab-badge {
            display: inline-block;
            background: #333;
            color: #888;
            font-size: 0.75rem;
            font-weight: 600;
            padding: 2px 8px;
            border-radius: 10px;
            margin-left: 6px;
            min-width: 20px;
            text-align: center;
        }

        .tab.active .tab-badge {
            background: #00ff88;
            color: #000;
        }

        body.light-mode .tab-badge {
            background: #e0e0e0;
            color: #666;
        }

        body.light-mode .tab.active .tab-badge {
            background: #00cc6a;
            color: #fff;
        }

        .settings-dropdown {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            z-index: 1000;
            min-width: 220px;
            padding: 10px 0;
        }

        .settings-dropdown button:hover {
            background: #252525 !important;
        }

        body.light-mode .settings-dropdown {
            background: #fff;
            border-color: #ddd;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        body.light-mode .settings-dropdown button {
            color: #000 !important;
        }

        body.light-mode .settings-dropdown button:hover {
            background: #f5f5f5 !important;
        }

        body.light-mode .settings-dropdown button[onclick*="logout"] {
            color: #ff4444 !important;
        }

        #settingsMenuBtn:hover {
            background: #1a1a1a !important;
            border-color: #00ff88 !important;
            color: #00ff88 !important;
        }

        body.light-mode #settingsMenuBtn {
            border-color: #ddd;
            color: #666;
        }

        body.light-mode #settingsMenuBtn:hover {
            background: #f5f5f5 !important;
            border-color: #00cc6a !important;
            color: #00cc6a !important;
        }

        #importOptionsModal button[onclick*="importData"]:hover {
            background: #252525 !important;
            border-color: #00ff88 !important;
            transform: translateY(-2px);
        }

        #importOptionsModal button[onclick*="downloadTemplate"]:hover {
            background: #252525 !important;
            border-color: #4488ff !important;
            transform: translateY(-2px);
        }

        body.light-mode #importOptionsModal {
            background: rgba(255, 255, 255, 0.95);
        }

        body.light-mode #importOptionsModal .modal-content {
            background: #fff;
        }

        body.light-mode #importOptionsModal button[onclick*="importData"],
        body.light-mode #importOptionsModal button[onclick*="downloadTemplate"] {
            background: #f5f5f5;
            color: #000;
        }

        body.light-mode #importOptionsModal button[onclick*="importData"]:hover {
            background: #e8e8e8 !important;
        }

        body.light-mode #importOptionsModal button[onclick*="downloadTemplate"]:hover {
            background: #e8e8e8 !important;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 40px;
        }

        .stat-card {
            background: #111;
            border: 1px solid #333;
            padding: 20px;
            border-radius: 8px;
        }

        .stat-label {
            color: #888;
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
        }

        .stat-value {
            font-size: 1.8rem;
            font-weight: 700;
            color: #fff;
        }

        .stat-value.positive {
            color: #00ff88;
        }

        .stat-value.negative {
            color: #ff4444;
        }

        .controls {
            background: #111;
            border: 1px solid #333;
            padding: 25px;
            border-radius: 8px;
            margin-bottom: 30px;
        }

        .form-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .form-group {
            display: flex;
            flex-direction: column;
        }

        label {
            color: #888;
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 5px;
        }

        input, select {
            background: #000;
            border: 1px solid #333;
            color: #fff;
            padding: 10px;
            border-radius: 4px;
            font-size: 1rem;
        }

        input:focus, select:focus {
            outline: none;
            border-color: #fff;
        }

        button {
            background: #fff;
            color: #000;
            border: none;
            padding: 12px 30px;
            border-radius: 4px;
            font-weight: 700;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.2s;
        }

        button:hover {
            background: #ddd;
        }

        button.secondary {
            background: #333;
            color: #fff;
        }

        button.secondary:hover {
            background: #444;
        }

        .table-container {
            background: #111;
            border: 1px solid #333;
            border-radius: 8px;
            overflow-x: auto;
            margin-bottom: 20px;
        }

        .table-header {
            padding: 20px;
            border-bottom: 1px solid #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .table-title {
            font-size: 1.3rem;
            font-weight: 700;
        }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        thead {
            background: #0a0a0a;
        }

        th {
            text-align: left;
            padding: 15px;
            color: #888;
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 600;
            border-bottom: 1px solid #333;
            white-space: nowrap;
        }

        td {
            padding: 15px;
            border-bottom: 1px solid #222;
            white-space: nowrap;
        }

        tr:hover {
            background: #0a0a0a;
        }

        .action-buttons {
            display: flex;
            gap: 10px;
        }

        .btn-small {
            padding: 5px 12px;
            font-size: 0.85rem;
            background: #333;
            color: #fff;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .btn-small:hover {
            background: #444;
        }

        .btn-small.danger {
            background: #ff4444;
        }

        .btn-small.danger:hover {
            background: #cc0000;
        }

        .btn-small.success {
            background: #00ff88;
            color: #000;
        }

        .btn-small.success:hover {
            background: #00dd77;
        }

        .type-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: 600;
        }

        .type-badge.put {
            background: #ff440033;
            color: #ff8888;
            border: 1px solid #ff4444;
        }

        .type-badge.call {
            background: #00ff8833;
            color: #88ffaa;
            border: 1px solid #00ff88;
        }

        .action-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: 600;
        }

        .action-badge.sell {
            background: #00ff8833;
            color: #88ffaa;
        }

        .action-badge.buy {
            background: #ff440033;
            color: #ff8888;
        }

        .status-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: 600;
        }

        .status-badge.open {
            background: #00ff8833;
            color: #88ffaa;
            border: 1px solid #00ff88;
        }

        .status-badge.closed {
            background: #88888833;
            color: #aaa;
            border: 1px solid #666;
        }

        .positive-value {
            color: #00ff88;
        }

        .negative-value {
            color: #ff4444;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: #111;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 30px;
            max-width: 600px;
            width: 90%;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .modal-title {
            font-size: 1.5rem;
            font-weight: 700;
        }

        .close-btn {
            background: none;
            color: #888;
            font-size: 1.5rem;
            padding: 0;
            width: 30px;
            height: 30px;
            cursor: pointer;
        }

        .close-btn:hover {
            color: #fff;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* Login/Signup Styles */
        .auth-container {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: #000;
        }

        .auth-box {
            background: #0a0a0a;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 40px;
            width: 100%;
            max-width: 400px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }

        .auth-title {
            font-size: 2rem;
            font-weight: bold;
            margin-bottom: 10px;
            color: #fff;
            text-align: center;
        }

        .auth-subtitle {
            color: #888;
            text-align: center;
            margin-bottom: 30px;
        }

        .auth-input {
            width: 100%;
            padding: 12px;
            margin-bottom: 15px;
            background: #000;
            border: 1px solid #333;
            border-radius: 4px;
            color: #fff;
            font-size: 1rem;
            box-sizing: border-box;
        }

        .auth-input:focus {
            outline: none;
            border-color: #00ff88;
        }

        .auth-button {
            width: 100%;
            padding: 12px;
            background: #00ff88;
            color: #000;
            border: none;
            border-radius: 4px;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            margin-bottom: 15px;
        }

        .auth-button:hover {
            background: #00cc6a;
        }

        .auth-link {
            text-align: center;
            color: #888;
        }

        .auth-link a {
            color: #00ff88;
            text-decoration: none;
            cursor: pointer;
        }

        .auth-link a:hover {
            text-decoration: underline;
        }

        .auth-error {
            background: #ff4444;
            color: #fff;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 15px;
            text-align: center;
        }

        .logout-button {
            display: none;
        }

        .rolled-badge {
            display: inline-block;
            background: #4488ff;
            color: #fff;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: bold;
            margin-left: 8px;
            vertical-align: middle;
        }

        .hidden {
            display: none;
        }

        /* Sortable Table Headers */
        th.sortable {
            cursor: pointer;
            user-select: none;
            position: relative;
            padding-right: 25px;
        }

        th.sortable:hover {
            background: #2a2a2a;
        }

        th.sortable::after {
            content: '‚áÖ';
            position: absolute;
            right: 8px;
            opacity: 0.3;
            font-size: 0.8em;
        }

        th.sortable.sort-asc::after {
            content: '‚ñ≤';
            opacity: 1;
            color: #00ff88;
        }

        th.sortable.sort-desc::after {
            content: '‚ñº';
            opacity: 1;
            color: #00ff88;
        }
    </style>
</head>
<body>
    <!-- Login/Signup Screen -->
    <div id="authScreen" class="auth-container">
        <div class="auth-box">
            <div id="loginForm">
                <h1 class="auth-title">Options Wheel Tracker</h1>
                <p class="auth-subtitle">Login to your account</p>
                <div id="loginError" class="auth-error hidden"></div>
                <input type="text" id="loginUsername" class="auth-input" placeholder="Username">
                <input type="password" id="loginPassword" class="auth-input" placeholder="Password">
                <button onclick="login()" class="auth-button">Login</button>
                <div class="auth-link">
                    Don't have an account? <a onclick="showSignup()">Sign up</a>
                </div>
            </div>

            <div id="signupForm" class="hidden">
                <h1 class="auth-title">Create Account</h1>
                <p class="auth-subtitle">Sign up for Options Wheel Tracker</p>
                <div id="signupError" class="auth-error hidden"></div>
                <input type="text" id="signupUsername" class="auth-input" placeholder="Username">
                <input type="password" id="signupPassword" class="auth-input" placeholder="Password">
                <input type="password" id="signupPasswordConfirm" class="auth-input" placeholder="Confirm Password">
                <button onclick="signup()" class="auth-button">Create Account</button>
                <div class="auth-link">
                    Already have an account? <a onclick="showLogin()">Login</a>
                </div>
            </div>
        </div>
    </div>

    <!-- Main Tracker (hidden until logged in) -->
    <div id="trackerApp" class="hidden">
        <button onclick="logout()" class="logout-button">Logout</button>
        <button onclick="toggleTheme()" class="theme-toggle" id="themeToggle"></button>
        
        <!-- Hamburger Menu - Fixed Top Right -->
        <button onclick="toggleSettingsMenu()" id="settingsMenuBtn" style="position: fixed; top: 20px; right: 20px; z-index: 1001; background: none; border: 1px solid #333; color: #888; padding: 12px 14px; border-radius: 6px; cursor: pointer; display: flex; flex-direction: column; gap: 3px; transition: all 0.2s;">
            <span style="width: 22px; height: 2px; background: currentColor; display: block;"></span>
            <span style="width: 22px; height: 2px; background: currentColor; display: block;"></span>
            <span style="width: 22px; height: 2px; background: currentColor; display: block;"></span>
        </button>

        <!-- Settings Menu Dropdown -->
        <div id="settingsMenu" class="settings-dropdown hidden" style="position: fixed; top: 70px; right: 20px;">
            <button onclick="exportData()" style="width: 100%; text-align: left; padding: 12px 20px; background: none; border: none; color: #fff; cursor: pointer; display: flex; align-items: center; gap: 10px; transition: background 0.2s;">
                <span style="font-size: 1.2rem;">üì§</span> Export Data
            </button>
            <button onclick="showImportOptions()" style="width: 100%; text-align: left; padding: 12px 20px; background: none; border: none; color: #fff; cursor: pointer; display: flex; align-items: center; gap: 10px; transition: background 0.2s;">
                <span style="font-size: 1.2rem;">üì•</span> Import Data
            </button>
            <div style="border-top: 1px solid #333; margin: 10px 0;"></div>
            <button onclick="logout()" style="width: 100%; text-align: left; padding: 12px 20px; background: none; border: none; color: #ff4444; cursor: pointer; display: flex; align-items: center; gap: 10px; transition: background 0.2s;">
                <span style="font-size: 1.2rem;">üö™</span> Logout
            </button>
        </div>
        
    <div class="container">
        <h1>Options Wheel Strategy Tracker</h1>
        <p class="subtitle">Track your puts and calls with automatic calculations</p>

        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 30px; border-bottom: 1px solid #333; position: relative;">
            <div class="tabs" style="border-bottom: none; margin-bottom: 0; flex: 1;">
                <button class="tab active" onclick="switchTab('dashboard')">Dashboard</button>
                <button class="tab" onclick="switchTab('open')">Open Positions <span class="tab-badge" id="tabOpenCount">0</span></button>
                <button class="tab" onclick="switchTab('groups')">Closed Groups <span class="tab-badge" id="tabGroupsCount">0</span></button>
                <button class="tab" onclick="switchTab('all')">All Trades <span class="tab-badge" id="tabAllCount">0</span></button>
                <button class="tab" onclick="switchTab('stock')">Stock Positions <span class="tab-badge" id="tabStockCount">0</span></button>
            </div>
            <div style="display: flex; gap: 10px; padding-bottom: 12px; align-items: center;">
                <button onclick="openTradeModal()" style="background: #00ff88; color: #000; border: none; padding: 10px 20px; border-radius: 6px; font-weight: 600; cursor: pointer; display: flex; align-items: center; gap: 8px; transition: all 0.2s;">
                    <span style="font-size: 1.2rem; line-height: 1;">+</span>
                    New Trade
                </button>
            </div>
        </div>

        <div class="stats-grid">
            <div class="stat-card">
                <div class="stat-label">Total P&L</div>
                <div class="stat-value" id="totalPL">$0</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Overall % Return on Money Risked</div>
                <div class="stat-value positive" id="overallReturn">0%</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Total Collateral Needed</div>
                <div class="stat-value" id="totalCollateral">$0</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Open Positions</div>
                <div class="stat-value" id="openPositions">0</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Closed Positions</div>
                <div class="stat-value" id="closedPositions">0</div>
            </div>
        </div>

        <!-- Controls removed - now in modal -->

        <div class="tab-content active" id="dashboardTab">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                <h2 style="margin: 0; font-size: 1.8rem;">Performance Metrics</h2>
                <div style="display: flex; gap: 10px; align-items: center;">
                    <label style="color: #888;">Account Filter:</label>
                    <select id="dashboardAccountFilter" onchange="updateDashboardMetrics()" style="padding: 8px 12px; background: #1a1a1a; border: 1px solid #333; color: #fff; border-radius: 4px; min-width: 150px;">
                        <option value="all">All Accounts</option>
                        <!-- Dynamically populated by JS -->
                    </select>
                </div>
            </div>
            
            <div class="dashboard-metrics">
                <!-- Win Rate Card -->
                <div class="metric-card">
                    <div class="metric-title">
                        Win Rate 
                        <button onclick="showWinRateInfo()" style="background: none; border: none; color: #00ff88; cursor: pointer; font-size: 0.9rem; margin-left: 5px;" title="How is this calculated?">‚ìò</button>
                    </div>
                    <div class="metric-value-large positive" id="winRate">0%</div>
                    <div class="metric-description">
                        <span id="winningTrades">0</span> winning / <span id="losingTrades">0</span> losing trades<br>
                        Based on <span id="totalClosedTrades">0</span> closed groups
                    </div>
                </div>

                <!-- Average Days to Expiration Card -->
                <div class="metric-card">
                    <div class="metric-title">Avg Days to Expiration</div>
                    <div class="metric-value-large" id="avgDTE" style="color: #4488ff;">0</div>
                    <div class="metric-description">
                        Average holding period for open positions<br>
                        Range: <span id="minDTE">0</span> - <span id="maxDTE">0</span> days
                    </div>
                </div>

                <!-- Portfolio Allocation Card -->
                <div class="metric-card" style="grid-column: span 2;">
                    <div class="metric-title">Portfolio Allocation by Symbol</div>
                    <div class="metric-description" style="margin-bottom: 15px;">
                        Capital at risk across all open positions
                    </div>
                    <div id="allocationList" class="allocation-list">
                        <!-- Will be populated by JS -->
                    </div>
                </div>
            </div>

            <!-- Weekly Premium Collected Section -->
            <h2 style="margin: 40px 0 20px 0; font-size: 1.8rem;">Weekly Premium Collected</h2>
            <div style="margin-bottom: 20px; display: flex; gap: 10px; align-items: center;">
                <label style="color: #888;">Date Range:</label>
                <select id="weeklyRangeFilter" onchange="updateWeeklyPremium()" style="padding: 8px 12px; background: #1a1a1a; border: 1px solid #333; color: #fff; border-radius: 4px;">
                    <option value="prev4next4">Previous 4 & Next 4</option>
                    <option value="-" disabled>‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</option>
                    <option value="next4">Next 4 Weeks</option>
                    <option value="next8">Next 8 Weeks</option>
                    <option value="next12">Next 12 Weeks</option>
                    <option value="-" disabled>‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</option>
                    <option value="4">Last 4 Weeks</option>
                    <option value="8">Last 8 Weeks</option>
                    <option value="12" selected>Last 12 Weeks</option>
                    <option value="26">Last 6 Months</option>
                    <option value="52">Last Year</option>
                    <option value="all">All Time</option>
                </select>
                <label style="color: #888; margin-left: 20px;">Display:</label>
                <select id="weeklyDisplayType" onchange="updateWeeklyPremium()" style="padding: 8px 12px; background: #1a1a1a; border: 1px solid #333; color: #fff; border-radius: 4px;">
                    <option value="chart">Bar Chart</option>
                    <option value="table">Table View</option>
                    <option value="cards">Card View</option>
                </select>
            </div>
            
            <!-- Bar Chart Display -->
            <div id="weeklyChartView" style="display: none;">
                <div class="metric-card" style="padding: 30px;">
                    <div id="weeklyChart" style="min-height: 300px;"></div>
                </div>
            </div>
            
            <!-- Table Display -->
            <div id="weeklyTableView" style="display: none;">
                <div class="table-container">
                    <table>
                        <thead>
                            <tr>
                                <th>Week Starting</th>
                                <th>Week Ending</th>
                                <th>Premium Collected</th>
                                <th>Number of Trades</th>
                                <th>Avg per Trade</th>
                            </tr>
                        </thead>
                        <tbody id="weeklyTableBody">
                            <!-- Populated by JS -->
                        </tbody>
                    </table>
                </div>
            </div>
            
            <!-- Card Display -->
            <div id="weeklyCardsView" style="display: none;">
                <div id="weeklyCardsContainer" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)); gap: 15px;">
                    <!-- Populated by JS -->
                </div>
            </div>

            <h2 style="margin: 40px 0 20px 0; font-size: 1.8rem;">Quick Stats</h2>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                <div class="metric-card">
                    <div class="metric-title">Avg Trade P&L</div>
                    <div style="font-size: 1.5rem; font-weight: 700;" id="avgTradePL">$0</div>
                </div>
                <div class="metric-card">
                    <div class="metric-title">Best Trade ($)</div>
                    <div style="font-size: 1.5rem; font-weight: 700; color: #00ff88;" id="bestTrade">$0</div>
                </div>
                <div class="metric-card">
                    <div class="metric-title">Worst Trade ($)</div>
                    <div style="font-size: 1.5rem; font-weight: 700; color: #ff4444;" id="worstTrade">$0</div>
                </div>
            </div>
        </div>

        <div class="tab-content" id="openTab">
            <div class="table-container">
                <div class="table-header">
                    <div class="table-title">All Open Positions</div>
                </div>
                <table>
                    <thead>
                        <tr>
                            <th class="sortable" onclick="sortTable('open', 'symbol', 'text')">Symbol</th>
                            <th class="sortable" onclick="sortTable('open', 'contracts', 'number')">Contracts</th>
                            <th class="sortable" onclick="sortTable('open', 'strike', 'number')">Strike</th>
                            <th class="sortable" onclick="sortTable('open', 'premium', 'number')">Premium</th>
                            <th class="sortable" onclick="sortTable('open', 'action', 'text')">Action</th>
                            <th class="sortable" onclick="sortTable('open', 'type', 'text')">Type</th>
                            <th class="sortable" onclick="sortTable('open', 'dateOpened', 'date')">Date Opened</th>
                            <th class="sortable" onclick="sortTable('open', 'expDate', 'date')">Exp Date</th>
                            <th class="sortable" onclick="sortTable('open', 'cashRequired', 'number')">Cash Required</th>
                            <th class="sortable" onclick="sortTable('open', 'percentReturn', 'number')">% Return</th>
                            <th class="sortable" onclick="sortTable('open', 'priceAtAction', 'number')">Price @ Action</th>
                            <th class="sortable" onclick="sortTable('open', 'percentOTM', 'number')">% OTM</th>
                            <th class="sortable" onclick="sortTable('open', 'pl', 'number')">P&L</th>
                            <th class="sortable" onclick="sortTable('open', 'info', 'text')">Info</th>
                            <th class="sortable" onclick="sortTable('open', 'tradeRef', 'text')">Trade Ref #</th>
                            <th class="sortable" onclick="sortTable('open', 'account', 'text')">Account</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody id="openTradesTableBody">
                        <tr>
                            <td colspan="17" style="text-align: center; color: #666; padding: 40px;">
                                No open positions. Add your first trade above.
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <div class="table-container" style="margin-top: 30px;">
                <div class="table-header">
                    <div class="table-title">Open Positions by Stock</div>
                    <div>
                        <select id="stockFilter" onchange="filterByStock()" style="padding: 8px 16px; background: #000; color: #fff; border: 1px solid #333; border-radius: 4px; font-size: 1rem;">
                            <option value="">Select a stock...</option>
                        </select>
                    </div>
                </div>
                <table>
                    <thead>
                        <tr>
                            <th class="sortable" onclick="sortTable('openByStock', 'symbol', 'text')">Symbol</th>
                            <th class="sortable" onclick="sortTable('openByStock', 'contracts', 'number')">Contracts</th>
                            <th class="sortable" onclick="sortTable('openByStock', 'strike', 'number')">Strike</th>
                            <th class="sortable" onclick="sortTable('openByStock', 'premium', 'number')">Premium</th>
                            <th class="sortable" onclick="sortTable('openByStock', 'action', 'text')">Action</th>
                            <th class="sortable" onclick="sortTable('openByStock', 'type', 'text')">Type</th>
                            <th class="sortable" onclick="sortTable('openByStock', 'dateOpened', 'date')">Date Opened</th>
                            <th class="sortable" onclick="sortTable('openByStock', 'expDate', 'date')">Exp Date</th>
                            <th class="sortable" onclick="sortTable('openByStock', 'cashRequired', 'number')">Cash Required</th>
                            <th class="sortable" onclick="sortTable('openByStock', 'percentReturn', 'number')">% Return</th>
                            <th class="sortable" onclick="sortTable('openByStock', 'priceAtAction', 'number')">Price @ Action</th>
                            <th class="sortable" onclick="sortTable('openByStock', 'percentOTM', 'number')">% OTM</th>
                            <th class="sortable" onclick="sortTable('openByStock', 'pl', 'number')">P&L</th>
                            <th class="sortable" onclick="sortTable('openByStock', 'credit', 'number')">Credit <span style="display: inline-block; width: 14px; height: 14px; background: #333; color: #fff; border-radius: 50%; text-align: center; line-height: 14px; font-size: 0.7rem; cursor: help; font-weight: bold;" title="Net credit from most recent roll (New Premium - Buyback Cost)">‚ìò</span></th>
                            <th class="sortable" onclick="sortTable('openByStock', 'info', 'text')">Info</th>
                            <th class="sortable" onclick="sortTable('openByStock', 'tradeRef', 'text')">Trade Ref #</th>
                            <th class="sortable" onclick="sortTable('openByStock', 'account', 'text')">Account</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody id="filteredTradesTableBody">
                        <tr>
                            <td colspan="18" style="text-align: center; color: #666; padding: 40px;">
                                Select a stock from the dropdown above to view positions.
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <div class="table-container" style="margin-top: 30px;">
                <div class="table-header">
                    <div class="table-title">Open Positions by Expiration Date</div>
                </div>
                <table>
                    <thead>
                        <tr>
                            <th>Symbol</th>
                            <th>Contracts</th>
                            <th>Strike</th>
                            <th>Premium</th>
                            <th>Action</th>
                            <th>Type</th>
                            <th>Date Opened <span style="cursor: pointer; user-select: none;" onclick="sortExpirationTrades('dateOpened', 'asc')">‚ñ≤</span><span style="cursor: pointer; user-select: none;" onclick="sortExpirationTrades('dateOpened', 'desc')">‚ñº</span></th>
                            <th>Exp Date</th>
                            <th>Days Till Exp</th>
                            <th>Cash Required</th>
                            <th>% Return</th>
                            <th>Price @ Action</th>
                            <th>% OTM</th>
                            <th>P&L</th>
                            <th>Info</th>
                            <th>Trade Ref #</th>
                            <th>Account</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody id="expirationTradesTableBody">
                        <tr>
                            <td colspan="18" style="text-align: center; color: #666; padding: 40px;">
                                No open positions.
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="tab-content" id="groupsTab">
            <div style="margin-bottom: 20px; display: flex; gap: 10px;">
                <button onclick="autoGroupByTradeRef()" style="background: #00ff88; color: #000;">Auto-Group by Trade Ref #</button>
                <button onclick="createNewGroup()">Create New Group</button>
                <button class="secondary" onclick="showGroupManager()">Manage Groups</button>
            </div>
            
            <div id="groupsList"></div>
        </div>

        <div class="tab-content" id="allTab">
            <div class="table-container">
                <div class="table-header">
                    <div class="table-title">All Trades (Open & Closed)</div>
                    <div style="display: flex; gap: 15px; align-items: center;">
                        <div style="display: flex; gap: 10px;">
                            <button onclick="filterAllTrades('all')" id="filterAllBtn" style="padding: 6px 16px; background: #00ff88; color: #000; border: none; border-radius: 20px; font-size: 0.9rem; cursor: pointer; font-weight: bold;">All Trades</button>
                            <button onclick="filterAllTrades('open')" id="filterOpenBtn" style="padding: 6px 16px; background: #333; color: #fff; border: none; border-radius: 20px; font-size: 0.9rem; cursor: pointer;">Open Trades</button>
                            <button onclick="filterAllTrades('closed')" id="filterClosedBtn" style="padding: 6px 16px; background: #333; color: #fff; border: none; border-radius: 20px; font-size: 0.9rem; cursor: pointer;">Closed Trades</button>
                            <button onclick="filterAllTrades('rolled')" id="filterRolledBtn" style="padding: 6px 16px; background: #333; color: #fff; border: none; border-radius: 20px; font-size: 0.9rem; cursor: pointer;">Rolled Trades</button>
                            <button onclick="filterAllTrades('assigned')" id="filterAssignedBtn" style="padding: 6px 16px; background: #333; color: #fff; border: none; border-radius: 20px; font-size: 0.9rem; cursor: pointer;">Assigned</button>
                        </div>
                        <div style="display: flex; align-items: center; gap: 8px; margin-left: auto;">
                            <label for="allTradesSymbolFilter" style="margin: 0; color: #888; font-size: 0.9rem;">Symbol:</label>
                            <select id="allTradesSymbolFilter" style="min-width: 120px; background: #000; border: 1px solid #333; color: #fff; padding: 6px 10px; border-radius: 4px; font-size: 0.9rem; cursor: pointer;">
                                <option value="">All</option>
                            </select>
                            <button onclick="populateSymbolFilter(); renderAllTrades();" style="padding: 6px 12px; background: #333; color: #fff; border: none; border-radius: 4px; font-size: 0.85rem; cursor: pointer;" title="Refresh symbol list">‚Üª</button>
                        </div>
                    </div>
                </div>
                <table>
                    <thead>
                        <tr>
                            <th class="sortable" onclick="sortTable('all', 'status', 'text')">Status</th>
                            <th class="sortable" onclick="sortTable('all', 'symbol', 'text')">Symbol</th>
                            <th class="sortable" onclick="sortTable('all', 'contracts', 'number')">Contracts</th>
                            <th class="sortable" onclick="sortTable('all', 'strike', 'number')">Strike</th>
                            <th class="sortable" onclick="sortTable('all', 'premium', 'number')">Premium</th>
                            <th class="sortable" onclick="sortTable('all', 'action', 'text')">Action</th>
                            <th class="sortable" onclick="sortTable('all', 'type', 'text')">Type</th>
                            <th class="sortable" onclick="sortTable('all', 'dateOpened', 'date')">Date Opened</th>
                            <th class="sortable" onclick="sortTable('all', 'dateClosed', 'date')">Date Closed</th>
                            <th class="sortable" onclick="sortTable('all', 'expDate', 'date')">Exp Date</th>
                            <th class="sortable" onclick="sortTable('all', 'cashRequired', 'number')">Cash Required</th>
                            <th class="sortable" onclick="sortTable('all', 'percentReturn', 'number')">% Return</th>
                            <th class="sortable" onclick="sortTable('all', 'pl', 'number')">P&L</th>
                            <th class="sortable" onclick="sortTable('all', 'credit', 'number')">Credit <span style="display: inline-block; width: 14px; height: 14px; background: #333; color: #fff; border-radius: 50%; text-align: center; line-height: 14px; font-size: 0.7rem; cursor: help; font-weight: bold;" title="Net credit from most recent roll (New Premium - Buyback Cost)">‚ìò</span></th>
                            <th class="sortable" onclick="sortTable('all', 'info', 'text')">Info</th>
                            <th class="sortable" onclick="sortTable('all', 'tradeRef', 'text')">Trade Ref #</th>
                            <th class="sortable" onclick="sortTable('all', 'account', 'text')">Account</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody id="allTradesTableBody">
                        <tr>
                            <td colspan="18" style="text-align: center; color: #666; padding: 40px;">
                                No trades yet.
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="tab-content" id="stockTab">
            <div class="table-container">
                <div class="table-header">
                    <div class="table-title">Stock Positions (Assigned)</div>
                </div>
                <table>
                    <thead>
                        <tr>
                            <th class="sortable" onclick="sortTable('stock', 'symbol', 'text')">Symbol</th>
                            <th class="sortable" onclick="sortTable('stock', 'shares', 'number')">Shares</th>
                            <th class="sortable" onclick="sortTable('stock', 'costBasis', 'number')">Cost Basis</th>
                            <th class="sortable" onclick="sortTable('stock', 'assignedPrice', 'number')">Assigned Price</th>
                            <th class="sortable" onclick="sortTable('stock', 'totalValue', 'number')">Total Value</th>
                            <th class="sortable" onclick="sortTable('stock', 'assignedDate', 'date')">Assigned Date</th>
                            <th>Original Put</th>
                            <th>Covered Calls</th>
                            <th class="sortable" onclick="sortTable('stock', 'account', 'text')">Account</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody id="stockPositionsBody">
                    </tbody>
                </table>
            </div>
        </div>

        <!-- Symbol Detail View -->
        <div class="tab-content" id="symbolDetailTab" style="display: none;">
            <div style="margin-bottom: 20px; display: flex; justify-content: space-between; align-items: center;">
                <h2 id="symbolDetailTitle" style="color: #00ff88; margin: 0;">Symbol Detail</h2>
                <button onclick="closeSymbolDetail()" style="padding: 8px 16px; background: #333; color: #fff; border: none; border-radius: 4px; cursor: pointer;">‚Üê Back</button>
            </div>
            
            <!-- All Trades Section with Filters -->
            <div class="table-container">
                <div class="table-header">
                    <div class="table-title">All Trades</div>
                    <div style="display: flex; gap: 10px;">
                        <button onclick="filterSymbolTrades('all')" id="symbolFilterAllBtn" style="padding: 6px 16px; background: #00ff88; color: #000; border: none; border-radius: 20px; font-size: 0.9rem; cursor: pointer; font-weight: bold;">All Trades</button>
                        <button onclick="filterSymbolTrades('open')" id="symbolFilterOpenBtn" style="padding: 6px 16px; background: #333; color: #fff; border: none; border-radius: 20px; font-size: 0.9rem; cursor: pointer;">Open Trades</button>
                        <button onclick="filterSymbolTrades('closed')" id="symbolFilterClosedBtn" style="padding: 6px 16px; background: #333; color: #fff; border: none; border-radius: 20px; font-size: 0.9rem; cursor: pointer;">Closed Trades</button>
                        <button onclick="filterSymbolTrades('rolled')" id="symbolFilterRolledBtn" style="padding: 6px 16px; background: #333; color: #fff; border: none; border-radius: 20px; font-size: 0.9rem; cursor: pointer;">Rolled Trades</button>
                        <button onclick="filterSymbolTrades('assigned')" id="symbolFilterAssignedBtn" style="padding: 6px 16px; background: #333; color: #fff; border: none; border-radius: 20px; font-size: 0.9rem; cursor: pointer;">Assigned</button>
                    </div>
                </div>
                <table>
                    <thead>
                        <tr>
                            <th class="sortable" onclick="sortTable('symbolDetail', 'status', 'text')">Status</th>
                            <th class="sortable" onclick="sortTable('symbolDetail', 'symbol', 'text')">Symbol</th>
                            <th class="sortable" onclick="sortTable('symbolDetail', 'contracts', 'number')">Contracts</th>
                            <th class="sortable" onclick="sortTable('symbolDetail', 'strike', 'number')">Strike</th>
                            <th class="sortable" onclick="sortTable('symbolDetail', 'premium', 'number')">Premium</th>
                            <th class="sortable" onclick="sortTable('symbolDetail', 'action', 'text')">Action</th>
                            <th class="sortable" onclick="sortTable('symbolDetail', 'type', 'text')">Type</th>
                            <th class="sortable" onclick="sortTable('symbolDetail', 'dateOpened', 'date')">Date Opened</th>
                            <th class="sortable" onclick="sortTable('symbolDetail', 'dateClosed', 'date')">Date Closed</th>
                            <th class="sortable" onclick="sortTable('symbolDetail', 'expDate', 'date')">Exp Date</th>
                            <th class="sortable" onclick="sortTable('symbolDetail', 'cashRequired', 'number')">Cash Required</th>
                            <th class="sortable" onclick="sortTable('symbolDetail', 'percentReturn', 'number')">Return %</th>
                            <th class="sortable" onclick="sortTable('symbolDetail', 'pl', 'number')">P&L</th>
                            <th class="sortable" onclick="sortTable('symbolDetail', 'info', 'text')">Info</th>
                            <th class="sortable" onclick="sortTable('symbolDetail', 'tradeRef', 'text')">Trade Ref #</th>
                            <th class="sortable" onclick="sortTable('symbolDetail', 'account', 'text')">Account</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody id="symbolTradesBody">
                    </tbody>
                </table>
            </div>

            <!-- Closed Groups Section -->
            <div style="margin-top: 30px;">
                <h3 style="color: #00ff88; margin-bottom: 15px;">Closed Groups</h3>
                <div id="symbolGroupsList"></div>
            </div>
        </div>
    </div>

    <div class="modal" id="closeModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">Close Position</div>
                <button class="close-btn" onclick="closeCloseModal()">√ó</button>
            </div>
            <div class="form-grid">
                <div class="form-group">
                    <label>Close Date</label>
                    <input type="date" id="closeDate">
                </div>
                <div class="form-group">
                    <label>Closing Premium (if bought back)</label>
                    <input type="number" id="closingPremium" placeholder="0.50" step="0.01" value="0">
                </div>
                <div class="form-group">
                    <label>Final Notes</label>
                    <input type="text" id="closingNotes" placeholder="Expired worthless, rolled, etc.">
                </div>
            </div>
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button class="success" onclick="confirmClose()">Close Position</button>
                <button class="secondary" onclick="closeCloseModal()">Cancel</button>
            </div>
        </div>
    </div>

    <div class="modal" id="assignModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">Assign Stock</div>
                <button class="close-btn" onclick="closeAssignModal()">√ó</button>
            </div>
            <div class="form-grid">
                <div class="form-group">
                    <label>Assignment Date</label>
                    <input type="date" id="assignDate">
                </div>
                <div class="form-group">
                    <label>Assignment Price (per share)</label>
                    <input type="number" id="assignmentPrice" placeholder="870.00" step="0.01">
                </div>
                <div class="form-group">
                    <label>Assignment Notes</label>
                    <input type="text" id="assignmentNotes" placeholder="Stock assigned">
                </div>
            </div>
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button style="background: #ff8844; color: #000;" onclick="confirmAssign()">Assign Stock</button>
                <button class="secondary" onclick="closeAssignModal()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Called Out Modal -->
    <div class="modal" id="calledOutModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">Stock Called Away</div>
                <button class="close-btn" onclick="closeCalledOutModal()">√ó</button>
            </div>
            <div class="form-grid">
                <div class="form-group">
                    <label>Called Away Date</label>
                    <input type="date" id="calledOutDate">
                </div>
                <div class="form-group">
                    <label>Call Away Price (per share)</label>
                    <input type="number" id="calledOutPrice" placeholder="Strike price" step="0.01">
                </div>
                <div class="form-group">
                    <label>Notes</label>
                    <input type="text" id="calledOutNotes" placeholder="Stock called away">
                </div>
            </div>
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button style="background: #ff4488; color: #fff;" onclick="confirmCalledOut()">Confirm Called Out</button>
                <button class="secondary" onclick="closeCalledOutModal()">Cancel</button>
            </div>
        </div>
    </div>

    <div class="modal" id="sellCallModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">Sell Covered Call</div>
                <button class="close-btn" onclick="closeSellCallModal()">√ó</button>
            </div>
            <div class="form-grid">
                <div class="form-group">
                    <label>Strike Price</label>
                    <input type="number" id="callStrike" placeholder="900.00" step="0.01">
                </div>
                <div class="form-group">
                    <label>Premium Received</label>
                    <input type="number" id="callPremium" placeholder="5.00" step="0.01">
                </div>
                <div class="form-group">
                    <label>Expiration Date</label>
                    <input type="date" id="callExpDate">
                </div>
                <div class="form-group">
                    <label>Date Opened</label>
                    <input type="date" id="callDateOpened">
                </div>
                <div class="form-group">
                    <label>Notes</label>
                    <input type="text" id="callNotes" placeholder="Covered call">
                </div>
            </div>
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button class="success" onclick="confirmSellCall()">Sell Call</button>
                <button class="secondary" onclick="closeSellCallModal()">Cancel</button>
            </div>
        </div>
    </div>

    <div class="modal" id="calledAwayModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">Stock Called Away</div>
                <button class="close-btn" onclick="closeCalledAwayModal()">√ó</button>
            </div>
            <div class="form-grid">
                <div class="form-group">
                    <label>Called Away Date</label>
                    <input type="date" id="calledAwayDate">
                </div>
                <div class="form-group">
                    <label>Sale Price (per share)</label>
                    <input type="number" id="salePrice" placeholder="900.00" step="0.01">
                </div>
                <div class="form-group">
                    <label>Notes</label>
                    <input type="text" id="calledAwayNotes" placeholder="Stock called away">
                </div>
            </div>
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button class="success" onclick="confirmCalledAway()">Called Away</button>
                <button class="secondary" onclick="closeCalledAwayModal()">Cancel</button>
            </div>
        </div>
    </div>

    <div class="modal" id="rollModal">
        <div class="modal-content" style="max-width: 800px;">
            <div class="modal-header">
                <div class="modal-title">Roll Position</div>
                <button class="close-btn" onclick="closeRollModal()">√ó</button>
            </div>
            <p style="color: #888; margin-bottom: 20px;">Close the current position and open a new one</p>
            
            <h3 style="margin-bottom: 15px; color: #fff;">Close Current Position</h3>
            <div class="form-grid">
                <div class="form-group">
                    <label>Close Date</label>
                    <input type="date" id="rollCloseDate">
                </div>
                <div class="form-group">
                    <label>Closing Premium (paid to buy back)</label>
                    <input type="number" id="rollClosingPremium" placeholder="0.50" step="0.01">
                </div>
            </div>
            
            <h3 style="margin: 25px 0 15px 0; color: #fff;">Open New Position</h3>
            <div class="form-grid">
                <div class="form-group">
                    <label>New Strike</label>
                    <input type="number" id="rollNewStrike" placeholder="150.00" step="0.01">
                </div>
                <div class="form-group">
                    <label>New Premium (collected)</label>
                    <input type="number" id="rollNewPremium" placeholder="2.50" step="0.01">
                </div>
                <div class="form-group">
                    <label>New Exp Date</label>
                    <input type="date" id="rollNewExpDate">
                </div>
                <div class="form-group">
                    <label>Price at Roll</label>
                    <input type="number" id="rollPriceAtAction" placeholder="152.50" step="0.01">
                </div>
                <div class="form-group">
                    <label>Type</label>
                    <select id="rollNewType">
                        <option value="put">Put</option>
                        <option value="call">Call</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Roll Notes</label>
                    <input type="text" id="rollNotes" placeholder="Rolled up/out for credit">
                </div>
            </div>
            
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button style="background: #4488ff; color: #fff;" onclick="confirmRoll()">Complete Roll</button>
                <button class="secondary" onclick="closeRollModal()">Cancel</button>
            </div>
        </div>
    </div>

    <div class="modal" id="editModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">Edit Position</div>
                <button class="close-btn" onclick="closeEditModal()">√ó</button>
            </div>
            <div class="form-grid">
                <div class="form-group">
                    <label>Trade Ref #</label>
                    <input type="text" id="editTradeRef">
                </div>
                <div class="form-group">
                    <label>Symbol</label>
                    <input type="text" id="editSymbol" style="text-transform: uppercase;">
                </div>
                <div class="form-group">
                    <label>Contracts</label>
                    <input type="number" id="editContracts">
                </div>
                <div class="form-group">
                    <label>Strike</label>
                    <input type="number" id="editStrike" step="0.01">
                </div>
                <div class="form-group">
                    <label>Premium</label>
                    <input type="number" id="editPremium" step="0.01">
                </div>
                <div class="form-group">
                    <label>Action</label>
                    <select id="editAction">
                        <option value="sell">Sell</option>
                        <option value="buy">Buy</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Type</label>
                    <select id="editType">
                        <option value="put">Put</option>
                        <option value="call">Call</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Date Opened</label>
                    <input type="date" id="editDateOpened">
                </div>
                <div class="form-group">
                    <label>Exp Date</label>
                    <input type="date" id="editExpDate">
                </div>
                <div class="form-group">
                    <label>Price at Action</label>
                    <input type="number" id="editPriceAtAction" step="0.01">
                </div>
                <div class="form-group">
                    <label>Info/Notes</label>
                    <input type="text" id="editInfo">
                </div>
            </div>
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button onclick="saveEdit()">Save Changes</button>
                <button class="secondary" onclick="closeEditModal()">Cancel</button>
            </div>
        </div>
    </div>

    <div class="modal" id="accountModal">
        <div class="modal-content" style="max-width: 400px;">
            <div class="modal-header">
                <div class="modal-title">Add New Account</div>
                <button class="close-btn" onclick="closeAccountModal()">√ó</button>
            </div>
            <div class="form-group">
                <label>Account Name</label>
                <input type="text" id="newAccountName" placeholder="e.g., Robinhood, TD Ameritrade">
            </div>
            <div style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 20px;">
                <button class="secondary" onclick="closeAccountModal()">Cancel</button>
                <button onclick="saveNewAccount()">Add Account</button>
            </div>
        </div>
    </div>

    <!-- Import Options Modal -->
    <div class="modal" id="importOptionsModal">
        <div class="modal-content" style="max-width: 500px;">
            <div class="modal-header">
                <div class="modal-title">Import Data</div>
                <button class="close-btn" onclick="closeImportOptionsModal()">√ó</button>
            </div>
            <div style="padding: 20px 0;">
                <p style="color: #888; margin-bottom: 30px; text-align: center;">
                    Choose an option to import your trades
                </p>
                <div style="display: flex; flex-direction: column; gap: 15px;">
                    <button onclick="importData(); closeImportOptionsModal();" style="width: 100%; padding: 20px; background: #1a1a1a; border: 2px solid #00ff88; color: #fff; border-radius: 8px; cursor: pointer; display: flex; align-items: center; gap: 15px; transition: all 0.2s; font-size: 1rem;">
                        <span style="font-size: 2rem;">üì•</span>
                        <div style="text-align: left; flex: 1;">
                            <div style="font-weight: 600; margin-bottom: 5px;">Import File</div>
                            <div style="font-size: 0.85rem; color: #888;">Upload Excel, CSV, or JSON file</div>
                        </div>
                    </button>
                    <button onclick="downloadTemplate(); closeImportOptionsModal();" style="width: 100%; padding: 20px; background: #1a1a1a; border: 2px solid #4488ff; color: #fff; border-radius: 8px; cursor: pointer; display: flex; align-items: center; gap: 15px; transition: all 0.2s; font-size: 1rem;">
                        <span style="font-size: 2rem;">üìã</span>
                        <div style="text-align: left; flex: 1;">
                            <div style="font-weight: 600; margin-bottom: 5px;">Download Import Template</div>
                            <div style="font-size: 0.85rem; color: #888;">Get Excel template with examples</div>
                        </div>
                    </button>
                </div>
            </div>
            <div style="text-align: center; margin-top: 20px;">
                <button class="secondary" onclick="closeImportOptionsModal()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Win Rate Info Modal -->
    <div class="modal" id="winRateInfoModal">
        <div class="modal-content" style="max-width: 600px;">
            <div class="modal-header">
                <div class="modal-title">How is Win Rate Calculated?</div>
                <button class="close-btn" onclick="closeWinRateInfo()">√ó</button>
            </div>
            <div style="padding: 20px; line-height: 1.6; color: #ccc;">
                <p style="margin-bottom: 15px;">
                    Win Rate is calculated based on <strong style="color: #00ff88;">fully closed trade groups</strong> using the same Ref #.
                </p>
                <p style="margin-bottom: 15px;">
                    A trade only counts once it is <strong>completely closed</strong>, including all rolls. 
                </p>
                <ul style="margin: 15px 0; padding-left: 20px;">
                    <li style="margin-bottom: 10px;">If the final result of the full position is a <strong style="color: #00ff88;">net profit</strong>, it is counted as a <strong>win</strong>.</li>
                    <li style="margin-bottom: 10px;">If the final result is a <strong style="color: #ff4444;">net loss</strong>, or if the position ends in <strong>assignment</strong> or shares being <strong>called away</strong>, it is counted as a <strong>loss</strong>.</li>
                    <li style="margin-bottom: 10px;">Open or rolled positions that remain active are <strong>not included</strong> in the win rate.</li>
                </ul>
            </div>
            <div style="text-align: center; padding: 0 20px 20px;">
                <button class="primary" onclick="closeWinRateInfo()">Got it</button>
            </div>
        </div>
    </div>

    <!-- New Trade Modal -->
    <div class="modal" id="tradeModal">
        <div class="modal-content" style="max-width: 800px;">
            <div class="modal-header">
                <div class="modal-title">Add New Position</div>
                <button class="close-btn" onclick="closeTradeModal()">√ó</button>
            </div>
            <div class="form-grid">
                <div class="form-group">
                    <label>Symbol</label>
                    <input type="text" id="symbol" placeholder="Enter symbol..." style="text-transform: uppercase;">
                </div>
                <div class="form-group">
                    <label>Contracts</label>
                    <input type="number" id="contracts" placeholder="1" value="1">
                </div>
                <div class="form-group">
                    <label>Strike</label>
                    <input type="number" id="strike" placeholder="150.00" step="0.01">
                </div>
                <div class="form-group">
                    <label>Premium</label>
                    <input type="number" id="premium" placeholder="2.50" step="0.01">
                </div>
                <div class="form-group">
                    <label>Action</label>
                    <select id="action">
                        <option value="sell">Sell</option>
                        <option value="buy">Buy</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Type</label>
                    <select id="type">
                        <option value="put">Put</option>
                        <option value="call">Call</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Date Opened</label>
                    <input type="date" id="dateOpened">
                </div>
                <div class="form-group">
                    <label>Exp Date</label>
                    <input type="date" id="expDate">
                </div>
                <div class="form-group">
                    <label>Price at Action</label>
                    <input type="number" id="priceAtAction" placeholder="152.50" step="0.01">
                </div>
                <div class="form-group">
                    <label>Info/Notes</label>
                    <input type="text" id="info" placeholder="Optional notes">
                </div>
                <div class="form-group">
                    <label>Trade Ref #</label>
                    <input type="text" id="tradeRef" placeholder="e.g., TSLA-001">
                    <div id="lastRefDisplay" style="margin-top: 5px; padding: 5px 8px; background: #1a1a1a; border: 1px solid #333; border-radius: 4px; font-size: 0.85rem; color: #00ff88;">
                        Last Ref # used: <span id="lastRefValue" style="font-weight: bold;">None</span>
                        <span style="display: inline-block; margin-left: 8px; width: 14px; height: 14px; background: #333; color: #fff; border-radius: 50%; text-align: center; line-height: 14px; font-size: 0.7rem; cursor: help; font-weight: bold;" title="Use number order (1, 2, 3, 4...)">‚ìò</span>
                    </div>
                </div>
                <div class="form-group">
                    <label>Account</label>
                    <select id="account">
                        <option value="">Select Account...</option>
                        <option value="Main">Main</option>
                        <option value="IRA">IRA</option>
                        <option value="Roth IRA">Roth IRA</option>
                    </select>
                    <button type="button" onclick="addNewAccount()" style="margin-top: 5px; padding: 4px 8px; font-size: 0.9rem;">+ Add Account</button>
                </div>
            </div>
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button onclick="addTrade()">Add Position</button>
                <button class="secondary" onclick="clearForm()">Clear</button>
                <button class="secondary" onclick="closeTradeModal()">Cancel</button>
            </div>
        </div>
    </div>

    <div class="modal" id="groupModal">
        <div class="modal-content" style="max-width: 1000px;">
            <div class="modal-header">
                <div class="modal-title">Create Trade Group</div>
                <button class="close-btn" onclick="closeGroupModal()">√ó</button>
            </div>
            <div style="margin-bottom: 20px;">
                <label>Group Name</label>
                <input type="text" id="groupName" placeholder="e.g., TSLA 820 Roll" style="width: 100%; margin-top: 10px;">
            </div>
            <div style="margin-bottom: 20px;">
                <strong>Select trades to include in this group:</strong>
            </div>
            <div id="availableTrades" style="max-height: 400px; overflow-y: auto; margin-bottom: 20px;"></div>
            <div style="display: flex; gap: 10px;">
                <button onclick="saveGroup()">Create Group</button>
                <button class="secondary" onclick="closeGroupModal()">Cancel</button>
            </div>
        </div>
    </div>
    </div> <!-- End trackerApp -->

    <script>
        // Authentication System
        let currentUser = null;
        let users = JSON.parse(localStorage.getItem('trackerUsers')) || {};

        function showLogin() {
            document.getElementById('loginForm').classList.remove('hidden');
            document.getElementById('signupForm').classList.add('hidden');
            document.getElementById('loginError').classList.add('hidden');
            document.getElementById('signupError').classList.add('hidden');
        }

        function showSignup() {
            document.getElementById('loginForm').classList.add('hidden');
            document.getElementById('signupForm').classList.remove('hidden');
            document.getElementById('loginError').classList.add('hidden');
            document.getElementById('signupError').classList.add('hidden');
        }

        function login() {
            const username = document.getElementById('loginUsername').value.trim().toLowerCase();
            const password = document.getElementById('loginPassword').value;
            const errorDiv = document.getElementById('loginError');

            if (!username || !password) {
                errorDiv.textContent = 'Please enter username and password';
                errorDiv.classList.remove('hidden');
                return;
            }

            if (!users[username]) {
                errorDiv.textContent = 'Username not found';
                errorDiv.classList.remove('hidden');
                return;
            }

            if (users[username].password !== password) {
                errorDiv.textContent = 'Incorrect password';
                errorDiv.classList.remove('hidden');
                return;
            }

            // Successful login
            currentUser = username;
            localStorage.setItem('currentUser', username);
            showTrackerApp();
        }

        function signup() {
            const username = document.getElementById('signupUsername').value.trim().toLowerCase();
            const password = document.getElementById('signupPassword').value;
            const passwordConfirm = document.getElementById('signupPasswordConfirm').value;
            const errorDiv = document.getElementById('signupError');

            if (!username || !password || !passwordConfirm) {
                errorDiv.textContent = 'Please fill in all fields';
                errorDiv.classList.remove('hidden');
                return;
            }

            if (username.length < 3) {
                errorDiv.textContent = 'Username must be at least 3 characters';
                errorDiv.classList.remove('hidden');
                return;
            }

            if (password !== passwordConfirm) {
                errorDiv.textContent = 'Passwords do not match';
                errorDiv.classList.remove('hidden');
                return;
            }

            if (users[username]) {
                errorDiv.textContent = 'Username already exists';
                errorDiv.classList.remove('hidden');
                return;
            }

            // Create new user
            users[username] = {
                password: password,
                created: new Date().toISOString()
            };
            localStorage.setItem('trackerUsers', JSON.stringify(users));

            // Auto-login
            currentUser = username;
            localStorage.setItem('currentUser', username);
            showTrackerApp();
        }

        function logout() {
            if (confirm('Are you sure you want to logout?')) {
                currentUser = null;
                localStorage.removeItem('currentUser');
                document.getElementById('authScreen').classList.remove('hidden');
                document.getElementById('trackerApp').classList.add('hidden');
                showLogin();
                // Clear form fields
                document.getElementById('loginUsername').value = '';
                document.getElementById('loginPassword').value = '';
            }
        }

        function showTrackerApp() {
            document.getElementById('authScreen').classList.add('hidden');
            document.getElementById('trackerApp').classList.remove('hidden');
            // Load user's specific data
            loadUserData();
            
            // Clean up any duplicate trade references in groups
            cleanupDuplicateGroupTrades();
            
            loadCustomAccounts();
            setTodayDate();
            
            // Run data migrations
            runDataMigrations();
            
            renderOpenTrades();
            populateSymbolFilter();
            renderAllTrades();
            renderStockPositions();
            updateStats();
            updateTabBadges(); // Update badges immediately
            
            // Ensure badges are updated after everything loads
            setTimeout(() => {
                updateTabBadges();
            }, 100);
        }

        // Data Migration System
        function runDataMigrations() {
            if (!currentUser) return;
            
            const versionKey = getUserStorageKey('dataVersion');
            const currentVersion = parseInt(localStorage.getItem(versionKey)) || 1;
            
            console.log('Current data version:', currentVersion);
            console.log('Target data version:', CURRENT_DATA_VERSION);
            
            if (currentVersion < CURRENT_DATA_VERSION) {
                console.log('Running migrations from version', currentVersion, 'to', CURRENT_DATA_VERSION);
                
                // Migration 1 ‚Üí 2: Mark existing rolled positions
                if (currentVersion < 2) {
                    migration_v2_markRolledTrades();
                }
                
                // Migration 2 ‚Üí 3: Add priceAtAction to trades missing it
                if (currentVersion < 3) {
                    migration_v3_addPriceAtAction();
                }
                
                // Migration 3 ‚Üí 4: Rebuild stock positions from assigned trades
                if (currentVersion < 4) {
                    migration_v4_rebuildStockPositions();
                }
                
                // Future migrations go here
                // if (currentVersion < 5) {
                //     migration_v5_someOtherFix();
                // }
                
                // Update version
                localStorage.setItem(versionKey, CURRENT_DATA_VERSION);
                console.log('Migrations complete! Data version now:', CURRENT_DATA_VERSION);
                
                // Save migrated data
                saveData();
            } else {
                console.log('Data is up to date, no migrations needed');
            }
        }

        // Migration v1 ‚Üí v2: Mark existing rolled positions
        function migration_v2_markRolledTrades() {
            console.log('Running migration v2: Marking rolled trades');
            
            let markedCount = 0;
            
            // Mark open trades with "Rolled:" in info
            trades.forEach(trade => {
                if (trade.info && trade.info.toLowerCase().includes('rolled:') && !trade.isRolled) {
                    trade.isRolled = true;
                    markedCount++;
                    console.log('Marked as rolled:', trade.symbol, trade.strike, trade.dateOpened);
                }
            });
            
            // Also check closed trades
            closedTrades.forEach(trade => {
                if (trade.info && trade.info.toLowerCase().includes('rolled:') && !trade.isRolled) {
                    trade.isRolled = true;
                    markedCount++;
                    console.log('Marked closed trade as rolled:', trade.symbol, trade.strike, trade.dateOpened);
                }
            });
            
            // Check trades in groups
            tradeGroups.forEach(group => {
                if (group.trades && Array.isArray(group.trades)) {
                    group.trades.forEach(trade => {
                        if (trade.info && trade.info.toLowerCase().includes('rolled:') && !trade.isRolled) {
                            trade.isRolled = true;
                            markedCount++;
                            console.log('Marked group trade as rolled:', trade.symbol, trade.strike, trade.dateOpened);
                        }
                    });
                }
            });
            
            console.log('Migration v2 complete: Marked', markedCount, 'trades as rolled');
        }

        // Migration v2 ‚Üí v3: Add priceAtAction to trades missing it
        function migration_v3_addPriceAtAction() {
            console.log('Running migration v3: Adding priceAtAction to trades');
            
            let fixedCount = 0;
            
            // Fix open trades
            trades.forEach(trade => {
                if (trade.priceAtAction === undefined) {
                    trade.priceAtAction = trade.strike || 0;
                    fixedCount++;
                    console.log('Added priceAtAction to trade:', trade.symbol, trade.strike);
                }
            });
            
            // Fix closed trades
            closedTrades.forEach(trade => {
                if (trade.priceAtAction === undefined) {
                    if (trade.isAssignment && trade.assignedPrice) {
                        trade.priceAtAction = trade.assignedPrice;
                    } else if (trade.isCalledAway && trade.strike) {
                        trade.priceAtAction = trade.strike;
                    } else {
                        trade.priceAtAction = trade.strike || 0;
                    }
                    fixedCount++;
                    console.log('Added priceAtAction to closed trade:', trade.symbol, trade.strike);
                }
            });
            
            // Fix trades in groups
            tradeGroups.forEach(group => {
                if (group.trades && Array.isArray(group.trades)) {
                    group.trades.forEach(trade => {
                        if (trade.priceAtAction === undefined) {
                            trade.priceAtAction = trade.strike || 0;
                            fixedCount++;
                            console.log('Added priceAtAction to group trade:', trade.symbol, trade.strike);
                        }
                    });
                }
            });
            
            console.log('Migration v3 complete: Fixed', fixedCount, 'trades');
        }

        // Migration v3 ‚Üí v4: Rebuild stock positions from assigned trades
        function migration_v4_rebuildStockPositions() {
            console.log('Running migration v4: Rebuilding stock positions from assigned trades');
            
            let rebuiltCount = 0;
            
            // Find all assigned PUT trades that don't have a corresponding stock position
            const assignedPuts = closedTrades.filter(t => 
                t.status === 'assigned' && 
                t.type === 'put' && 
                t.action === 'sell'
            );
            
            assignedPuts.forEach(put => {
                // Check if this put already has a stock position
                const existingPosition = stockPositions.find(sp => sp.originalPutId === put.id);
                
                if (!existingPosition) {
                    console.log(`Rebuilding stock position for ${put.symbol} from assigned PUT`);
                    
                    // Find any covered calls linked to this position by trade ref
                    const linkedCalls = trades.filter(t => 
                        t.symbol === put.symbol &&
                        t.type === 'call' &&
                        t.action === 'sell' &&
                        t.isCoveredCall &&
                        t.tradeRef === put.tradeRef
                    );
                    
                    // Build covered calls array
                    const coveredCalls = linkedCalls.map(call => ({
                        id: call.id,
                        strike: call.strike,
                        premium: call.premium * call.contracts * 100,
                        premiumPerShare: call.premium,
                        expDate: call.expDate,
                        dateOpened: call.dateOpened,
                        notes: call.info || ''
                    }));
                    
                    // Create stock position
                    const stockPosition = {
                        id: put.id + '_stock', // Use put ID to prevent duplicates
                        symbol: put.symbol,
                        shares: put.contracts * 100,
                        costBasis: put.strike,
                        assignedPrice: put.assignmentPrice || put.strike,
                        totalCost: put.strike * put.contracts * 100,
                        totalValue: (put.assignmentPrice || put.strike) * put.contracts * 100,
                        assignedDate: put.dateClosed || put.dateOpened,
                        originalPutId: put.id,
                        originalPut: {
                            strike: put.strike,
                            premium: put.premium,
                            contracts: put.contracts,
                            dateOpened: put.dateOpened,
                            tradeRef: put.tradeRef,
                            premiumCollected: put.premium * put.contracts * 100
                        },
                        coveredCalls: coveredCalls,
                        account: put.account || '',
                        tradeRef: put.tradeRef || '',
                        status: 'holding'
                    };
                    
                    stockPositions.push(stockPosition);
                    rebuiltCount++;
                    console.log(`‚úÖ Rebuilt stock position for ${put.symbol}:`, stockPosition);
                }
            });
            
            console.log('Migration v4 complete: Rebuilt', rebuiltCount, 'stock positions');
        }

        function checkAuth() {
            const savedUser = localStorage.getItem('currentUser');
            if (savedUser && users[savedUser]) {
                currentUser = savedUser;
                showTrackerApp();
            } else {
                document.getElementById('authScreen').classList.remove('hidden');
                document.getElementById('trackerApp').classList.add('hidden');
            }
        }

        // User-specific data storage
        function getUserStorageKey(key) {
            return `${currentUser}_${key}`;
        }

        function loadUserData() {
            trades = JSON.parse(localStorage.getItem(getUserStorageKey('wheelTrades'))) || [];
            closedTrades = JSON.parse(localStorage.getItem(getUserStorageKey('wheelClosedTrades'))) || [];
            tradeGroups = JSON.parse(localStorage.getItem(getUserStorageKey('wheelTradeGroups'))) || [];
            customAccounts = JSON.parse(localStorage.getItem(getUserStorageKey('customAccounts'))) || [];
            stockPositions = JSON.parse(localStorage.getItem(getUserStorageKey('stockPositions'))) || [];
            updateLastRefDisplay();
        }

        function updateLastRefDisplay() {
            // Get all trades with Trade Ref #s
            const allTrades = [...trades, ...closedTrades];
            const tradesWithRef = allTrades.filter(t => t.tradeRef && t.tradeRef.trim() !== '');
            
            if (tradesWithRef.length === 0) {
                document.getElementById('lastRefValue').textContent = 'None';
                return;
            }
            
            // Extract numbers from each ref and find the highest
            let highestNumber = -1;
            let highestRef = '';
            
            tradesWithRef.forEach(trade => {
                const ref = trade.tradeRef.trim();
                
                // Extract all numbers from the ref (e.g., "Main - 3" -> [3], "Roth - 2" -> [2])
                const numbers = ref.match(/\d+/g);
                
                if (numbers && numbers.length > 0) {
                    // Get the largest number found in this ref
                    const maxNum = Math.max(...numbers.map(n => parseInt(n)));
                    
                    if (maxNum > highestNumber) {
                        highestNumber = maxNum;
                        highestRef = ref;
                    }
                }
            });
            
            // If we found refs with numbers, show the one with highest number
            if (highestNumber >= 0) {
                document.getElementById('lastRefValue').textContent = highestRef;
            } else {
                // No numbers found in any refs, just show most recent by date
                tradesWithRef.sort((a, b) => new Date(b.dateOpened) - new Date(a.dateOpened));
                document.getElementById('lastRefValue').textContent = tradesWithRef[0].tradeRef;
            }
        }

        function saveUserData() {
            localStorage.setItem(getUserStorageKey('wheelTrades'), JSON.stringify(trades));
            localStorage.setItem(getUserStorageKey('wheelClosedTrades'), JSON.stringify(closedTrades));
            localStorage.setItem(getUserStorageKey('wheelTradeGroups'), JSON.stringify(tradeGroups));
            localStorage.setItem(getUserStorageKey('customAccounts'), JSON.stringify(customAccounts));
            localStorage.setItem(getUserStorageKey('stockPositions'), JSON.stringify(stockPositions));
        }

        // Original variables
        let trades = [];
        let closedTrades = [];
        let tradeGroups = []; // Groups of related trades (open + close)
        let customAccounts = []; // User-defined account names
        let stockPositions = []; // Stock positions from assignments
        let editingIndex = -1;
        
        // Data version for migrations
        const CURRENT_DATA_VERSION = 4;
        let editingFromArray = 'open'; // Track which array we're editing from
        let editingFromGroup = -1; // Track if editing from a group
        let closingIndex = -1;
        let rollingIndex = -1; // Track which position is being rolled
        let currentTab = 'dashboard';
        
        // Sort state
        let openTradesSortField = 'dateOpened';
        let openTradesSortOrder = 'desc'; // 'asc' or 'desc'
        let allTradesSortField = 'dateOpened';
        let allTradesSortOrder = 'desc';
        let allTradesFilter = 'all'; // 'all', 'open', 'closed', 'rolled'
        let groupsSortField = 'dateOpened';
        let groupsSortOrder = 'desc';
        let filteredTradesSortField = 'dateOpened';
        let filteredTradesSortOrder = 'desc';
        let expirationTradesSortField = 'dateOpened';
        let expirationTradesSortOrder = 'desc'; // Changed to match other tables
        
        // Symbol detail view state
        let currentSymbol = '';
        let symbolTradesFilter = 'all'; // 'all', 'open', 'closed', 'rolled'
        
        // Helper function to make symbol clickable
        function makeSymbolClickable(symbol, hasRolledBadge = false) {
            const rolledBadge = hasRolledBadge ? '<span class="rolled-badge">Rolled</span>' : '';
            return `<strong style="cursor: pointer; text-decoration: underline; color: #00ff88;" onclick="showSymbolDetail('${symbol}')">${symbol}</strong>${rolledBadge}`;
        }
        
        // Undo functionality
        let lastDeletedTrade = null;
        let lastDeletedFrom = null; // 'open', 'closed', or 'group'
        let lastDeletedGroupInfo = null; // Store group info if deleted from group

        // Load data from localStorage on page load
        window.onload = function() {
            checkAuth(); // Check authentication and show appropriate screen
            
            // Add event listener for symbol filter
            const symbolFilter = document.getElementById('allTradesSymbolFilter');
            if (symbolFilter) {
                symbolFilter.addEventListener('change', function() {
                    renderAllTrades();
                });
            }
            
            // Load theme preference
            loadTheme();
        };

        function loadTheme() {
            const savedTheme = localStorage.getItem('theme');
            
            if (savedTheme === 'light') {
                document.body.classList.add('light-mode');
            }
        }

        function setTodayDate() {
            const today = new Date().toISOString().split('T')[0];
            document.getElementById('dateOpened').value = today;
            document.getElementById('closeDate').value = today;
        }

        function openTradeModal() {
            document.getElementById('tradeModal').classList.add('active');
            setTodayDate();
        }

        function closeTradeModal() {
            document.getElementById('tradeModal').classList.remove('active');
        }

        function showImportOptions() {
            // Close settings menu
            document.getElementById('settingsMenu').classList.add('hidden');
            // Open import options modal
            document.getElementById('importOptionsModal').classList.add('active');
        }

        function closeImportOptionsModal() {
            document.getElementById('importOptionsModal').classList.remove('active');
        }

        function toggleSettingsMenu() {
            const menu = document.getElementById('settingsMenu');
            menu.classList.toggle('hidden');
        }

        // Close settings menu when clicking outside
        document.addEventListener('click', function(event) {
            const menu = document.getElementById('settingsMenu');
            const btn = document.getElementById('settingsMenuBtn');
            if (menu && btn && !menu.contains(event.target) && !btn.contains(event.target)) {
                menu.classList.add('hidden');
            }
            
            // Close win rate info modal when clicking outside
            const winRateModal = document.getElementById('winRateInfoModal');
            if (winRateModal && winRateModal.classList.contains('active') && event.target === winRateModal) {
                closeWinRateInfo();
            }
        });

        function switchTab(tabName) {
            currentTab = tabName;
            
            // Hide symbol detail view if open
            document.getElementById('symbolDetailTab').style.display = 'none';
            
            // Update tab buttons
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });
            event.target.classList.add('active');
            
            // Update content
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
                content.style.display = 'none';
            });
            const targetTab = document.getElementById(tabName + 'Tab');
            targetTab.classList.add('active');
            targetTab.style.display = 'block';
            
            // Render appropriate table
            if (tabName === 'all') {
                populateSymbolFilter();
                renderAllTrades();
            } else if (tabName === 'groups') {
                renderGroups();
            } else if (tabName === 'stock') {
                renderStockPositions();
            } else if (tabName === 'dashboard') {
                updateDashboardMetrics();
            }
        }

        function addTrade() {
            const tradeRef = document.getElementById('tradeRef').value.trim();
            const symbol = document.getElementById('symbol').value.toUpperCase().trim();
            const contracts = parseInt(document.getElementById('contracts').value) || 1;
            const strike = parseFloat(document.getElementById('strike').value) || 0;
            const premium = parseFloat(document.getElementById('premium').value) || 0;
            const action = document.getElementById('action').value;
            const type = document.getElementById('type').value;
            const dateOpened = document.getElementById('dateOpened').value;
            const expDate = document.getElementById('expDate').value;
            const priceAtAction = parseFloat(document.getElementById('priceAtAction').value) || 0;
            const info = document.getElementById('info').value;
            const account = document.getElementById('account').value;

            // Minimum validation - only require symbol
            if (!symbol) {
                alert('Please enter a symbol');
                return;
            }

            // Smart close detection: If BUY action with Trade Ref #, check for matching open SELL
            if (action === 'buy' && tradeRef && tradeRef.trim() !== '') {
                const matchingOpenTrade = trades.find(t => 
                    t.tradeRef === tradeRef &&
                    t.symbol === symbol &&
                    t.action === 'sell' &&
                    t.status === 'open' &&
                    (strike === 0 || t.strike === strike) // If strike is 0 (blank), match any strike
                );

                if (matchingOpenTrade) {
                    // This is a closing trade! Mark the original as closed and group them
                    console.log('Smart close detected! Closing trade:', matchingOpenTrade);
                    
                    matchingOpenTrade.status = 'closed';
                    matchingOpenTrade.dateClosed = dateOpened;
                    
                    // Create the closing trade - use the original trade's strike if BUY strike was blank
                    const closingTrade = {
                        id: Date.now() + Math.random(),
                        tradeRef: tradeRef,
                        account: account || matchingOpenTrade.account,
                        groupId: matchingOpenTrade.groupId,
                        symbol,
                        contracts: contracts || matchingOpenTrade.contracts,
                        strike: strike || matchingOpenTrade.strike, // Use original strike if blank
                        premium,
                        action: 'buy',
                        type: type || matchingOpenTrade.type, // Use original type if blank
                        dateOpened,
                        expDate,
                        priceAtAction,
                        info: info || 'Closing trade',
                        status: 'closed',
                        dateClosed: dateOpened,
                        isClosingTrade: true,
                        isRolled: matchingOpenTrade.isRolled || false // Inherit rolled status
                    };
                    
                    // Move both to closed trades
                    closedTrades.push(matchingOpenTrade);
                    closedTrades.push(closingTrade);
                    
                    // Remove from open trades
                    const index = trades.indexOf(matchingOpenTrade);
                    if (index > -1) {
                        trades.splice(index, 1);
                    }
                    
                    // Create or update group
                    let existingGroup = tradeGroups.find(g => 
                        g.name === `Trade Ref: ${tradeRef}` ||
                        (g.trades && g.trades.some(t => t.tradeRef === tradeRef))
                    );
                    
                    if (existingGroup) {
                        existingGroup.trades.push(matchingOpenTrade);
                        existingGroup.trades.push(closingTrade);
                    } else {
                        tradeGroups.push({
                            id: Date.now(),
                            name: `Trade Ref: ${tradeRef}`,
                            trades: [matchingOpenTrade, closingTrade],
                            created: new Date().toISOString()
                        });
                    }
                    
                    saveData();
                    renderTables();
                    updateStats();
                    updateLastRefDisplay();
                    clearForm();
                    closeTradeModal();
                    alert('Position closed and grouped automatically!');
                    return;
                }
            }

            // Regular trade (not a close)
            const trade = {
                id: Date.now() + Math.random(),
                tradeRef: tradeRef || '',
                account: account || '',
                groupId: `${symbol}-${strike}-${type}-${expDate}`,
                symbol,
                contracts,
                strike,
                premium,
                action,
                type,
                dateOpened,
                expDate,
                priceAtAction,
                info,
                status: 'open'
            };

            trades.push(trade);
            saveData();
            renderTables();
            updateStats();
            updateLastRefDisplay();
            clearForm();
            closeTradeModal();
        }

        function clearForm() {
            document.getElementById('tradeRef').value = '';
            document.getElementById('symbol').value = '';
            document.getElementById('contracts').value = '1';
            document.getElementById('strike').value = '';
            document.getElementById('premium').value = '';
            document.getElementById('priceAtAction').value = '';
            document.getElementById('info').value = '';
            document.getElementById('account').value = '';
            setTodayDate();
        }

        function addNewAccount() {
            console.log('addNewAccount called - opening modal');
            document.getElementById('newAccountName').value = '';
            document.getElementById('accountModal').classList.add('active');
        }

        function closeAccountModal() {
            document.getElementById('accountModal').classList.remove('active');
        }

        function saveNewAccount() {
            const accountName = document.getElementById('newAccountName').value.trim();
            console.log('Saving account:', accountName);
            
            if (!accountName) {
                alert('Please enter an account name');
                return;
            }
            
            if (customAccounts.includes(accountName)) {
                alert(`Account "${accountName}" already exists!`);
                return;
            }
            
            customAccounts.push(accountName);
            console.log('Added to customAccounts:', customAccounts);
            saveCustomAccounts();
            populateAccountDropdowns();
            document.getElementById('account').value = accountName;
            closeAccountModal();
            alert(`Account "${accountName}" added successfully!`);
        }

        function populateAccountDropdowns() {
            const dropdowns = ['account'];
            dropdowns.forEach(id => {
                const dropdown = document.getElementById(id);
                if (dropdown) {
                    const currentValue = dropdown.value;
                    dropdown.innerHTML = '<option value="">Select Account...</option>' +
                        '<option value="Main">Main</option>' +
                        '<option value="IRA">IRA</option>' +
                        '<option value="Roth IRA">Roth IRA</option>' +
                        customAccounts.map(acc => `<option value="${acc}">${acc}</option>`).join('');
                    dropdown.value = currentValue;
                }
            });
        }

        function saveCustomAccounts() {
            if (currentUser) {
                localStorage.setItem(getUserStorageKey('customAccounts'), JSON.stringify(customAccounts));
            } else {
                localStorage.setItem('customAccounts', JSON.stringify(customAccounts));
            }
        }

        function loadCustomAccounts() {
            const key = currentUser ? getUserStorageKey('customAccounts') : 'customAccounts';
            const saved = localStorage.getItem(key);
            if (saved) {
                try {
                    customAccounts = JSON.parse(saved);
                    if (!Array.isArray(customAccounts)) customAccounts = [];
                } catch (e) {
                    customAccounts = [];
                }
            }
            populateAccountDropdowns();
        }

        function calculateCashRequired(trade) {
            // Skip assignment and called-away trades
            if (trade.isAssignment || trade.isCalledAway) {
                return 0;
            }
            
            if (trade.type === 'put' && trade.action === 'sell') {
                return trade.strike * trade.contracts * 100;
            }
            
            // Covered calls: cash required = strike * contracts * 100
            if (trade.type === 'call' && trade.action === 'sell' && trade.isCoveredCall) {
                return trade.strike * trade.contracts * 100;
            }
            
            return 0;
        }

        function calculateReturnPercent(trade) {
            // Skip assignment and called-away trades for return calculation
            if (trade.isAssignment || trade.isCalledAway) {
                return "0.00";
            }
            
            const cashRequired = calculateCashRequired(trade);
            const totalPremium = trade.premium * trade.contracts * 100;
            
            // For BUY actions, this is a cost (negative return)
            const multiplier = trade.action === 'buy' ? -1 : 1;
            
            if (cashRequired === 0) {
                const stockValue = trade.strike * trade.contracts * 100;
                return ((multiplier * totalPremium / stockValue) * 100).toFixed(2);
            }
            
            return ((multiplier * totalPremium / cashRequired) * 100).toFixed(2);
        }

        function calculateOTM(trade) {
            // Skip assignment and called-away trades for OTM calculation
            if (trade.isAssignment || trade.isCalledAway) {
                return "0.00";
            }
            
            if (trade.type === 'put') {
                const diff = ((trade.priceAtAction - trade.strike) / trade.strike * 100);
                return diff.toFixed(2);
            } else {
                const diff = ((trade.strike - trade.priceAtAction) / trade.priceAtAction * 100);
                return diff.toFixed(2);
            }
        }

        function calculatePL(trade, forDisplay = false) {
            // Handle special stock trades (assignment, called-away)
            if (trade.isAssignment) {
                return 0; // Assignment itself has no P&L (tracked in put premium)
            }
            
            if (trade.isCalledAway && trade.cycleDetails) {
                return trade.cycleDetails.stockProfit; // Return ONLY stock profit for this row
            }
            
            const premiumCollected = trade.premium * trade.contracts * 100;
            
            // For DISPLAY purposes (showing in tables), each roll leg shows its own P&L
            if (forDisplay && (trade.isRolled || trade.isClosingTrade)) {
                if (trade.action === 'sell') {
                    return premiumCollected; // SELL = credit (positive)
                } else {
                    return -premiumCollected; // BUY = debit (negative)
                }
            }
            
            // For non-rolled trades OR when calculating totals, use the original logic
            let closingCost = (trade.closingPremium || trade.closePrice || 0) * trade.contracts * 100;
            
            // For closed SELL trades without a closePrice, try to find the matching BUY trade
            if (trade.action === 'sell' && trade.status === 'closed' && closingCost === 0 && trade.tradeRef) {
                // Find the BUY trade with isClosingTrade that matches this trade
                const buybackTrade = closedTrades.find(t => 
                    t.isClosingTrade === true &&
                    t.action === 'buy' &&
                    t.tradeRef === trade.tradeRef &&
                    t.symbol === trade.symbol &&
                    Math.abs(new Date(t.dateOpened || t.dateClosed) - new Date(trade.dateClosed || trade.dateOpened)) < 86400000 // Within 1 day
                );
                
                if (buybackTrade) {
                    closingCost = buybackTrade.premium * buybackTrade.contracts * 100;
                }
            }
            
            if (trade.action === 'sell') {
                // For closed positions, calculate actual P&L
                if (trade.status === 'closed') {
                    return premiumCollected - closingCost;
                }
                
                // For open positions, show premium collected
                return premiumCollected;
            } else {
                // For BUY positions, premium paid is a cost
                return -premiumCollected;
            }
        }

        function calculateRollCredit(trade) {
            // Credit only applies to SELL trades that are rolled
            if (!trade.isRolled || !trade.tradeRef || trade.action !== 'sell') {
                return null;
            }
            
            // Find all buybacks for this tradeRef
            const buybackTrades = closedTrades
                .filter(t => 
                    t.tradeRef === trade.tradeRef && 
                    t.action === 'buy' && 
                    t.isClosingTrade === true
                )
                .sort((a, b) => new Date(a.dateClosed || a.dateOpened) - new Date(b.dateClosed || b.dateOpened));
            
            if (buybackTrades.length === 0) {
                return null;
            }
            
            // Find the buyback that happened on or just after this SELL's opening date
            // If this SELL's dateOpened is the same as a buyback's dateClosed, this is the NEW sell (show credit)
            // If this SELL's dateOpened is earlier than all buybacks, this is the ORIGINAL (no credit)
            
            const buybackOnSameDate = buybackTrades.find(buy => {
                const buyDate = new Date(buy.dateClosed || buy.dateOpened).toDateString();
                const sellDate = new Date(trade.dateOpened).toDateString();
                return buyDate === sellDate;
            });
            
            if (buybackOnSameDate) {
                // This SELL opened on the same day as a buyback = it's the NEW sell after a roll
                // Calculate credit: this sell premium - buyback cost
                const newPremium = trade.premium * trade.contracts * 100;
                const buybackCost = buybackOnSameDate.premium * buybackOnSameDate.contracts * 100;
                const credit = newPremium - buybackCost;
                return credit;
            }
            
            // This SELL opened before any buybacks = it's the ORIGINAL sell (no credit)
            return null;
        }

        function renderTables() {
            renderOpenTrades();
            populateSymbolFilter();
            if (currentTab === 'groups') {
                renderGroups();
            } else if (currentTab === 'all') {
                renderAllTrades();
            }
        }

        function sortFilteredTrades(field, order) {
            filteredTradesSortField = field;
            filteredTradesSortOrder = order;
            filterByStock(); // Re-render with new sort
        }

        function sortExpirationTrades(field, order) {
            expirationTradesSortField = field;
            expirationTradesSortOrder = order;
            renderTradesByExpiration(); // Re-render with new sort
        }

        function sortOpenTrades(field, order) {
            openTradesSortField = field;
            openTradesSortOrder = order;
            renderOpenTrades();
        }

        // Universal Table Sorting System
        const tableSortState = {
            open: { column: null, direction: null },
            openByStock: { column: null, direction: null },
            all: { column: null, direction: null },
            stock: { column: null, direction: null },
            groups: { column: null, direction: null },
            symbolDetail: { column: null, direction: null }
        };

        function sortTable(table, column, type) {
            const state = tableSortState[table];
            
            // Toggle direction
            if (state.column === column) {
                state.direction = state.direction === 'asc' ? 'desc' : 'asc';
            } else {
                state.column = column;
                state.direction = 'asc';
            }
            
            // Update header indicators
            let tableElement;
            if (table === 'symbolDetail') {
                tableElement = document.querySelector('#symbolDetailTab table');
            } else if (table === 'all') {
                tableElement = document.querySelector('#allTab table');
            } else if (table === 'open') {
                tableElement = document.querySelector('#openTab table');
            } else if (table === 'openByStock') {
                tableElement = document.querySelector('#filteredTradesTableBody')?.closest('table');
            } else if (table === 'stock') {
                tableElement = document.querySelector('#stockTab table');
            }
            
            if (tableElement) {
                // Remove all sort classes
                tableElement.querySelectorAll('th.sortable').forEach(th => {
                    th.classList.remove('sort-asc', 'sort-desc');
                });
                
                // Add sort class to active column
                const headers = Array.from(tableElement.querySelectorAll('th.sortable'));
                const activeHeader = headers.find(th => {
                    const onclick = th.getAttribute('onclick');
                    return onclick && onclick.includes(`'${column}'`);
                });
                if (activeHeader) {
                    activeHeader.classList.add(`sort-${state.direction}`);
                }
            }
            
            // Sort and re-render
            if (table === 'open') {
                sortAndRenderOpen(column, type, state.direction);
            } else if (table === 'openByStock') {
                sortAndRenderOpenByStock(column, type, state.direction);
            } else if (table === 'all') {
                sortAndRenderAll(column, type, state.direction);
            } else if (table === 'stock') {
                sortAndRenderStock(column, type, state.direction);
            } else if (table === 'symbolDetail') {
                sortAndRenderSymbolDetail(column, type, state.direction);
            }
        }

        function compareValues(a, b, type, direction) {
            let aVal = a;
            let bVal = b;
            
            // Handle null/undefined
            if (aVal == null) aVal = type === 'number' ? -Infinity : '';
            if (bVal == null) bVal = type === 'number' ? -Infinity : '';
            
            let comparison = 0;
            
            if (type === 'number') {
                comparison = parseFloat(aVal) - parseFloat(bVal);
            } else if (type === 'date') {
                comparison = new Date(aVal) - new Date(bVal);
            } else { // text
                comparison = String(aVal).localeCompare(String(bVal));
            }
            
            return direction === 'asc' ? comparison : -comparison;
        }

        function sortAndRenderOpen(column, type, direction) {
            // Sort trades array
            trades.sort((a, b) => {
                let aVal, bVal;
                
                // Special handling for calculated fields
                if (column === 'cashRequired') {
                    aVal = calculateCashRequired(a);
                    bVal = calculateCashRequired(b);
                } else if (column === 'percentReturn') {
                    aVal = calculatePercentReturn(a);
                    bVal = calculatePercentReturn(b);
                } else if (column === 'percentOTM') {
                    aVal = calculatePercentOTM(a);
                    bVal = calculatePercentOTM(b);
                } else if (column === 'pl') {
                    aVal = calculatePL(a);
                    bVal = calculatePL(b);
                } else {
                    aVal = a[column];
                    bVal = b[column];
                }
                
                return compareValues(aVal, bVal, type, direction);
            });
            
            renderOpenTrades();
        }

        function sortAndRenderOpenByStock(column, type, direction) {
            // Get current stock filter
            const selectedStock = document.getElementById('stockFilter')?.value;
            
            if (!selectedStock) {
                // No stock selected, can't sort
                return;
            }
            
            // Filter trades by selected stock
            let filteredTrades = trades.filter(t => t.symbol === selectedStock);
            
            // Sort the filtered trades
            filteredTrades.sort((a, b) => {
                let aVal, bVal;
                
                if (column === 'cashRequired') {
                    aVal = calculateCashRequired(a);
                    bVal = calculateCashRequired(b);
                } else if (column === 'percentReturn') {
                    aVal = calculatePercentReturn(a);
                    bVal = calculatePercentReturn(b);
                } else if (column === 'percentOTM') {
                    aVal = calculatePercentOTM(a);
                    bVal = calculatePercentOTM(b);
                } else if (column === 'pl') {
                    aVal = calculatePL(a);
                    bVal = calculatePL(b);
                } else if (column === 'credit') {
                    aVal = a.isRolled ? (calculateRollCredit(a) || 0) : 0;
                    bVal = b.isRolled ? (calculateRollCredit(b) || 0) : 0;
                } else {
                    aVal = a[column];
                    bVal = b[column];
                }
                
                return compareValues(aVal, bVal, type, direction);
            });
            
            // Store sorted trades
            window.sortedOpenByStock = filteredTrades;
            
            // Re-render by calling filterByStock which will use the sorted array
            filterByStock();
        }

        function sortAndRenderAll(column, type, direction) {
            // Get current filter state
            const currentFilter = window.allTradesFilter || 'all';
            const symbolFilter = document.getElementById('allTradesSymbolFilter')?.value || '';
            
            // Build combined array for sorting
            let allTrades = [];
            
            // Add open trades with isOpen flag
            trades.forEach(t => {
                allTrades.push({...t, isOpen: true, status: 'open'});
            });
            
            // Add closed trades
            closedTrades.filter(t => !t.isClosingTrade).forEach(t => {
                allTrades.push({...t, isOpen: false, status: t.status || 'closed'});
            });
            
            // Sort the combined array
            allTrades.sort((a, b) => {
                let aVal, bVal;
                
                // Special handling for calculated fields
                if (column === 'cashRequired') {
                    aVal = a.isOpen ? calculateCashRequired(a) : 0;
                    bVal = b.isOpen ? calculateCashRequired(b) : 0;
                } else if (column === 'percentReturn') {
                    aVal = calculatePercentReturn(a);
                    bVal = calculatePercentReturn(b);
                } else if (column === 'pl') {
                    aVal = calculatePL(a);
                    bVal = calculatePL(b);
                } else if (column === 'credit') {
                    aVal = a.isOpen && a.isRolled ? (calculateRollCredit(a) || 0) : 0;
                    bVal = b.isOpen && b.isRolled ? (calculateRollCredit(b) || 0) : 0;
                } else {
                    aVal = a[column];
                    bVal = b[column];
                }
                
                return compareValues(aVal, bVal, type, direction);
            });
            
            // Store sorted order (we'll need to update renderAllTrades to use this)
            window.sortedAllTrades = allTrades;
            
            renderAllTrades();
        }

        function sortAndRenderSymbolDetail(column, type, direction) {
            // Get current symbol
            const currentSymbol = window.currentDetailSymbol;
            if (!currentSymbol) {
                return;
            }
            
            // Get current filter
            const currentFilter = window.symbolTradesFilter || 'all';
            
            // Build array to sort
            let symbolTrades = [];
            
            trades.filter(t => t.symbol === currentSymbol).forEach(t => {
                symbolTrades.push({...t, isOpen: true, status: 'open'});
            });
            
            closedTrades.filter(t => t.symbol === currentSymbol && !t.isClosingTrade).forEach(t => {
                symbolTrades.push({...t, isOpen: false, status: t.status || 'closed'});
            });
            
            // Sort
            symbolTrades.sort((a, b) => {
                let aVal, bVal;
                
                if (column === 'cashRequired') {
                    aVal = a.isOpen ? calculateCashRequired(a) : 0;
                    bVal = b.isOpen ? calculateCashRequired(b) : 0;
                } else if (column === 'percentReturn') {
                    aVal = calculatePercentReturn(a);
                    bVal = calculatePercentReturn(b);
                } else if (column === 'pl') {
                    aVal = calculatePL(a);
                    bVal = calculatePL(b);
                } else {
                    aVal = a[column];
                    bVal = b[column];
                }
                
                return compareValues(aVal, bVal, type, direction);
            });
            
            // Store sorted order
            window.sortedSymbolTrades = symbolTrades;
            
            // Re-render symbol detail
            showSymbolDetail(currentSymbol);
        }

        function sortAndRenderStock(column, type, direction) {
            // Sort stockPositions array
            stockPositions.sort((a, b) => {
                return compareValues(a[column], b[column], type, direction);
            });
            
            renderStockPositions();
        }

        function renderOpenTrades() {
            const tbody = document.getElementById('openTradesTableBody');
            if (!tbody) {
                console.error('openTradesTableBody not found');
                return;
            }
            
            if (trades.length === 0) {
                tbody.innerHTML = `
                    <tr>
                        <td colspan="15" style="text-align: center; color: #666; padding: 40px;">
                            No open positions. Add your first trade above.
                        </td>
                    </tr>
                `;
                
                // Clear stock filter dropdown
                const stockFilter = document.getElementById('stockFilter');
                if (stockFilter) {
                    stockFilter.innerHTML = '<option value="">Select a stock...</option>';
                }
                
                // Clear filtered table
                const filteredTbody = document.getElementById('filteredTradesTableBody');
                if (filteredTbody) {
                    filteredTbody.innerHTML = `
                        <tr>
                            <td colspan="15" style="text-align: center; color: #666; padding: 40px;">
                                No open positions available.
                            </td>
                        </tr>
                    `;
                }
                return;
            }

            // Sort by the selected field and order
            const sortedTrades = [...trades].sort((a, b) => {
                const aDate = new Date(a[openTradesSortField]);
                const bDate = new Date(b[openTradesSortField]);
                if (openTradesSortOrder === 'asc') {
                    return aDate - bDate;
                } else {
                    return bDate - aDate;
                }
            });

            tbody.innerHTML = sortedTrades.map((trade) => {
                const actualIndex = trades.indexOf(trade);
                const cashRequired = calculateCashRequired(trade);
                const returnPercent = calculateReturnPercent(trade);
                const otm = calculateOTM(trade);
                const pl = calculatePL(trade, true);

                return `
                    <tr>
                        <td>${makeSymbolClickable(trade.symbol, trade.isRolled)}</td>
                        <td>${trade.contracts}</td>
                        <td>$${trade.strike.toFixed(2)}</td>
                        <td>$${trade.premium.toFixed(2)}</td>
                        <td><span class="action-badge ${trade.action}">${trade.action.toUpperCase()}</span></td>
                        <td><span class="type-badge ${trade.type}">${trade.type.toUpperCase()}</span></td>
                        <td>${formatDate(trade.dateOpened)}</td>
                        <td>${formatDate(trade.expDate)}</td>
                        <td>${cashRequired > 0 ? '$' + cashRequired.toLocaleString() : '-'}</td>
                        <td class="${parseFloat(returnPercent) >= 0 ? 'positive-value' : 'negative-value'}">${returnPercent}%</td>
                        <td>$${(trade.priceAtAction || 0).toFixed(2)}</td>
                        <td class="${parseFloat(otm) >= 0 ? 'positive-value' : 'negative-value'}">${otm}%</td>
                        <td class="${pl >= 0 ? 'positive-value' : 'negative-value'}">$${formatCurrency(pl)}</td>
                        <td style="max-width: 150px; overflow: hidden; text-overflow: ellipsis;">${trade.info || '-'}</td>
                        <td style="color: #00ff88;"><strong>${trade.tradeRef || '-'}</strong></td>
                        <td>${trade.account || '-'}</td>
                        <td>
                            <div class="action-buttons">
                                <button class="btn-small" onclick="editTrade(${actualIndex})">Edit</button>
                                <button class="btn-small" style="background: #4488ff; color: #fff;" onclick="openRollModal(${actualIndex})">Roll</button>
                                <button class="btn-small success" onclick="openCloseModal(${actualIndex})">Close</button>
                                ${trade.type === 'put' && trade.action === 'sell' ? `
                                    <button class="btn-small" style="background: #ff8844; color: #000;" onclick="assignStock(${actualIndex})">Assign</button>
                                ` : ''}
                                ${trade.type === 'call' && trade.action === 'sell' ? `
                                    <button class="btn-small" style="background: #ff4488; color: #fff;" onclick="openCalledOutModal(${actualIndex})">Called Out</button>
                                ` : ''}
                                <button class="btn-small danger" onclick="deleteTrade(${actualIndex})">Delete</button>
                            </div>
                        </td>
                    </tr>
                `;
            }).join('');
            
            // Add stock positions to the table
            const stockRows = stockPositions.map((stock, index) => {
                const callsCount = stock.coveredCalls.length;
                const totalCallPremiums = stock.coveredCalls.reduce((sum, call) => sum + call.premium, 0);
                const runningPL = stock.originalPut.premiumCollected + totalCallPremiums;
                
                return `
                    <tr style="background: #1a1a2a; border-left: 3px solid #ff8844;">
                        <td>${makeSymbolClickable(stock.symbol, false)}<br><span style="font-size: 0.8rem; color: #ff8844;">STOCK</span></td>
                        <td><strong>${stock.shares / 100}</strong><br><span style="font-size: 0.8rem;">(${stock.shares} shares)</span></td>
                        <td>$${stock.costBasis.toFixed(2)}</td>
                        <td><span style="color: #00ff88;">+$${formatCurrency(stock.originalPut.premiumCollected)}</span></td>
                        <td colspan="2"><span style="background: #ff8844; color: #000; padding: 2px 8px; border-radius: 4px; font-weight: bold;">ASSIGNED</span></td>
                        <td>${formatDate(stock.assignedDate)}</td>
                        <td>-</td>
                        <td>$${stock.totalCost.toLocaleString()}</td>
                        <td colspan="2">${callsCount} call${callsCount !== 1 ? 's' : ''}</td>
                        <td class="${runningPL >= 0 ? 'positive-value' : 'negative-value'}"><strong>${runningPL >= 0 ? '+' : ''}$${formatCurrency(runningPL)}</strong></td>
                        <td>Running P&L</td>
                        <td style="color: #00ff88;"><strong>${stock.tradeRef || '-'}</strong></td>
                        <td>${stock.account || '-'}</td>
                        <td>
                            <div class="action-buttons">
                                <button class="btn-small" style="background: #00ff88; color: #000;" onclick="calledAway(${index})">Called Away</button>
                                <button class="btn-small danger" onclick="deleteStockPosition(${index})">Delete</button>
                            </div>
                        </td>
                    </tr>
                `;
            }).join('');
            
            tbody.innerHTML = tbody.innerHTML + stockRows;
            
            // Populate stock filter dropdown
            populateStockFilter();
            
            // Also render by expiration
            renderTradesByExpiration();
        }

        function populateStockFilter() {
            const stockFilter = document.getElementById('stockFilter');
            if (!stockFilter) return;
            
            // Get unique symbols from open trades
            const symbols = [...new Set(trades.map(t => t.symbol))].sort();
            
            stockFilter.innerHTML = '<option value="">Select a stock...</option>' + 
                symbols.map(symbol => `<option value="${symbol}">${symbol}</option>`).join('');
        }

        function calculateDaysToExpiration(expDate) {
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            const exp = new Date(expDate + 'T00:00:00');
            const diffTime = exp - today;
            const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
            return diffDays;
        }

        function renderTradesByExpiration() {
            const tbody = document.getElementById('expirationTradesTableBody');
            if (!tbody) return;

            if (trades.length === 0) {
                tbody.innerHTML = `
                    <tr>
                        <td colspan="18" style="text-align: center; color: #666; padding: 40px;">
                            No open positions.
                        </td>
                    </tr>
                `;
                return;
            }

            // Sort by the selected field and order
            const sortedTrades = [...trades].sort((a, b) => {
                const aDate = new Date(a[expirationTradesSortField]);
                const bDate = new Date(b[expirationTradesSortField]);
                if (expirationTradesSortOrder === 'asc') {
                    return aDate - bDate;
                } else {
                    return bDate - aDate;
                }
            });

            tbody.innerHTML = sortedTrades.map((trade) => {
                const actualIndex = trades.indexOf(trade);
                const cashRequired = calculateCashRequired(trade);
                const returnPercent = calculateReturnPercent(trade);
                const otm = calculateOTM(trade);
                const pl = calculatePL(trade, true);
                const daysToExp = calculateDaysToExpiration(trade.expDate);
                
                // Color code days to expiration
                let daysColor = '#00ff88'; // green (11+ days)
                if (daysToExp <= 7) {
                    daysColor = '#ff4444'; // red (7 days or less)
                } else if (daysToExp >= 8 && daysToExp <= 10) {
                    daysColor = '#888888'; // grey (8-10 days)
                }

                return `
                    <tr>
                        <td>${makeSymbolClickable(trade.symbol, trade.isRolled)}</td>
                        <td>${trade.contracts}</td>
                        <td>$${trade.strike.toFixed(2)}</td>
                        <td>$${trade.premium.toFixed(2)}</td>
                        <td><span class="action-badge ${trade.action}">${trade.action.toUpperCase()}</span></td>
                        <td><span class="type-badge ${trade.type}">${trade.type.toUpperCase()}</span></td>
                        <td>${formatDate(trade.dateOpened)}</td>
                        <td>${formatDate(trade.expDate)}</td>
                        <td style="color: ${daysColor}; font-weight: bold; font-size: 1.1rem;">${daysToExp}</td>
                        <td>${cashRequired > 0 ? '$' + cashRequired.toLocaleString() : '-'}</td>
                        <td class="${parseFloat(returnPercent) >= 0 ? 'positive-value' : 'negative-value'}">${returnPercent}%</td>
                        <td>$${(trade.priceAtAction || 0).toFixed(2)}</td>
                        <td class="${parseFloat(otm) >= 0 ? 'positive-value' : 'negative-value'}">${otm}%</td>
                        <td class="${pl >= 0 ? 'positive-value' : 'negative-value'}">$${formatCurrency(pl)}</td>
                        <td style="max-width: 150px; overflow: hidden; text-overflow: ellipsis;">${trade.info || '-'}</td>
                        <td style="color: #00ff88;"><strong>${trade.tradeRef || '-'}</strong></td>
                        <td>${trade.account || '-'}</td>
                        <td>
                            <div class="action-buttons">
                                <button class="btn-small" onclick="editTrade(${actualIndex})">Edit</button>
                                <button class="btn-small" style="background: #4488ff; color: #fff;" onclick="openRollModal(${actualIndex})">Roll</button>
                                <button class="btn-small success" onclick="openCloseModal(${actualIndex})">Close</button>
                                ${trade.type === 'put' && trade.action === 'sell' ? `
                                    <button class="btn-small" style="background: #ff8844; color: #000;" onclick="assignStock(${actualIndex})">Assign</button>
                                ` : ''}
                                <button class="btn-small danger" onclick="deleteTrade(${actualIndex})">Delete</button>
                            </div>
                        </td>
                    </tr>
                `;
            }).join('');
        }

        function filterByStock() {
            const stockFilter = document.getElementById('stockFilter');
            const selectedSymbol = stockFilter.value;
            const filteredTbody = document.getElementById('filteredTradesTableBody');
            
            if (!filteredTbody) return;
            
            if (!selectedSymbol) {
                filteredTbody.innerHTML = `
                    <tr>
                        <td colspan="18" style="text-align: center; color: #666; padding: 40px;">
                            Select a stock from the dropdown above to view positions.
                        </td>
                    </tr>
                `;
                return;
            }
            
            // Check if we have a sorted array to use
            let filteredTrades;
            if (window.sortedOpenByStock && window.sortedOpenByStock.length > 0 && 
                window.sortedOpenByStock[0].symbol === selectedSymbol) {
                // Use pre-sorted array
                filteredTrades = window.sortedOpenByStock;
            } else {
                // Filter trades by selected symbol
                filteredTrades = trades.filter(t => t.symbol === selectedSymbol);
                // Clear sorted array since we're using a new filter
                window.sortedOpenByStock = null;
            }
            
            if (filteredTrades.length === 0) {
                filteredTbody.innerHTML = `
                    <tr>
                        <td colspan="18" style="text-align: center; color: #666; padding: 40px;">
                            No positions found for ${selectedSymbol}.
                        </td>
                    </tr>
                `;
                return;
            }
            
            // Calculate totals for this symbol
            let symbolCollateral = 0;
            let symbolPL = 0;
            let html = '';
            
            filteredTrades.forEach((trade, index) => {
                const actualIndex = trades.indexOf(trade);
                const cashRequired = calculateCashRequired(trade);
                const returnPercent = calculateReturnPercent(trade);
                const otm = calculateOTM(trade);
                const pl = calculatePL(trade, true);
                const rollCredit = calculateRollCredit(trade);
                
                symbolCollateral += cashRequired;
                // Don't add pl here yet - we'll calculate total P&L including roll history below

                // Current open position row
                html += `
                    <tr style="background: #0a0a0a;">
                        <td>${makeSymbolClickable(trade.symbol, trade.isRolled)}</td>
                        <td>${trade.contracts}</td>
                        <td>$${trade.strike.toFixed(2)}</td>
                        <td>$${trade.premium.toFixed(2)}</td>
                        <td><span class="action-badge ${trade.action}">${trade.action.toUpperCase()}</span></td>
                        <td><span class="type-badge ${trade.type}">${trade.type.toUpperCase()}</span></td>
                        <td>${formatDate(trade.dateOpened)}</td>
                        <td>${formatDate(trade.expDate)}</td>
                        <td>${cashRequired > 0 ? '$' + cashRequired.toLocaleString() : '-'}</td>
                        <td class="${parseFloat(returnPercent) >= 0 ? 'positive-value' : 'negative-value'}">${returnPercent}%</td>
                        <td>$${(trade.priceAtAction || 0).toFixed(2)}</td>
                        <td class="${parseFloat(otm) >= 0 ? 'positive-value' : 'negative-value'}">${otm}%</td>
                        <td class="${pl >= 0 ? 'positive-value' : 'negative-value'}">$${formatCurrency(pl)}</td>
                        <td class="${rollCredit !== null ? (rollCredit >= 0 ? 'positive-value' : 'negative-value') : ''}">${rollCredit !== null ? '$' + formatCurrency(rollCredit) : '-'}</td>
                        <td style="max-width: 150px; overflow: hidden; text-overflow: ellipsis;">${trade.info || '-'}</td>
                        <td style="color: #00ff88;"><strong>${trade.tradeRef || '-'}</strong></td>
                        <td>${trade.account || '-'}</td>
                        <td>
                            <div class="action-buttons">
                                <button class="btn-small" onclick="editTrade(${actualIndex})">Edit</button>
                                <button class="btn-small" style="background: #4488ff; color: #fff;" onclick="openRollModal(${actualIndex})">Roll</button>
                                <button class="btn-small success" onclick="openCloseModal(${actualIndex})">Close</button>
                                ${trade.type === 'put' && trade.action === 'sell' ? `
                                    <button class="btn-small" style="background: #ff8844; color: #000;" onclick="assignStock(${actualIndex})">Assign</button>
                                ` : ''}
                                <button class="btn-small danger" onclick="deleteTrade(${actualIndex})">Delete</button>
                            </div>
                        </td>
                    </tr>
                `;
                
                // Find roll history for this position
                const rollHistory = findRollHistory(trade);
                
                console.log('Roll history for', trade.symbol, trade.strike, ':', rollHistory.length, 'trades');
                
                if (rollHistory.length > 0) {
                    // Calculate cumulative P&L for this roll chain
                    let rollPL = 0;
                    
                    // Add current open position premium (if sold)
                    if (trade.action === 'sell') {
                        rollPL += trade.premium * trade.contracts * 100;
                        console.log('Current position premium:', trade.premium * trade.contracts * 100);
                    }
                    
                    // Calculate P&L from all history trades
                    rollHistory.forEach(histTrade => {
                        const amount = histTrade.premium * histTrade.contracts * 100;
                        if (histTrade.action === 'sell') {
                            rollPL += amount;
                            console.log('History SELL:', amount);
                        } else {
                            rollPL -= amount;
                            console.log('History BUY:', -amount);
                        }
                    });
                    
                    console.log('Total Roll P/L:', rollPL);
                    
                    // Add the rollPL to the symbol total
                    symbolPL += rollPL;
                    
                    html += `
                        <tr style="background: #1a1a1a; border-top: 1px solid #444; border-bottom: 1px solid #444;">
                            <td colspan="12" style="padding: 12px 15px;">
                                <strong style="color: #888;">Roll History</strong>
                            </td>
                            <td colspan="5" style="padding: 12px 15px; text-align: right;">
                                <strong style="color: #fff;">Current Roll P/L: </strong>
                                <strong class="${rollPL >= 0 ? 'positive-value' : 'negative-value'}" style="font-size: 1.1rem;">
                                    ${rollPL >= 0 ? '+' : ''}$${formatCurrency(rollPL)}
                                </strong>
                            </td>
                        </tr>
                    `;
                    
                    rollHistory.forEach(historyTrade => {
                        const histCashRequired = calculateCashRequired(historyTrade);
                        const histReturnPercent = calculateReturnPercent(historyTrade);
                        const histOtm = calculateOTM(historyTrade);
                        const histPl = calculatePL(historyTrade);
                        
                        html += `
                            <tr style="background: #050505; opacity: 0.7;">
                                <td style="padding-left: 30px;">${historyTrade.symbol}</td>
                                <td>${historyTrade.contracts}</td>
                                <td>$${historyTrade.strike.toFixed(2)}</td>
                                <td>$${historyTrade.premium.toFixed(2)}</td>
                                <td><span class="action-badge ${historyTrade.action}">${historyTrade.action.toUpperCase()}</span></td>
                                <td><span class="type-badge ${historyTrade.type}">${historyTrade.type.toUpperCase()}</span></td>
                                <td>${formatDate(historyTrade.dateOpened)}</td>
                                <td>${formatDate(historyTrade.expDate)}</td>
                                <td>${histCashRequired > 0 ? '$' + histCashRequired.toLocaleString() : '-'}</td>
                                <td class="${parseFloat(histReturnPercent) >= 0 ? 'positive-value' : 'negative-value'}">${histReturnPercent}%</td>
                                <td>$${historyTrade.priceAtAction.toFixed(2)}</td>
                                <td class="${parseFloat(histOtm) >= 0 ? 'positive-value' : 'negative-value'}">${histOtm}%</td>
                                <td class="${histPl >= 0 ? 'positive-value' : 'negative-value'}">$${formatCurrency(histPl)}</td>
                                <td style="max-width: 150px; overflow: hidden; text-overflow: ellipsis;">${historyTrade.info || '-'}</td>
                                <td style="color: #00ff88;"><strong>${historyTrade.tradeRef || '-'}</strong></td>
                                <td>${historyTrade.account || '-'}</td>
                                <td style="color: #666;">ROLLED</td>
                            </tr>
                        `;
                    });
                } else {
                    // No roll history - just add the current trade's P&L
                    symbolPL += pl;
                }
                
                // Add spacing between different positions
                html += `<tr style="height: 20px; background: #000;"><td colspan="18"></td></tr>`;
            });
            
            // Add totals row
            html += `
                <tr style="background: #0a0a0a; font-weight: bold; border-top: 2px solid #fff;">
                    <td colspan="8" style="text-align: right; padding: 15px;"><strong>${selectedSymbol} Totals:</strong></td>
                    <td>$${symbolCollateral.toLocaleString()}</td>
                    <td>-</td>
                    <td>-</td>
                    <td>-</td>
                    <td class="${symbolPL >= 0 ? 'positive-value' : 'negative-value'}">$${formatCurrency(symbolPL)}</td>
                    <td colspan="5">-</td>
                </tr>
            `;
            
            filteredTbody.innerHTML = html;
        }

        function findRollHistory(currentTrade) {
            const history = [];
            const processedGroups = new Set();
            
            console.log('Finding roll history for:', currentTrade.symbol, currentTrade.strike, currentTrade.dateOpened);
            
            // Function to recursively find all related roll groups
            function findRelatedGroups(symbol) {
                tradeGroups.forEach(group => {
                    if (processedGroups.has(group.id)) return;
                    if (!group.trades || !Array.isArray(group.trades)) return;
                    
                    // Check if this group contains the symbol and is a roll group
                    const hasMatchingSymbol = group.trades.some(t => t.symbol === symbol);
                    const isRollGroup = group.name.includes('Roll') || 
                                       group.trades.some(t => t.info && (t.info.includes('Roll') || t.info.includes('roll')));
                    
                    if (hasMatchingSymbol && isRollGroup) {
                        console.log('Found roll group:', group.name);
                        processedGroups.add(group.id);
                        
                        // Add all trades from this group except the current open one
                        group.trades.forEach(t => {
                            // Don't add the exact current trade
                            const isCurrent = t.symbol === currentTrade.symbol && 
                                            t.strike === currentTrade.strike && 
                                            t.dateOpened === currentTrade.dateOpened &&
                                            t.expDate === currentTrade.expDate &&
                                            t.premium === currentTrade.premium &&
                                            t.status === 'open';
                            
                            if (!isCurrent) {
                                // Check if this trade isn't already in history
                                const alreadyAdded = history.some(h => 
                                    h.symbol === t.symbol &&
                                    h.strike === t.strike &&
                                    h.dateOpened === t.dateOpened &&
                                    h.premium === t.premium &&
                                    h.action === t.action
                                );
                                
                                if (!alreadyAdded) {
                                    console.log('Adding to history:', t.symbol, t.strike, t.action, t.premium, t.dateOpened);
                                    history.push(t);
                                }
                            }
                        });
                    }
                });
            }
            
            // Find all related roll groups for this symbol
            findRelatedGroups(currentTrade.symbol);
            
            console.log('Total history trades found:', history.length);
            
            // Sort by date (oldest first)
            history.sort((a, b) => new Date(a.dateOpened) - new Date(b.dateOpened));
            
            return history;
        }

        function renderClosedTrades() {
            const tbody = document.getElementById('closedTradesTableBody');
            if (!tbody) return; // Exit if element doesn't exist yet
            
            if (closedTrades.length === 0) {
                tbody.innerHTML = `
                    <tr>
                        <td colspan="14" style="text-align: center; color: #666; padding: 40px;">
                            No closed positions yet.
                        </td>
                    </tr>
                `;
                return;
            }

            tbody.innerHTML = closedTrades.map((trade, index) => {
                const cashRequired = calculateCashRequired(trade);
                const returnPercent = calculateReturnPercent(trade);
                const pl = calculatePL(trade, true);

                return `
                    <tr>
                        <td><strong>${trade.symbol}</strong></td>
                        <td>${trade.contracts}</td>
                        <td>$${trade.strike.toFixed(2)}</td>
                        <td>$${trade.premium.toFixed(2)}</td>
                        <td><span class="action-badge ${trade.action}">${trade.action.toUpperCase()}</span></td>
                        <td><span class="type-badge ${trade.type}">${trade.type.toUpperCase()}</span></td>
                        <td>${formatDate(trade.dateOpened)}</td>
                        <td>${formatDate(trade.dateClosed)}</td>
                        <td>${formatDate(trade.expDate)}</td>
                        <td>${cashRequired > 0 ? '$' + cashRequired.toLocaleString() : '-'}</td>
                        <td class="${parseFloat(returnPercent) >= 0 ? 'positive-value' : 'negative-value'}">${returnPercent}%</td>
                        <td class="${pl >= 0 ? 'positive-value' : 'negative-value'}">$${formatCurrency(pl)}</td>
                        <td style="max-width: 200px; overflow: hidden; text-overflow: ellipsis;">${trade.closingNotes || trade.info || '-'}</td>
                        <td>
                            <div class="action-buttons">
                                <button class="btn-small" onclick="reopenTrade(${index})">Reopen</button>
                                <button class="btn-small danger" onclick="deleteClosedTrade(${index})">Delete</button>
                            </div>
                        </td>
                    </tr>
                `;
            }).join('');
        }

        function sortAllTrades(field, order) {
            allTradesSortField = field;
            allTradesSortOrder = order;
            renderAllTrades();
        }

        function filterAllTrades(filterType) {
            allTradesFilter = filterType;
            
            // Update button styles
            document.getElementById('filterAllBtn').style.background = filterType === 'all' ? '#00ff88' : '#333';
            document.getElementById('filterAllBtn').style.color = filterType === 'all' ? '#000' : '#fff';
            document.getElementById('filterOpenBtn').style.background = filterType === 'open' ? '#00ff88' : '#333';
            document.getElementById('filterOpenBtn').style.color = filterType === 'open' ? '#000' : '#fff';
            document.getElementById('filterClosedBtn').style.background = filterType === 'closed' ? '#00ff88' : '#333';
            document.getElementById('filterClosedBtn').style.color = filterType === 'closed' ? '#000' : '#fff';
            document.getElementById('filterRolledBtn').style.background = filterType === 'rolled' ? '#00ff88' : '#333';
            document.getElementById('filterRolledBtn').style.color = filterType === 'rolled' ? '#000' : '#fff';
            document.getElementById('filterAssignedBtn').style.background = filterType === 'assigned' ? '#00ff88' : '#333';
            document.getElementById('filterAssignedBtn').style.color = filterType === 'assigned' ? '#000' : '#fff';
            
            renderAllTrades();
        }

        function showSymbolDetail(symbol) {
            currentSymbol = symbol;
            symbolTradesFilter = 'all';
            
            // Hide all other tabs
            document.querySelectorAll('.tab-content').forEach(tab => tab.style.display = 'none');
            
            // Show symbol detail tab
            document.getElementById('symbolDetailTab').style.display = 'block';
            document.getElementById('symbolDetailTitle').textContent = `${symbol} - All Trades`;
            
            // Render the symbol trades
            renderSymbolTrades();
            renderSymbolGroups();
        }

        function closeSymbolDetail() {
            document.getElementById('symbolDetailTab').style.display = 'none';
            document.getElementById(currentTab + 'Tab').classList.add('active');
            document.getElementById(currentTab + 'Tab').style.display = 'block';
        }

        function filterSymbolTrades(filterType) {
            symbolTradesFilter = filterType;
            
            // Update button styles
            document.getElementById('symbolFilterAllBtn').style.background = filterType === 'all' ? '#00ff88' : '#333';
            document.getElementById('symbolFilterAllBtn').style.color = filterType === 'all' ? '#000' : '#fff';
            document.getElementById('symbolFilterOpenBtn').style.background = filterType === 'open' ? '#00ff88' : '#333';
            document.getElementById('symbolFilterOpenBtn').style.color = filterType === 'open' ? '#000' : '#fff';
            document.getElementById('symbolFilterClosedBtn').style.background = filterType === 'closed' ? '#00ff88' : '#333';
            document.getElementById('symbolFilterClosedBtn').style.color = filterType === 'closed' ? '#000' : '#fff';
            document.getElementById('symbolFilterRolledBtn').style.background = filterType === 'rolled' ? '#00ff88' : '#333';
            document.getElementById('symbolFilterRolledBtn').style.color = filterType === 'rolled' ? '#000' : '#fff';
            document.getElementById('symbolFilterAssignedBtn').style.background = filterType === 'assigned' ? '#00ff88' : '#333';
            document.getElementById('symbolFilterAssignedBtn').style.color = filterType === 'assigned' ? '#000' : '#fff';
            
            renderSymbolTrades();
        }

        function renderSymbolTrades() {
            const tbody = document.getElementById('symbolTradesBody');
            if (!tbody) return;
            
            // Get all trades for this symbol
            const openTrades = trades.filter(t => t.symbol === currentSymbol).map(t => ({...t, isOpen: true}));
            const closedTradesArray = closedTrades.filter(t => t.symbol === currentSymbol).map(t => ({...t, isOpen: false}));
            
            // Get trades from groups
            const includedIds = new Set();
            openTrades.forEach(t => { if (t.id) includedIds.add(t.id); });
            closedTradesArray.forEach(t => { if (t.id) includedIds.add(t.id); });
            
            const groupTrades = [];
            tradeGroups.forEach(group => {
                if (group.trades && Array.isArray(group.trades)) {
                    group.trades.forEach(trade => {
                        if (trade.symbol !== currentSymbol) return;
                        
                        if (trade.id && includedIds.has(trade.id)) return;
                        
                        const alreadyExists = openTrades.some(t => 
                            t.symbol === trade.symbol && 
                            t.dateOpened === trade.dateOpened && 
                            t.strike === trade.strike &&
                            t.premium === trade.premium &&
                            t.action === trade.action
                        ) || closedTradesArray.some(t => 
                            t.symbol === trade.symbol && 
                            t.dateOpened === trade.dateOpened && 
                            t.strike === trade.strike &&
                            t.premium === trade.premium &&
                            t.action === trade.action
                        );
                        
                        if (!alreadyExists) {
                            if (trade.id) includedIds.add(trade.id);
                            groupTrades.push({...trade, isOpen: trade.status === 'open'});
                        }
                    });
                }
            });
            
            let allTrades = [...openTrades, ...closedTradesArray, ...groupTrades];
            
            // Apply filter
            let filteredTrades = allTrades;
            if (symbolTradesFilter === 'open') {
                filteredTrades = allTrades.filter(t => t.isOpen);
            } else if (symbolTradesFilter === 'closed') {
                filteredTrades = allTrades.filter(t => !t.isOpen);
            } else if (symbolTradesFilter === 'rolled') {
                const rolledTradeRefs = new Set();
                allTrades.forEach(t => {
                    if (t.isRolled && t.tradeRef && t.tradeRef.trim()) {
                        rolledTradeRefs.add(t.tradeRef);
                    }
                });
                
                filteredTrades = allTrades.filter(t => {
                    if (t.isRolled) return true;
                    if (t.tradeRef && t.tradeRef.trim() && rolledTradeRefs.has(t.tradeRef)) {
                        return true;
                    }
                    return false;
                });
            } else if (symbolTradesFilter === 'assigned') {
                const assignedTradeRefs = new Set();
                stockPositions.forEach(sp => {
                    if (sp.symbol === currentSymbol && sp.tradeRef && sp.tradeRef.trim()) {
                        assignedTradeRefs.add(sp.tradeRef);
                    }
                });
                
                closedTrades.forEach(t => {
                    if (t.symbol === currentSymbol && t.status === 'assigned' && t.tradeRef && t.tradeRef.trim()) {
                        assignedTradeRefs.add(t.tradeRef);
                    }
                });
                
                filteredTrades = allTrades.filter(t => {
                    if (t.status === 'assigned') return true;
                    if (t.tradeRef && t.tradeRef.trim() && assignedTradeRefs.has(t.tradeRef)) {
                        return true;
                    }
                    return false;
                });
            }
            
            if (filteredTrades.length === 0) {
                tbody.innerHTML = `
                    <tr>
                        <td colspan="17" style="text-align: center; color: #666; padding: 40px;">
                            No trades found for this filter.
                        </td>
                    </tr>
                `;
                return;
            }
            
            // Sort by dateOpened desc
            filteredTrades.sort((a, b) => new Date(b.dateOpened) - new Date(a.dateOpened));
            
            // Render trades
            tbody.innerHTML = filteredTrades.map(trade => {
                const cashRequired = calculateCashRequired(trade);
                const returnPercent = calculateReturnPercent(trade);
                const pl = calculatePL(trade, true);
                const statusBadge = trade.isOpen ? 
                    '<span class="status-badge open">OPEN</span>' : 
                    '<span class="status-badge closed">CLOSED</span>';

                return `
                    <tr>
                        <td>${statusBadge}</td>
                        <td><strong>${trade.symbol}</strong>${trade.isRolled ? '<span class="rolled-badge">Rolled</span>' : ''}</td>
                        <td>${trade.contracts}</td>
                        <td>$${trade.strike.toFixed(2)}</td>
                        <td>$${trade.premium.toFixed(2)}</td>
                        <td><span class="action-badge ${trade.action}">${trade.action.toUpperCase()}</span></td>
                        <td><span class="type-badge ${trade.type}">${trade.type.toUpperCase()}</span></td>
                        <td>${formatDate(trade.dateOpened)}</td>
                        <td>${trade.dateClosed ? formatDate(trade.dateClosed) : '-'}</td>
                        <td>${formatDate(trade.expDate)}</td>
                        <td>${cashRequired > 0 ? '$' + cashRequired.toLocaleString() : '-'}</td>
                        <td class="${parseFloat(returnPercent) >= 0 ? 'positive-value' : 'negative-value'}">${returnPercent}%</td>
                        <td class="${pl >= 0 ? 'positive-value' : 'negative-value'}">$${formatCurrency(pl)}</td>
                        <td style="max-width: 200px; overflow: hidden; text-overflow: ellipsis;">${trade.closingNotes || trade.info || '-'}</td>
                        <td style="color: #00ff88;"><strong>${trade.tradeRef || '-'}</strong></td>
                        <td>${trade.account || '-'}</td>
                        <td>-</td>
                    </tr>
                `;
            }).join('');
        }

        function renderSymbolGroups() {
            const container = document.getElementById('symbolGroupsList');
            if (!container) return;
            
            // Filter groups that have trades with this symbol and are fully closed
            const symbolGroups = tradeGroups.filter(group => {
                if (!group.trades || !Array.isArray(group.trades)) return false;
                
                // Check if group has this symbol
                const hasSymbol = group.trades.some(t => t.symbol === currentSymbol);
                if (!hasSymbol) return false;
                
                // Check if all trades with this symbol are closed
                const symbolTrades = group.trades.filter(t => t.symbol === currentSymbol);
                const hasOpenTrades = symbolTrades.some(t => t.status === 'open');
                
                return !hasOpenTrades;
            });
            
            if (symbolGroups.length === 0) {
                container.innerHTML = `
                    <div style="text-align: center; color: #666; padding: 40px; background: #111; border: 1px solid #333; border-radius: 8px;">
                        No completed groups for ${currentSymbol} yet.
                    </div>
                `;
                return;
            }
            
            // Render groups (same as renderGroups but filtered)
            container.innerHTML = symbolGroups.map(group => {
                let totalProfit = 0;
                const symbolTradesInGroup = group.trades.filter(t => t.symbol === currentSymbol);
                
                symbolTradesInGroup.forEach(trade => {
                    // For CALLED AWAY trades, use the stock profit from cycleDetails
                    if (trade.isCalledAway && trade.cycleDetails) {
                        totalProfit += trade.cycleDetails.stockProfit;
                    } 
                    // For ASSIGNMENT trades, no P&L (already counted in PUT)
                    else if (trade.isAssignment) {
                        // Skip - no P&L for assignment itself
                    }
                    // For regular option trades
                    else {
                        const amount = trade.premium * trade.contracts * 100;
                        if (trade.action === 'sell') {
                            totalProfit += amount;
                        } else {
                            totalProfit -= amount;
                        }
                    }
                });

                const cashRequired = symbolTradesInGroup[0].strike * symbolTradesInGroup[0].contracts * 100;
                const percentReturn = ((totalProfit / cashRequired) * 100).toFixed(2);

                return `
                    <div class="table-container" style="margin-bottom: 20px;">
                        <div class="table-header">
                            <div class="table-title">${group.name}</div>
                            <div style="font-size: 1.5rem; font-weight: 700; color: ${totalProfit >= 0 ? '#00ff88' : '#ff4444'};">
                                Profit: $${formatCurrency(totalProfit)} (${percentReturn}%)
                            </div>
                        </div>
                        <table>
                            <thead>
                                <tr>
                                    <th>Symbol</th>
                                    <th>Contracts</th>
                                    <th>Strike</th>
                                    <th>Premium</th>
                                    <th>Action</th>
                                    <th>Type</th>
                                    <th>Date Opened</th>
                                    <th>Exp Date</th>
                                    <th>P&L</th>
                                    <th>Info</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${symbolTradesInGroup.map(trade => {
                                    const pl = calculatePL(trade, true);
                                    return `
                                        <tr>
                                            <td>
                                                <strong>${trade.symbol}</strong>
                                                ${trade.isRolled ? '<span style="background: #4488ff; color: #fff; padding: 2px 6px; border-radius: 4px; font-size: 0.75rem; margin-left: 5px;">ROLLED</span>' : ''}
                                                ${trade.isAssignment ? '<span style="background: #ff8844; color: #000; padding: 2px 6px; border-radius: 4px; font-size: 0.75rem; margin-left: 5px;">ASSIGNED</span>' : ''}
                                                ${trade.isCalledAway ? '<span style="background: #00ff88; color: #000; padding: 2px 6px; border-radius: 4px; font-size: 0.75rem; margin-left: 5px;">CALLED AWAY</span>' : ''}
                                            </td>
                                            <td>${trade.contracts}</td>
                                            <td>$${trade.strike.toFixed(2)}</td>
                                            <td>$${trade.premium.toFixed(2)}</td>
                                            <td><span class="action-badge ${trade.action}">${trade.action.toUpperCase()}</span></td>
                                            <td><span class="type-badge ${trade.type}">${trade.type.toUpperCase()}</span></td>
                                            <td>${formatDate(trade.dateOpened)}</td>
                                            <td>${formatDate(trade.expDate)}</td>
                                            <td class="${pl >= 0 ? 'positive-value' : 'negative-value'}">$${formatCurrency(pl)}</td>
                                            <td style="max-width: 200px; overflow: hidden; text-overflow: ellipsis;">${trade.info || '-'}</td>
                                        </tr>
                                    `;
                                }).join('')}
                            </tbody>
                        </table>
                    </div>
                `;
            }).join('');
        }

        function renderAllTrades() {
            // Populate the symbol filter dropdown first
            populateSymbolFilter();
            
            const tbody = document.getElementById('allTradesTableBody');
            if (!tbody) return; // Exit if element doesn't exist yet
            
            // Check if we have a sorted order to use
            let allTrades;
            if (window.sortedAllTrades && window.sortedAllTrades.length > 0) {
                // Use pre-sorted array
                allTrades = window.sortedAllTrades;
            } else {
                // Build array normally
                const openTrades = trades.map(t => ({...t, isOpen: true}));
                const closedTradesArray = closedTrades.map(t => ({...t, isOpen: false}));
                
                // Build a Set of IDs we've already included from open and closed
                const includedIds = new Set();
                openTrades.forEach(t => { if (t.id) includedIds.add(t.id); });
                closedTradesArray.forEach(t => { if (t.id) includedIds.add(t.id); });
                
                // Only add trades from groups if they're NOT in open or closed arrays
                const groupTrades = [];
                tradeGroups.forEach(group => {
                    if (group.trades && Array.isArray(group.trades)) {
                        group.trades.forEach(trade => {
                            // Skip if already included (by ID or by field matching)
                            if (trade.id && includedIds.has(trade.id)) {
                                return; // Already in open or closed
                            }
                            
                            // Fallback: field matching for old trades without IDs
                            const alreadyExists = openTrades.some(t => 
                                t.symbol === trade.symbol && 
                                t.dateOpened === trade.dateOpened && 
                                t.strike === trade.strike &&
                                t.premium === trade.premium &&
                                t.action === trade.action
                            ) || closedTradesArray.some(t => 
                                t.symbol === trade.symbol && 
                                t.dateOpened === trade.dateOpened && 
                                t.strike === trade.strike &&
                                t.premium === trade.premium &&
                                t.action === trade.action
                            );
                            
                            if (!alreadyExists) {
                                if (trade.id) includedIds.add(trade.id);
                                groupTrades.push({...trade, isOpen: trade.status === 'open'});
                            }
                        });
                    }
                });
                
                allTrades = [...openTrades, ...closedTradesArray, ...groupTrades];
            }
            
            console.log('renderAllTrades - Total allTrades:', allTrades.length);
            
            // Apply filter
            let filteredTrades = allTrades;
            
            // Apply symbol filter first
            const selectedSymbol = document.getElementById('allTradesSymbolFilter')?.value;
            if (selectedSymbol && selectedSymbol !== '') {
                filteredTrades = filteredTrades.filter(t => t.symbol === selectedSymbol);
            }
            
            // Then apply status filter
            if (allTradesFilter === 'open') {
                filteredTrades = filteredTrades.filter(t => t.isOpen);
            } else if (allTradesFilter === 'closed') {
                filteredTrades = allTrades.filter(t => !t.isOpen);
            } else if (allTradesFilter === 'rolled') {
                // Find all Trade Ref #s that have at least one rolled position
                const rolledTradeRefs = new Set();
                allTrades.forEach(t => {
                    if (t.isRolled && t.tradeRef && t.tradeRef.trim()) {
                        rolledTradeRefs.add(t.tradeRef);
                    }
                });
                
                // Show all trades that either:
                // 1. Are marked as rolled, OR
                // 2. Share a Trade Ref # with a rolled position
                filteredTrades = allTrades.filter(t => {
                    if (t.isRolled) return true; // Always show rolled positions
                    if (t.tradeRef && t.tradeRef.trim() && rolledTradeRefs.has(t.tradeRef)) {
                        return true; // Show trades with same Trade Ref as rolled positions
                    }
                    return false;
                });
            } else if (allTradesFilter === 'assigned') {
                // Find all Trade Ref #s that have assigned stock positions
                const assignedTradeRefs = new Set();
                stockPositions.forEach(sp => {
                    if (sp.tradeRef && sp.tradeRef.trim()) {
                        assignedTradeRefs.add(sp.tradeRef);
                    }
                });
                
                // Also find trades marked as assigned
                closedTrades.forEach(t => {
                    if (t.status === 'assigned' && t.tradeRef && t.tradeRef.trim()) {
                        assignedTradeRefs.add(t.tradeRef);
                    }
                });
                
                // Show all trades that share a Trade Ref # with assigned positions
                filteredTrades = allTrades.filter(t => {
                    if (t.status === 'assigned') return true;
                    if (t.tradeRef && t.tradeRef.trim() && assignedTradeRefs.has(t.tradeRef)) {
                        return true;
                    }
                    return false;
                });
            }
            
            if (filteredTrades.length === 0) {
                tbody.innerHTML = `
                    <tr>
                        <td colspan="17" style="text-align: center; color: #666; padding: 40px;">
                            No trades found for this filter.
                        </td>
                    </tr>
                `;
                return;
            }

            // Sort by the selected field and order
            filteredTrades.sort((a, b) => {
                let aValue, bValue;
                
                if (allTradesSortField === 'dateClosed') {
                    // For dateClosed, treat null/undefined as very old dates for sorting
                    aValue = a.dateClosed ? new Date(a.dateClosed) : new Date('1900-01-01');
                    bValue = b.dateClosed ? new Date(b.dateClosed) : new Date('1900-01-01');
                } else {
                    aValue = new Date(a[allTradesSortField]);
                    bValue = new Date(b[allTradesSortField]);
                }
                
                if (allTradesSortOrder === 'asc') {
                    return aValue - bValue;
                } else {
                    return bValue - aValue;
                }
            });

            // Special handling for Rolled Trades and Assigned Trades filters - group by Trade Ref #
            if (allTradesFilter === 'rolled' || allTradesFilter === 'assigned') {
                // Group trades by Trade Ref #
                const groupedByRef = {};
                filteredTrades.forEach(trade => {
                    const ref = trade.tradeRef || 'No Trade Ref';
                    if (!groupedByRef[ref]) {
                        groupedByRef[ref] = [];
                    }
                    groupedByRef[ref].push(trade);
                });

                // Render grouped
                let html = '';
                Object.keys(groupedByRef).forEach(ref => {
                    const tradesInRef = groupedByRef[ref];
                    
                    // Calculate total P&L for this ref group
                    let totalPL = 0;
                    tradesInRef.forEach(t => {
                        // For grouped display, sum the individual P&L values shown in the table
                        // Use forDisplay=true to get each leg's premium
                        totalPL += calculatePL(t, true);
                    });
                    
                    // Add group header
                    html += `
                        <tr style="background: #1a1a1a; font-weight: bold; border-top: 2px solid #00ff88;">
                            <td colspan="12" style="padding: 10px;">
                                <div style="display: flex; justify-content: space-between; align-items: center;">
                                    <span style="color: #00ff88; font-size: 1.1rem;">Trade Ref: ${ref}</span>
                                    <span class="${totalPL >= 0 ? 'positive-value' : 'negative-value'}" style="font-size: 1.1rem;">
                                        Total P&L: $${totalPL.toFixed(2)}
                                    </span>
                                </div>
                            </td>
                            <td colspan="5"></td>
                        </tr>
                    `;
                    
                    // Add trades in this group
                    tradesInRef.forEach(trade => {
                        const cashRequired = calculateCashRequired(trade);
                        const returnPercent = calculateReturnPercent(trade);
                        const pl = calculatePL(trade, true);
                        const rollCredit = calculateRollCredit(trade);
                        const statusBadge = trade.isOpen ? 
                            '<span class="status-badge open">OPEN</span>' : 
                            '<span class="status-badge closed">CLOSED</span>';

                        html += `
                            <tr>
                                <td>${statusBadge}</td>
                                <td>${makeSymbolClickable(trade.symbol, trade.isRolled)}${trade.isAssignment ? '<span style="background: #ff8844; color: #000; padding: 2px 6px; border-radius: 4px; font-size: 0.75rem; margin-left: 5px;">ASSIGNED</span>' : ''}${trade.isCalledAway ? '<span style="background: #00ff88; color: #000; padding: 2px 6px; border-radius: 4px; font-size: 0.75rem; margin-left: 5px;">CALLED AWAY</span>' : ''}</td>
                                <td>${trade.contracts}</td>
                                <td>$${trade.strike.toFixed(2)}</td>
                                <td>$${trade.premium.toFixed(2)}</td>
                                <td><span class="action-badge ${trade.action}">${trade.action.toUpperCase()}</span></td>
                                <td><span class="type-badge ${trade.type}">${trade.type.toUpperCase()}</span></td>
                                <td>${formatDate(trade.dateOpened)}</td>
                                <td>${trade.dateClosed ? formatDate(trade.dateClosed) : '-'}</td>
                                <td>${formatDate(trade.expDate)}</td>
                                <td>${cashRequired > 0 ? '$' + cashRequired.toLocaleString() : '-'}</td>
                                <td class="${parseFloat(returnPercent) >= 0 ? 'positive-value' : 'negative-value'}">${returnPercent}%</td>
                                <td class="${pl >= 0 ? 'positive-value' : 'negative-value'}">$${formatCurrency(pl)}</td>
                                <td class="${rollCredit !== null ? (rollCredit >= 0 ? 'positive-value' : 'negative-value') : ''}">${rollCredit !== null ? '$' + formatCurrency(rollCredit) : '-'}</td>
                                <td style="max-width: 200px; overflow: hidden; text-overflow: ellipsis;">${trade.closingNotes || trade.info || '-'}</td>
                                <td style="color: #00ff88;"><strong>${trade.tradeRef || '-'}</strong></td>
                                <td>${trade.account || '-'}</td>
                                <td>
                                    <div class="action-buttons">
                                        ${trade.isOpen ? `
                                            <button class="btn-small" onclick="editTradeFromAll(${filteredTrades.indexOf(trade)})">Edit</button>
                                            <button class="btn-small" style="background: #4488ff; color: #fff;" onclick="rollTradeFromAll(${filteredTrades.indexOf(trade)})">Roll</button>
                                            <button class="btn-small success" onclick="closeTradeFromAll(${filteredTrades.indexOf(trade)})">Close</button>
                                            ${trade.type === 'call' && trade.action === 'sell' ? `
                                                <button class="btn-small" style="background: #ff4488; color: #fff;" onclick="calledOutFromAll(${filteredTrades.indexOf(trade)})">Called Out</button>
                                            ` : ''}
                                        ` : `
                                            <button class="btn-small" onclick="editTradeFromAll(${filteredTrades.indexOf(trade)})">Edit</button>
                                        `}
                                        <button class="btn-small danger" onclick="deleteTradeFromAll(${filteredTrades.indexOf(trade)})">Delete</button>
                                    </div>
                                </td>
                            </tr>
                        `;
                    });
                    
                    // Add spacing between groups
                    html += `<tr style="height: 20px;"><td colspan="17"></td></tr>`;
                });
                
                tbody.innerHTML = html;
            } else {
                // Normal rendering for other filters
                tbody.innerHTML = filteredTrades.map((trade, index) => {
                const cashRequired = calculateCashRequired(trade);
                const returnPercent = calculateReturnPercent(trade);
                const pl = calculatePL(trade, true);
                const rollCredit = calculateRollCredit(trade);
                const statusBadge = trade.isOpen ? 
                    '<span class="status-badge open">OPEN</span>' : 
                    '<span class="status-badge closed">CLOSED</span>';

                return `
                    <tr>
                        <td>${statusBadge}</td>
                        <td>${makeSymbolClickable(trade.symbol, trade.isRolled)}${trade.isAssignment ? '<span style="background: #ff8844; color: #000; padding: 2px 6px; border-radius: 4px; font-size: 0.75rem; margin-left: 5px;">ASSIGNED</span>' : ''}${trade.isCalledAway ? '<span style="background: #00ff88; color: #000; padding: 2px 6px; border-radius: 4px; font-size: 0.75rem; margin-left: 5px;">CALLED AWAY</span>' : ''}</td>
                        <td>${trade.contracts}</td>
                        <td>$${trade.strike.toFixed(2)}</td>
                        <td>$${trade.premium.toFixed(2)}</td>
                        <td><span class="action-badge ${trade.action}">${trade.action.toUpperCase()}</span></td>
                        <td><span class="type-badge ${trade.type}">${trade.type.toUpperCase()}</span></td>
                        <td>${formatDate(trade.dateOpened)}</td>
                        <td>${trade.dateClosed ? formatDate(trade.dateClosed) : '-'}</td>
                        <td>${formatDate(trade.expDate)}</td>
                        <td>${cashRequired > 0 ? '$' + cashRequired.toLocaleString() : '-'}</td>
                        <td class="${parseFloat(returnPercent) >= 0 ? 'positive-value' : 'negative-value'}">${returnPercent}%</td>
                        <td class="${pl >= 0 ? 'positive-value' : 'negative-value'}">$${formatCurrency(pl)}</td>
                        <td class="${rollCredit !== null ? (rollCredit >= 0 ? 'positive-value' : 'negative-value') : ''}">${rollCredit !== null ? '$' + formatCurrency(rollCredit) : '-'}</td>
                        <td style="max-width: 200px; overflow: hidden; text-overflow: ellipsis;">${trade.closingNotes || trade.info || '-'}</td>
                        <td style="color: #00ff88;"><strong>${trade.tradeRef || '-'}</strong></td>
                        <td>${trade.account || '-'}</td>
                        <td>
                            <div class="action-buttons">
                                <button class="btn-small" onclick="editTradeFromAll(${index}, ${trade.isOpen})">Edit</button>
                                ${trade.isOpen ? `
                                    <button class="btn-small" style="background: #4488ff; color: #fff;" onclick="rollTradeFromAll(${index})">Roll</button>
                                    <button class="btn-small success" onclick="closeTradeFromAll(${index})">Close</button>
                                    ${trade.type === 'call' && trade.action === 'sell' ? `
                                        <button class="btn-small" style="background: #ff4488; color: #fff;" onclick="calledOutFromAll(${index})">Called Out</button>
                                    ` : ''}
                                ` : ''}
                                <button class="btn-small danger" onclick="deleteTradeFromAll(${index}, ${trade.isOpen})">Delete</button>
                            </div>
                        </td>
                    </tr>
                `;
            }).join('');
            }
        }

        function sortGroupTrades(groupIndex, field, order) {
            const group = tradeGroups[groupIndex];
            if (group && group.trades) {
                group.trades.sort((a, b) => {
                    const aDate = new Date(a[field]);
                    const bDate = new Date(b[field]);
                    if (order === 'asc') {
                        return aDate - bDate;
                    } else {
                        return bDate - aDate;
                    }
                });
                saveData();
                renderGroups();
            }
        }

        function renderGroups() {
            const container = document.getElementById('groupsList');
            if (!container) return; // Exit if container doesn't exist yet
            
            // Filter out any invalid groups
            tradeGroups = tradeGroups.filter(g => g.trades && Array.isArray(g.trades) && g.trades.length > 0);
            
            // Filter groups to only show if there are NO open trades with the same Trade Ref #
            const groupsToDisplay = tradeGroups.filter(group => {
                // Get Trade Ref # from group (check group name or first trade)
                let groupTradeRef = null;
                
                // Try to extract from group name "Trade Ref: XXX"
                if (group.name && group.name.startsWith('Trade Ref: ')) {
                    groupTradeRef = group.name.replace('Trade Ref: ', '');
                }
                
                // Fallback: get from first trade
                if (!groupTradeRef && group.trades && group.trades.length > 0) {
                    groupTradeRef = group.trades[0].tradeRef;
                }
                
                // If no Trade Ref, show the group (it's a manual group)
                if (!groupTradeRef || !groupTradeRef.trim()) {
                    return true;
                }
                
                // Check if there are any OPEN trades with this Trade Ref #
                const hasOpenTrades = trades.some(t => 
                    t.tradeRef && 
                    t.tradeRef.trim() === groupTradeRef.trim() && 
                    t.status === 'open'
                );
                
                // Only show group if there are NO open trades with this Trade Ref
                return !hasOpenTrades;
            });
            
            if (groupsToDisplay.length === 0) {
                container.innerHTML = `
                    <div style="text-align: center; color: #666; padding: 40px; background: #111; border: 1px solid #333; border-radius: 8px;">
                        No completed trade groups yet. Groups will appear here when all positions in a trade chain are closed.
                    </div>
                `;
                return;
            }
            
            // Sort groups by most recent dateClosed (newest first)
            groupsToDisplay.sort((a, b) => {
                const getLatestDate = (group) => {
                    if (group.dateClosed) return new Date(group.dateClosed);
                    // Find latest dateClosed from trades
                    const dates = group.trades
                        .filter(t => t.dateClosed)
                        .map(t => new Date(t.dateClosed));
                    return dates.length > 0 ? new Date(Math.max(...dates)) : new Date(0);
                };
                return getLatestDate(b) - getLatestDate(a); // Descending (newest first)
            });

            container.innerHTML = groupsToDisplay.map((group) => {
                // Find actual index in tradeGroups array
                const actualGroupIndex = tradeGroups.findIndex(g => g.id === group.id);
                
                // Calculate total profit for the group
                let totalProfit = 0;
                if (!group.trades || !Array.isArray(group.trades)) {
                    console.error('Invalid group trades:', group);
                    return '';
                }
                
                group.trades.forEach(trade => {
                    // For CALLED AWAY trades, use the stock profit from cycleDetails
                    if (trade.isCalledAway && trade.cycleDetails) {
                        totalProfit += trade.cycleDetails.stockProfit;
                    } 
                    // For ASSIGNMENT trades, no P&L (already counted in PUT)
                    else if (trade.isAssignment) {
                        // Skip - no P&L for assignment itself
                    }
                    // For regular option trades
                    else {
                        const amount = trade.premium * trade.contracts * 100;
                        if (trade.action === 'sell') {
                            totalProfit += amount;
                        } else {
                            totalProfit -= amount;
                        }
                    }
                });

                const cashRequired = group.trades[0].strike * group.trades[0].contracts * 100;
                const percentReturn = ((totalProfit / cashRequired) * 100).toFixed(2);

                return `
                    <div class="table-container" style="margin-bottom: 30px;">
                        <div class="table-header">
                            <div class="table-title">${group.name}</div>
                            <div style="display: flex; gap: 10px; align-items: center;">
                                <div style="font-size: 1.5rem; font-weight: 700; color: ${totalProfit >= 0 ? '#00ff88' : '#ff4444'};">
                                    Profit: $${formatCurrency(totalProfit)} (${percentReturn}%)
                                </div>
                                <button class="btn-small" onclick="editGroup(${actualGroupIndex})">Edit</button>
                                <button class="btn-small danger" onclick="deleteGroup(${actualGroupIndex})">Delete</button>
                            </div>
                        </div>
                        <table>
                            <thead>
                                <tr>
                                    <th>Symbol</th>
                                    <th>Contracts</th>
                                    <th>Strike</th>
                                    <th>Premium</th>
                                    <th>Action</th>
                                    <th>Type</th>
                                    <th>Date Opened <span style="cursor: pointer; user-select: none;" onclick="sortGroupTrades(${actualGroupIndex}, 'dateOpened', 'asc')">‚ñ≤</span><span style="cursor: pointer; user-select: none;" onclick="sortGroupTrades(${actualGroupIndex}, 'dateOpened', 'desc')">‚ñº</span></th>
                                    <th>Exp Date</th>
                                    <th>Cash Required</th>
                                    <th>% Return</th>
                                    <th>Price @ Action</th>
                                    <th>% OTM</th>
                                    <th>P&L</th>
                                    <th>Info</th>
                                    <th>Trade Ref #</th>
                                    <th>Account</th>
                                    <th>Actions</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${group.trades.map((trade, tradeIndex) => {
                                    const cashReq = calculateCashRequired(trade);
                                    const returnPercent = calculateReturnPercent(trade);
                                    const otm = calculateOTM(trade);
                                    const pl = calculatePL(trade, true);
                                    
                                    return `
                                        <tr>
                                            <td>
                                                ${makeSymbolClickable(trade.symbol, trade.isRolled)}
                                                ${trade.isRolled ? '<span style="background: #4488ff; color: #fff; padding: 2px 6px; border-radius: 4px; font-size: 0.75rem; margin-left: 5px;">ROLLED</span>' : ''}
                                                ${trade.isAssignment ? '<span style="background: #ff8844; color: #000; padding: 2px 6px; border-radius: 4px; font-size: 0.75rem; margin-left: 5px;">ASSIGNED</span>' : ''}
                                                ${trade.isCalledAway ? '<span style="background: #00ff88; color: #000; padding: 2px 6px; border-radius: 4px; font-size: 0.75rem; margin-left: 5px;">CALLED AWAY</span>' : ''}
                                            </td>
                                            <td>${trade.contracts}</td>
                                            <td>$${trade.strike.toFixed(2)}</td>
                                            <td class="${trade.action === 'sell' ? 'positive-value' : 'negative-value'}">
                                                $${trade.premium.toFixed(2)}
                                            </td>
                                            <td><span class="action-badge ${trade.action}">${trade.action.toUpperCase()}</span></td>
                                            <td><span class="type-badge ${trade.type}">${trade.type.toUpperCase()}</span></td>
                                            <td>${formatDate(trade.dateOpened)}</td>
                                            <td>${formatDate(trade.expDate)}</td>
                                            <td>${cashReq > 0 ? '$' + cashReq.toLocaleString() : '-'}</td>
                                            <td class="${parseFloat(returnPercent) >= 0 ? 'positive-value' : 'negative-value'}">${returnPercent}%</td>
                                            <td>$${(trade.priceAtAction || 0).toFixed(2)}</td>
                                            <td class="${parseFloat(otm) >= 0 ? 'positive-value' : 'negative-value'}">${otm}%</td>
                                            <td class="${pl >= 0 ? 'positive-value' : 'negative-value'}">$${formatCurrency(pl)}</td>
                                            <td>${trade.info || '-'}</td>
                                            <td style="color: #00ff88;"><strong>${trade.tradeRef || '-'}</strong></td>
                                            <td>${trade.account || '-'}</td>
                                            <td>
                                                <div class="action-buttons">
                                                    <button class="btn-small" onclick="editTradeFromGroup(${actualGroupIndex}, ${tradeIndex})">Edit</button>
                                                    ${trade.status === 'open' ? `
                                                        <button class="btn-small" style="background: #4488ff; color: #fff;" onclick="rollTradeFromGroup(${actualGroupIndex}, ${tradeIndex})">Roll</button>
                                                        <button class="btn-small success" onclick="closeTradeFromGroup(${actualGroupIndex}, ${tradeIndex})">Close</button>
                                                    ` : ''}
                                                    <button class="btn-small danger" onclick="deleteTradeFromGroup(${actualGroupIndex}, ${tradeIndex})">Delete</button>
                                                </div>
                                            </td>
                                        </tr>
                                    `;
                                }).join('')}
                            </tbody>
                        </table>
                    </div>
                `;
            }).join('');
        }

        function autoGroupByTradeRef() {
            console.log('Auto-group called');
            // Only collect CLOSED trades
            const allClosedTrades = closedTrades;
            console.log('Total closed trades:', allClosedTrades.length);
            console.log('All closed trades:', allClosedTrades);
            
            // Filter trades that have a tradeRef
            const tradesWithRef = allClosedTrades.filter(t => t.tradeRef && t.tradeRef.trim() !== '');
            console.log('Closed trades with ref:', tradesWithRef.length);
            console.log('Closed trades with ref data:', tradesWithRef);
            
            if (tradesWithRef.length === 0) {
                alert('No closed trades with Trade Ref # found. Please add Trade Ref # to your trades first.');
                return;
            }
            
            // Group by tradeRef
            const grouped = {};
            tradesWithRef.forEach(trade => {
                const ref = trade.tradeRef.trim();
                if (!grouped[ref]) {
                    grouped[ref] = [];
                }
                grouped[ref].push({...trade});
            });
            
            console.log('Grouped:', grouped);
            console.log('Number of groups:', Object.keys(grouped).length);
            
            // Clear existing groups and create new ones
            tradeGroups = [];
            
            // Create groups
            Object.keys(grouped).forEach(ref => {
                const tradesInGroup = grouped[ref];
                console.log('Creating group for:', ref, 'with', tradesInGroup.length, 'trades');
                tradeGroups.push({
                    id: Date.now() + Math.random(),
                    name: `Trade Ref: ${ref}`,
                    trades: tradesInGroup,
                    created: new Date().toISOString()
                });
            });
            
            console.log('Final tradeGroups:', tradeGroups);
            
            saveData();
            renderGroups();
            updateStats();
            alert(`Created ${Object.keys(grouped).length} groups from closed trades with Trade Ref #!`);
        }

        function createNewGroup() {
            document.getElementById('groupName').value = '';
            renderAvailableTrades();
            document.getElementById('groupModal').classList.add('active');
        }

        function renderAvailableTrades() {
            const container = document.getElementById('availableTrades');
            const allTrades = [...trades, ...closedTrades];
            
            if (allTrades.length === 0) {
                container.innerHTML = '<p style="color: #666;">No trades available to group.</p>';
                return;
            }

            container.innerHTML = `
                <table style="width: 100%; border-collapse: collapse;">
                    <thead>
                        <tr style="background: #0a0a0a;">
                            <th style="padding: 10px; text-align: left;">
                                <input type="checkbox" id="selectAll" onchange="toggleSelectAll()" style="width: auto;">
                            </th>
                            <th style="padding: 10px; text-align: left; color: #888;">Symbol</th>
                            <th style="padding: 10px; text-align: left; color: #888;">Strike</th>
                            <th style="padding: 10px; text-align: left; color: #888;">Premium</th>
                            <th style="padding: 10px; text-align: left; color: #888;">Action</th>
                            <th style="padding: 10px; text-align: left; color: #888;">Type</th>
                            <th style="padding: 10px; text-align: left; color: #888;">Date</th>
                            <th style="padding: 10px; text-align: left; color: #888;">Exp</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${allTrades.map((trade, index) => `
                            <tr style="border-bottom: 1px solid #222;">
                                <td style="padding: 10px;">
                                    <input type="checkbox" class="trade-checkbox" data-index="${index}" style="width: auto;">
                                </td>
                                <td style="padding: 10px;"><strong>${trade.symbol}</strong></td>
                                <td style="padding: 10px;">$${trade.strike.toFixed(2)}</td>
                                <td style="padding: 10px;" class="${trade.action === 'sell' ? 'positive-value' : 'negative-value'}">
                                    $${trade.premium.toFixed(2)}
                                </td>
                                <td style="padding: 10px;"><span class="action-badge ${trade.action}">${trade.action.toUpperCase()}</span></td>
                                <td style="padding: 10px;"><span class="type-badge ${trade.type}">${trade.type.toUpperCase()}</span></td>
                                <td style="padding: 10px;">${formatDate(trade.dateOpened)}</td>
                                <td style="padding: 10px;">${formatDate(trade.expDate)}</td>
                            </tr>
                        `).join('')}
                    </tbody>
                </table>
            `;
        }

        function toggleSelectAll() {
            const selectAll = document.getElementById('selectAll').checked;
            document.querySelectorAll('.trade-checkbox').forEach(cb => {
                cb.checked = selectAll;
            });
        }

        function saveGroup() {
            const groupName = document.getElementById('groupName').value.trim();
            if (!groupName) {
                alert('Please enter a group name');
                return;
            }

            const allTrades = [...trades, ...closedTrades];
            const selectedTrades = [];
            
            document.querySelectorAll('.trade-checkbox:checked').forEach(cb => {
                const index = parseInt(cb.dataset.index);
                selectedTrades.push({...allTrades[index]});
            });

            if (selectedTrades.length === 0) {
                alert('Please select at least one trade');
                return;
            }

            const group = {
                id: Date.now(),
                name: groupName,
                trades: selectedTrades,
                created: new Date().toISOString()
            };

            tradeGroups.push(group);
            saveData();
            renderGroups();
            updateStats();
            closeGroupModal();
        }

        function closeGroupModal() {
            document.getElementById('groupModal').classList.remove('active');
        }

        function editGroup(index) {
            // TODO: Implement edit group functionality
            alert('Edit group functionality coming soon');
        }

        function showGroupManager() {
            // TODO: Implement group manager
            alert('Group manager coming soon');
        }

        function deleteGroup(index) {
            if (true) { // Temporarily removing confirm
                tradeGroups.splice(index, 1);
                saveData();
                renderGroups();
                updateStats();
                alert('Group deleted successfully');
            }
        }

        function editTradeFromGroup(groupIndex, tradeIndex) {
            const group = tradeGroups[groupIndex];
            const trade = group.trades[tradeIndex];
            
            // Set editing context
            editingFromGroup = groupIndex;
            
            // Find which array this trade is in
            const openIndex = trades.findIndex(t => 
                t.symbol === trade.symbol && 
                t.dateOpened === trade.dateOpened && 
                t.strike === trade.strike &&
                t.premium === trade.premium
            );
            
            if (openIndex !== -1) {
                editingIndex = openIndex;
                editingFromArray = 'open';
            } else {
                const closedIndex = closedTrades.findIndex(t => 
                    t.symbol === trade.symbol && 
                    t.dateOpened === trade.dateOpened && 
                    t.strike === trade.strike &&
                    t.premium === trade.premium
                );
                if (closedIndex !== -1) {
                    editingIndex = closedIndex;
                    editingFromArray = 'closed';
                }
            }
            
            populateEditModal(trade);
            document.getElementById('editModal').classList.add('active');
        }

        function deleteTradeFromGroup(groupIndex, tradeIndex) {
            if (true) { // Temporarily removing confirm
                console.log('Deleting trade from group:', groupIndex, 'trade index:', tradeIndex);
                
                const group = tradeGroups[groupIndex];
                const tradeToDelete = group.trades[tradeIndex];
                
                // Save for undo
                lastDeletedTrade = {...tradeToDelete};
                lastDeletedFrom = 'group';
                lastDeletedGroupInfo = {
                    groupIndex: groupIndex,
                    tradeIndex: tradeIndex,
                    groupName: group.name
                };
                
                // Remove from group
                group.trades.splice(tradeIndex, 1);
                
                // If group has no trades left, delete the entire group
                if (group.trades.length === 0) {
                    tradeGroups.splice(groupIndex, 1);
                    alert('Trade deleted. Group was empty so it was also removed.');
                }
                
                // Also remove from the underlying trades or closedTrades arrays
                // Check if it's in open trades
                const openIndex = trades.findIndex(t => 
                    t.symbol === tradeToDelete.symbol && 
                    t.dateOpened === tradeToDelete.dateOpened && 
                    t.strike === tradeToDelete.strike &&
                    t.premium === tradeToDelete.premium
                );
                if (openIndex !== -1) {
                    trades.splice(openIndex, 1);
                    console.log('Also removed from open trades');
                }
                
                // Check if it's in closed trades
                const closedIndex = closedTrades.findIndex(t => 
                    t.symbol === tradeToDelete.symbol && 
                    t.dateOpened === tradeToDelete.dateOpened && 
                    t.strike === tradeToDelete.strike &&
                    t.premium === tradeToDelete.premium
                );
                if (closedIndex !== -1) {
                    closedTrades.splice(closedIndex, 1);
                    console.log('Also removed from closed trades');
                }
                
                saveData();
                renderGroups();
                renderOpenTrades();
                if (currentTab === 'all') {
                    renderAllTrades();
                }
                updateStats();
                showUndoButton();
                alert('Trade deleted successfully from group');
            }
        }

        function rollTradeFromGroup(groupIndex, tradeIndex) {
            console.log('rollTradeFromGroup called:', groupIndex, tradeIndex);
            const group = tradeGroups[groupIndex];
            const tradeToRoll = group.trades[tradeIndex];
            
            console.log('Trade to roll:', tradeToRoll);
            
            // Find the actual index in the open trades array
            if (tradeToRoll.status === 'open') {
                const openIndex = trades.findIndex(t => 
                    t.symbol === tradeToRoll.symbol && 
                    t.dateOpened === tradeToRoll.dateOpened && 
                    t.strike === tradeToRoll.strike &&
                    t.premium === tradeToRoll.premium
                );
                console.log('Found openIndex:', openIndex);
                if (openIndex !== -1) {
                    openRollModal(openIndex);
                } else {
                    console.error('Could not find trade in open trades array');
                    alert('Error: Could not find this trade in open positions.');
                }
            } else {
                alert('This trade is not open and cannot be rolled.');
            }
        }

        function closeTradeFromGroup(groupIndex, tradeIndex) {
            console.log('closeTradeFromGroup called:', groupIndex, tradeIndex);
            const group = tradeGroups[groupIndex];
            const tradeToClose = group.trades[tradeIndex];
            
            console.log('Trade to close:', tradeToClose);
            
            // Find the actual index in the open trades array
            if (tradeToClose.status === 'open') {
                const openIndex = trades.findIndex(t => 
                    t.symbol === tradeToClose.symbol && 
                    t.dateOpened === tradeToClose.dateOpened && 
                    t.strike === tradeToClose.strike &&
                    t.premium === tradeToClose.premium
                );
                console.log('Found openIndex:', openIndex);
                if (openIndex !== -1) {
                    openCloseModal(openIndex);
                } else {
                    console.error('Could not find trade in open trades array');
                    alert('Error: Could not find this trade in open positions.');
                }
            } else {
                alert('This trade is not open and cannot be closed.');
            }
        }

        function showUndoButton() {
            const undoButton = document.getElementById('undoButton');
            if (undoButton) {
                undoButton.style.display = 'inline-block';
            }
        }

        function hideUndoButton() {
            const undoButton = document.getElementById('undoButton');
            if (undoButton) {
                undoButton.style.display = 'none';
            }
        }

        function undoDelete() {
            if (!lastDeletedTrade) {
                alert('Nothing to undo');
                return;
            }

            console.log('Undoing delete from:', lastDeletedFrom);

            if (lastDeletedFrom === 'open') {
                trades.push(lastDeletedTrade);
                renderOpenTrades();
            } else if (lastDeletedFrom === 'closed') {
                closedTrades.push(lastDeletedTrade);
            } else if (lastDeletedFrom === 'group' && lastDeletedGroupInfo) {
                // Restore to the group
                const group = tradeGroups[lastDeletedGroupInfo.groupIndex];
                if (group) {
                    group.trades.splice(lastDeletedGroupInfo.tradeIndex, 0, lastDeletedTrade);
                }
                
                // Also restore to the appropriate array
                if (lastDeletedTrade.status === 'open') {
                    trades.push(lastDeletedTrade);
                } else {
                    closedTrades.push(lastDeletedTrade);
                }
                
                renderGroups();
                renderOpenTrades();
            }

            if (currentTab === 'all') {
                renderAllTrades();
            }

            saveData();
            updateStats();
            
            // Clear undo data
            lastDeletedTrade = null;
            lastDeletedFrom = null;
            lastDeletedGroupInfo = null;
            hideUndoButton();
            
            alert('Delete undone successfully!');
        }

        function populateSymbolFilter() {
            const filterSelect = document.getElementById('allTradesSymbolFilter');
            if (!filterSelect) return;
            
            // Get all unique symbols from trades
            const symbols = new Set();
            trades.forEach(t => symbols.add(t.symbol));
            closedTrades.forEach(t => symbols.add(t.symbol));
            tradeGroups.forEach(group => {
                if (group.trades && Array.isArray(group.trades)) {
                    group.trades.forEach(t => symbols.add(t.symbol));
                }
            });
            
            // Sort symbols alphabetically
            const sortedSymbols = Array.from(symbols).sort();
            
            // Store current selection
            const currentValue = filterSelect.value;
            
            // Populate dropdown
            filterSelect.innerHTML = '<option value="">All</option>';
            sortedSymbols.forEach(symbol => {
                const option = document.createElement('option');
                option.value = symbol;
                option.textContent = symbol;
                filterSelect.appendChild(option);
            });
            
            // Restore selection if it still exists
            if (currentValue && sortedSymbols.includes(currentValue)) {
                filterSelect.value = currentValue;
            }
        }

        function updateStats() {
            try {
                let totalCollateral = 0;
                let totalPL = 0;
                let totalReturns = 0;

                trades.forEach(trade => {
                    const cashReq = calculateCashRequired(trade);
                    totalCollateral += cashReq;
                    
                    // Use forDisplay=true to get premium for each leg (including rolled trades)
                    totalPL += calculatePL(trade, true);
                    totalReturns += parseFloat(calculateReturnPercent(trade));
                });

            closedTrades.forEach(trade => {
                // Skip trades without required fields
                if (!trade.contracts || trade.premium === undefined) {
                    return;
                }
                
                // For rolled trades, include ALL legs (SELL and BUY)
                // Use forDisplay=true to get each leg's premium
                totalPL += calculatePL(trade, true);
            });

            const avgReturn = trades.length > 0 ? (totalReturns / trades.length).toFixed(2) : 0;
            
            // Calculate overall return: Sum of all % returns from CLOSED groups only
            let overallReturn = 0;
            let closedGroupsCount = 0;
            
            tradeGroups.forEach(group => {
                if (!group.trades || !Array.isArray(group.trades) || group.trades.length === 0) {
                    return;
                }
                
                // Check if this group is truly closed (same logic as badge count)
                let groupTradeRef = null;
                if (group.name && group.name.startsWith('Trade Ref: ')) {
                    groupTradeRef = group.name.replace('Trade Ref: ', '');
                }
                if (!groupTradeRef && group.trades.length > 0) {
                    groupTradeRef = group.trades[0].tradeRef;
                }
                
                // Skip if group has open trades
                if (groupTradeRef && groupTradeRef.trim()) {
                    const hasOpenTrades = trades.some(t => 
                        t.tradeRef && 
                        t.tradeRef.trim() === groupTradeRef.trim()
                    );
                    if (hasOpenTrades) {
                        return; // Skip this group - it's not fully closed
                    }
                }
                
                // Calculate profit for this CLOSED group
                let groupProfit = 0;
                group.trades.forEach(trade => {
                    const amount = trade.premium * trade.contracts * 100;
                    if (trade.action === 'sell') {
                        groupProfit += amount;
                    } else {
                        groupProfit -= amount;
                    }
                });
                
                // Calculate % return for this group
                const groupCashRequired = group.trades[0].strike * group.trades[0].contracts * 100;
                if (groupCashRequired > 0) {
                    const groupReturnPercent = (groupProfit / groupCashRequired) * 100;
                    overallReturn += groupReturnPercent;
                    closedGroupsCount++;
                }
            });
            
            // If no closed groups, show 0%
            if (closedGroupsCount === 0) {
                overallReturn = 0;
            }
            
            overallReturn = overallReturn.toFixed(2);

            // Update stats
            const totalCollateralEl = document.getElementById('totalCollateral');
            const totalPLEl = document.getElementById('totalPL');
            const overallReturnEl = document.getElementById('overallReturn');
            const openPositionsEl = document.getElementById('openPositions');
            const avgReturnEl = document.getElementById('avgReturn');
            const closedPositionsEl = document.getElementById('closedPositions');
            
            if (totalCollateralEl) totalCollateralEl.textContent = `$${totalCollateral.toLocaleString()}`;
            if (totalPLEl) {
                totalPLEl.textContent = `$${formatCurrency(totalPL)}`;
                totalPLEl.className = `stat-value ${totalPL >= 0 ? 'positive' : 'negative'}`;
            }
            if (overallReturnEl) {
                overallReturnEl.textContent = `${overallReturn}%`;
                overallReturnEl.className = `stat-value ${parseFloat(overallReturn) >= 0 ? 'positive' : 'negative'}`;
            }
            if (openPositionsEl) openPositionsEl.textContent = trades.length;
            if (avgReturnEl) avgReturnEl.textContent = `${avgReturn}%`;
            if (closedPositionsEl) closedPositionsEl.textContent = tradeGroups.length; // Show number of closed groups
            
            // Update dashboard metrics if on dashboard tab
            if (currentTab === 'dashboard') {
                updateDashboardMetrics();
            }
            
            // Update tab badges
            updateTabBadges();
            } catch (error) {
                console.error('Error in updateStats:', error);
                console.log('trades:', trades);
                console.log('closedTrades:', closedTrades);
                console.log('stockPositions:', stockPositions);
            }
        }

        // Clean up duplicate trade references in groups (same ID appearing multiple times)
        function cleanupDuplicateGroupTrades() {
            let duplicatesRemoved = 0;
            
            tradeGroups.forEach(group => {
                if (group.trades && Array.isArray(group.trades)) {
                    const seenIds = new Set();
                    const uniqueTrades = [];
                    
                    group.trades.forEach(trade => {
                        if (trade.id && !seenIds.has(trade.id)) {
                            seenIds.add(trade.id);
                            uniqueTrades.push(trade);
                        } else if (trade.id && seenIds.has(trade.id)) {
                            duplicatesRemoved++;
                            console.log('Removed duplicate reference:', trade.symbol, trade.action, '$' + trade.premium, 'ID:', trade.id);
                        }
                    });
                    
                    group.trades = uniqueTrades;
                }
            });
            
            if (duplicatesRemoved > 0) {
                console.log(`Cleaned up ${duplicatesRemoved} duplicate trade reference(s)`);
                saveUserData();
            }
            
            return duplicatesRemoved;
        }

        // Helper function to sync a trade's updates across all arrays
        function syncTradeAcrossAllArrays(tradeId, updates) {
            let synced = false;
            
            // Update in trades array
            const openTrade = trades.find(t => t.id === tradeId);
            if (openTrade) {
                Object.assign(openTrade, updates);
                synced = true;
            }
            
            // Update in closedTrades array
            const closedTrade = closedTrades.find(t => t.id === tradeId);
            if (closedTrade) {
                Object.assign(closedTrade, updates);
                synced = true;
            }
            
            // Update in all tradeGroups
            tradeGroups.forEach(group => {
                const tradeInGroup = group.trades.find(t => t.id === tradeId);
                if (tradeInGroup) {
                    Object.assign(tradeInGroup, updates);
                    synced = true;
                }
            });
            
            // Update in stockPositions if referenced
            stockPositions.forEach(stock => {
                if (stock.originalPut && stock.originalPut.id === tradeId) {
                    Object.assign(stock.originalPut, updates);
                    synced = true;
                }
            });
            
            return synced;
        }

        function showWinRateInfo() {
            document.getElementById('winRateInfoModal').classList.add('active');
        }

        function closeWinRateInfo() {
            document.getElementById('winRateInfoModal').classList.remove('active');
        }

        function updateTabBadges() {
            const openCount = trades.length;
            const stockCount = stockPositions.length;
            const groupsCount = getClosedGroupsCount(); // Use helper function instead
            
            // Count ALL trades: open + closed + orphaned trades in groups
            // Build a Set of IDs we've already counted
            const countedIds = new Set();
            trades.forEach(t => { if (t.id) countedIds.add(t.id); });
            closedTrades.forEach(t => { if (t.id) countedIds.add(t.id); });
            
            let allTradesCount = trades.length + closedTrades.length;
            
            // Add trades from groups that aren't in main arrays (orphans)
            tradeGroups.forEach(group => {
                if (group.trades && Array.isArray(group.trades)) {
                    group.trades.forEach(trade => {
                        if (trade.id && !countedIds.has(trade.id)) {
                            allTradesCount++;
                            countedIds.add(trade.id); // Prevent counting duplicates
                        }
                    });
                }
            });
            
            console.log('Updating tab badges:', { openCount, stockCount, groupsCount, allTradesCount });
            
            const tabOpenBadge = document.getElementById('tabOpenCount');
            const tabStockBadge = document.getElementById('tabStockCount');
            const tabGroupsBadge = document.getElementById('tabGroupsCount');
            const tabAllBadge = document.getElementById('tabAllCount');
            
            if (tabOpenBadge) {
                tabOpenBadge.textContent = openCount;
                console.log('Set open badge to:', openCount);
            }
            if (tabStockBadge) {
                tabStockBadge.textContent = stockCount;
                console.log('Set stock badge to:', stockCount);
            }
            if (tabGroupsBadge) {
                tabGroupsBadge.textContent = groupsCount;
                console.log('Set groups badge to:', groupsCount);
            }
            if (tabAllBadge) {
                tabAllBadge.textContent = allTradesCount;
                console.log('Set all trades badge to:', allTradesCount);
            }
        }

        function getClosedGroupsCount() {
            // Filter out any invalid groups
            const validGroups = tradeGroups.filter(g => g.trades && Array.isArray(g.trades) && g.trades.length > 0);
            
            // Filter groups to only count if there are NO open trades with the same Trade Ref #
            const closedGroups = validGroups.filter(group => {
                // Get Trade Ref # from group (check group name or first trade)
                let groupTradeRef = null;
                
                // Try to extract from group name "Trade Ref: XXX"
                if (group.name && group.name.startsWith('Trade Ref: ')) {
                    groupTradeRef = group.name.replace('Trade Ref: ', '');
                }
                
                // Fallback: get from first trade
                if (!groupTradeRef && group.trades && group.trades.length > 0) {
                    groupTradeRef = group.trades[0].tradeRef;
                }
                
                // If no Trade Ref, count the group (it's a manual group)
                if (!groupTradeRef || !groupTradeRef.trim()) {
                    return true;
                }
                
                // Check if there are any OPEN trades with this Trade Ref #
                const hasOpenTrades = trades.some(t => 
                    t.tradeRef && 
                    t.tradeRef.trim() === groupTradeRef.trim() && 
                    t.status === 'open'
                );
                
                // Only count group if there are NO open trades with this Trade Ref
                return !hasOpenTrades;
            });
            
            return closedGroups.length;
        }

        function populateDashboardAccountFilter() {
            const filterSelect = document.getElementById('dashboardAccountFilter');
            if (!filterSelect) return;
            
            // Get unique accounts from all trades
            const allTrades = [...trades, ...closedTrades];
            const accountsFromTrades = new Set();
            
            allTrades.forEach(trade => {
                if (trade.account && trade.account.trim() !== '') {
                    accountsFromTrades.add(trade.account.trim());
                }
            });
            
            // Combine with customAccounts to include all defined accounts
            const allAccountsSet = new Set([...accountsFromTrades, ...customAccounts]);
            
            // Sort accounts alphabetically
            const accounts = Array.from(allAccountsSet).sort();
            
            // Save current selection
            const currentValue = filterSelect.value;
            
            // Rebuild options
            filterSelect.innerHTML = '<option value="all">All Accounts</option>';
            accounts.forEach(account => {
                const option = document.createElement('option');
                option.value = account;
                option.textContent = account;
                filterSelect.appendChild(option);
            });
            
            // Restore selection if it still exists
            if (currentValue && Array.from(filterSelect.options).some(opt => opt.value === currentValue)) {
                filterSelect.value = currentValue;
            }
        }

        function updateDashboardMetrics() {
            try {
                // Populate account filter if not done yet
                populateDashboardAccountFilter();
                
                // Get selected account filter
                const accountFilter = document.getElementById('dashboardAccountFilter')?.value || 'all';
                
                // Filter trades by account
                const filterByAccount = (trade) => {
                    if (accountFilter === 'all') return true;
                    return trade.account === accountFilter;
                };
                
                // Calculate Win Rate based on CLOSED TRADE GROUPS
                let winningTrades = 0;
                let losingTrades = 0;
                let totalClosedGroups = 0;
                let bestTrade = 0;
                let worstTrade = 0;
                let totalClosedPL = 0;

                // Get all closed groups
                const closedGroups = tradeGroups.filter(group => {
                    // A group is closed if it has no open trades
                    const isClosed = !group.trades.some(t => trades.some(openTrade => openTrade.id === t.id));
                    
                    // Filter by account - check if any trade in group matches account
                    if (accountFilter !== 'all' && isClosed) {
                        return group.trades.some(t => t.account === accountFilter);
                    }
                    
                    return isClosed;
                });

                closedGroups.forEach(group => {
                    // Calculate total P&L for this group
                    let groupPL = 0;
                    let hasAssignment = false;
                    let hasCalledAway = false;
                    
                    group.trades.forEach(trade => {
                        if (trade.isAssignment) hasAssignment = true;
                        if (trade.isCalledAway) hasCalledAway = true;
                        
                        const pl = calculatePL(trade, true);
                        groupPL += pl;
                    });
                    
                    totalClosedGroups++;
                    totalClosedPL += groupPL;
                    
                    // Assignment or Called Away = Loss
                    if (hasAssignment || hasCalledAway) {
                        losingTrades++;
                    }
                    // Otherwise, check if net profit or loss
                    else if (groupPL > 0) {
                        winningTrades++;
                    } else if (groupPL < 0) {
                        losingTrades++;
                    }
                    // groupPL === 0 counts as neither win nor loss
                    
                    if (groupPL > bestTrade) bestTrade = groupPL;
                    if (groupPL < worstTrade) worstTrade = groupPL;
                });

                const winRate = totalClosedGroups > 0 ? ((winningTrades / totalClosedGroups) * 100).toFixed(1) : 0;
                const avgTradePL = totalClosedGroups > 0 ? (Math.round((totalClosedPL / totalClosedGroups) * 100) / 100).toFixed(2) : '0.00';

                // Update Win Rate
                document.getElementById('winRate').textContent = `${winRate}%`;
                document.getElementById('winRate').className = `metric-value-large ${parseFloat(winRate) >= 50 ? 'positive' : 'negative'}`;
                document.getElementById('winningTrades').textContent = winningTrades;
                document.getElementById('losingTrades').textContent = losingTrades;
                document.getElementById('totalClosedTrades').textContent = totalClosedGroups;

                // Calculate Average Days to Expiration (filter by account)
                let totalDTE = 0;
                let minDTE = Infinity;
                let maxDTE = -Infinity;
                let filteredTradesCount = 0;
                
                trades.filter(filterByAccount).forEach(trade => {
                    const dte = calculateDaysToExpiration(trade.expDate);
                    totalDTE += dte;
                    if (dte < minDTE) minDTE = dte;
                    if (dte > maxDTE) maxDTE = dte;
                    filteredTradesCount++;
                });

                const avgDTE = filteredTradesCount > 0 ? Math.round(totalDTE / filteredTradesCount) : 0;
                
                document.getElementById('avgDTE').textContent = avgDTE;
                document.getElementById('minDTE').textContent = filteredTradesCount > 0 ? minDTE : 0;
                document.getElementById('maxDTE').textContent = filteredTradesCount > 0 ? maxDTE : 0;

                // Calculate Portfolio Allocation (filter by account)
                const allocationBySymbol = {};
                let totalAllocation = 0;

                trades.filter(filterByAccount).forEach(trade => {
                    const cashReq = calculateCashRequired(trade);
                    if (!allocationBySymbol[trade.symbol]) {
                        allocationBySymbol[trade.symbol] = 0;
                    }
                    allocationBySymbol[trade.symbol] += cashReq;
                    totalAllocation += cashReq;
                });

                // Sort by allocation (highest first)
                const sortedAllocations = Object.entries(allocationBySymbol)
                    .sort((a, b) => b[1] - a[1]);

                // Render allocation list
                const allocationList = document.getElementById('allocationList');
                if (sortedAllocations.length === 0) {
                    allocationList.innerHTML = '<div style="color: #666; text-align: center; padding: 20px;">No open positions</div>';
                } else {
                    allocationList.innerHTML = sortedAllocations.map(([symbol, amount]) => {
                        const percent = ((amount / totalAllocation) * 100).toFixed(1);
                        return `
                            <div class="allocation-item">
                                <div>
                                    <span class="allocation-symbol">${symbol}</span>
                                    <div style="font-size: 0.85rem; color: #666; margin-top: 2px;">
                                        $${amount.toLocaleString()} at risk
                                    </div>
                                </div>
                                <div style="text-align: right;">
                                    <span class="allocation-percent">${percent}%</span>
                                    <div class="allocation-bar" style="width: 100px; margin-top: 4px;">
                                        <div class="allocation-fill" style="width: ${percent}%"></div>
                                    </div>
                                </div>
                            </div>
                        `;
                    }).join('');
                }

                // Update Quick Stats
                document.getElementById('bestTrade').textContent = `$${formatCurrency(bestTrade)}`;
                document.getElementById('worstTrade').textContent = `$${formatCurrency(worstTrade)}`;
                document.getElementById('avgTradePL').textContent = `$${avgTradePL}`;
                document.getElementById('avgTradePL').className = parseFloat(avgTradePL) >= 0 ? 'positive-value' : 'negative-value';
                
                // Update weekly premium section
                updateWeeklyPremium();

            } catch (error) {
                console.error('Error in updateDashboardMetrics:', error);
            }
        }

        function updateWeeklyPremium() {
            try {
                const weeklyData = calculateWeeklyPremium();
                const displayType = document.getElementById('weeklyDisplayType').value;
                
                // Hide all views
                document.getElementById('weeklyChartView').style.display = 'none';
                document.getElementById('weeklyTableView').style.display = 'none';
                document.getElementById('weeklyCardsView').style.display = 'none';
                
                // Show selected view
                if (displayType === 'chart') {
                    document.getElementById('weeklyChartView').style.display = 'block';
                    renderWeeklyChart(weeklyData);
                } else if (displayType === 'table') {
                    document.getElementById('weeklyTableView').style.display = 'block';
                    renderWeeklyTable(weeklyData);
                } else if (displayType === 'cards') {
                    document.getElementById('weeklyCardsView').style.display = 'block';
                    renderWeeklyCards(weeklyData);
                }
            } catch (error) {
                console.error('Error in updateWeeklyPremium:', error);
            }
        }

        function getWeekStart(date) {
            // Get Monday of the week containing this date
            const d = new Date(date);
            const day = d.getDay();
            const diff = d.getDate() - day + (day === 0 ? -6 : 1); // Adjust when day is Sunday
            const monday = new Date(d.setDate(diff));
            monday.setHours(0, 0, 0, 0);
            return monday;
        }

        function getWeekEnd(date) {
            // Get Friday of the week containing this date
            const monday = getWeekStart(date);
            const friday = new Date(monday);
            friday.setDate(monday.getDate() + 4); // Monday + 4 = Friday
            friday.setHours(23, 59, 59, 999);
            return friday;
        }

        function formatWeekRange(weekStart) {
            const weekEnd = getWeekEnd(weekStart);
            const formatDate = (d) => {
                const month = d.getMonth() + 1;
                const day = d.getDate();
                return `${month}/${day}`;
            };
            return `${formatDate(weekStart)} - ${formatDate(weekEnd)}`;
        }

        function calculateWeeklyPremium() {
            const accountFilter = document.getElementById('dashboardAccountFilter')?.value || 'all';
            const weeklyPremiums = {};
            const processedSells = new Set();
            
            const allSells = closedTrades.filter(t => t.action === 'sell' && !t.isClosingTrade);
            
            allSells.forEach(trade => {
                if (accountFilter !== 'all' && trade.account !== accountFilter) return;
                if (!trade.expDate) return;
                if (processedSells.has(trade.id)) return;
                
                if (trade.isRolled) {
                    // TODO: Add rolled trade logic here after Victor explains step by step
                    // Temporarily disabled to start fresh
                } else {
                    // NON-ROLLED TRADE
                    let netPremium = trade.premium * trade.contracts * 100;
                    
                    const buyback = closedTrades.find(t =>
                        t.isClosingTrade && t.action === 'buy' &&
                        t.tradeRef === trade.tradeRef && t.symbol === trade.symbol &&
                        Math.abs(new Date(t.dateClosed) - new Date(trade.dateClosed || trade.expDate)) < 86400000 * 3
                    );
                    
                    if (buyback) {
                        netPremium -= buyback.premium * buyback.contracts * 100;
                    }
                    
                    const targetWeek = buyback ? getWeekStart(trade.dateClosed) : getWeekStart(trade.expDate);
                    const weekKey = targetWeek.toISOString();
                    
                    if (!weeklyPremiums[weekKey]) {
                        weeklyPremiums[weekKey] = {
                            premium: 0,
                            trades: 0,
                            weekStart: targetWeek,
                            weekEnd: getWeekEnd(targetWeek)
                        };
                    }
                    weeklyPremiums[weekKey].premium += netPremium;
                    weeklyPremiums[weekKey].trades += 1;
                }
            });
            
            // Convert to array and sort by week
            let weeksArray = Object.values(weeklyPremiums).sort((a, b) => 
                a.weekStart - b.weekStart // Chronological (oldest first)
            );
            
            // Apply date range filter
            const rangeFilter = document.getElementById('weeklyRangeFilter').value;
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            const currentWeekStart = getWeekStart(today);
            
            let startWeek, endWeek;
            
            if (rangeFilter === 'prev4next4') {
                // Show previous 4 weeks and next 4 weeks (8 weeks total)
                startWeek = new Date(currentWeekStart);
                startWeek.setDate(startWeek.getDate() - (7 * 4)); // 4 weeks back
                
                endWeek = new Date(currentWeekStart);
                endWeek.setDate(endWeek.getDate() + (7 * 4)); // 4 weeks forward
                
                weeksArray = weeksArray.filter(w => 
                    w.weekStart >= startWeek && w.weekStart < endWeek
                );
            } else if (rangeFilter.startsWith('next')) {
                // Forward-looking: show only future weeks
                const weeksToShow = parseInt(rangeFilter.replace('next', ''));
                startWeek = new Date(currentWeekStart);
                endWeek = new Date(currentWeekStart);
                endWeek.setDate(endWeek.getDate() + (7 * weeksToShow));
                
                weeksArray = weeksArray.filter(w => w.weekStart >= currentWeekStart);
                weeksArray = weeksArray.slice(0, weeksToShow);
            } else if (rangeFilter !== 'all') {
                // Backward-looking: show only past weeks
                const weeksToShow = parseInt(rangeFilter);
                startWeek = new Date(currentWeekStart);
                startWeek.setDate(startWeek.getDate() - (7 * weeksToShow));
                endWeek = new Date(currentWeekStart);
                
                weeksArray = weeksArray.filter(w => w.weekStart < currentWeekStart);
                weeksArray = weeksArray.slice(-weeksToShow); // Get last N weeks
            }
            
            // Fill in missing weeks with $0 placeholders (only if not "all")
            if (rangeFilter !== 'all' && startWeek && endWeek) {
                const filledWeeks = [];
                const existingWeeksMap = {};
                
                // Map existing weeks by their ISO string
                weeksArray.forEach(w => {
                    existingWeeksMap[w.weekStart.toISOString()] = w;
                });
                
                // Generate all weeks in range
                let currentWeek = new Date(startWeek);
                while (currentWeek < endWeek) {
                    const weekKey = currentWeek.toISOString();
                    
                    if (existingWeeksMap[weekKey]) {
                        // Week has data
                        filledWeeks.push(existingWeeksMap[weekKey]);
                    } else {
                        // Week has no data - create placeholder
                        filledWeeks.push({
                            premium: 0,
                            trades: 0,
                            weekStart: new Date(currentWeek),
                            weekEnd: getWeekEnd(new Date(currentWeek))
                        });
                    }
                    
                    // Move to next week
                    currentWeek.setDate(currentWeek.getDate() + 7);
                }
                
                weeksArray = filledWeeks;
            }
            
            // Return in chronological order
            return weeksArray;
        }

        function renderWeeklyChart(weeklyData) {
            const chartContainer = document.getElementById('weeklyChart');
            
            if (weeklyData.length === 0) {
                chartContainer.innerHTML = '<div style="text-align: center; color: #666; padding: 40px;">No data available for selected range</div>';
                return;
            }
            
            const maxPremium = Math.max(...weeklyData.map(w => w.premium));
            const chartHeight = 250;
            
            let html = '<div style="display: flex; align-items: flex-end; justify-content: space-around; height: ' + chartHeight + 'px; gap: 10px; padding: 20px 0;">';
            
            weeklyData.forEach(week => {
                const barHeight = maxPremium > 0 ? (week.premium / maxPremium) * (chartHeight - 50) : 0;
                const color = week.premium >= 0 ? '#00ff88' : '#ff4444';
                const weekLabel = formatWeekRange(week.weekStart);
                
                html += `
                    <div style="flex: 1; display: flex; flex-direction: column; align-items: center; gap: 10px;">
                        <div style="font-size: 0.9rem; font-weight: 600; color: ${color};">
                            $${formatCurrency(week.premium).split('.')[0]}
                        </div>
                        <div style="width: 100%; background: ${color}; height: ${Math.abs(barHeight)}px; border-radius: 4px 4px 0 0; transition: all 0.3s; cursor: pointer;" title="${week.trades} trades">
                        </div>
                        <div style="font-size: 0.75rem; color: #666; text-align: center; writing-mode: horizontal-tb; transform: rotate(-45deg); white-space: nowrap; margin-top: 20px;">
                            ${weekLabel}
                        </div>
                    </div>
                `;
            });
            
            html += '</div>';
            chartContainer.innerHTML = html;
        }

        function renderWeeklyTable(weeklyData) {
            const tbody = document.getElementById('weeklyTableBody');
            
            if (weeklyData.length === 0) {
                tbody.innerHTML = '<tr><td colspan="5" style="text-align: center; color: #666; padding: 40px;">No data available for selected range</td></tr>';
                return;
            }
            
            // Calculate totals
            const totalPremium = weeklyData.reduce((sum, w) => sum + w.premium, 0);
            const totalTrades = weeklyData.reduce((sum, w) => sum + w.trades, 0);
            
            tbody.innerHTML = weeklyData.map(week => {
                const avgPerTrade = week.trades > 0 ? week.premium / week.trades : 0;
                const weekLabel = formatWeekRange(week.weekStart);
                const parts = weekLabel.split(' - ');
                
                return `
                    <tr>
                        <td>${parts[0]}</td>
                        <td>${parts[1]}</td>
                        <td class="${week.premium >= 0 ? 'positive-value' : 'negative-value'}" style="font-weight: 600;">
                            $${formatCurrency(week.premium)}
                        </td>
                        <td>${week.trades}</td>
                        <td>$${formatCurrency(avgPerTrade)}</td>
                    </tr>
                `;
            }).join('') + `
                <tr style="background: #1a1a1a; font-weight: bold; border-top: 2px solid #00ff88;">
                    <td colspan="2" style="text-align: right;">TOTALS:</td>
                    <td class="${totalPremium >= 0 ? 'positive-value' : 'negative-value'}">
                        $${formatCurrency(totalPremium)}
                    </td>
                    <td>${totalTrades}</td>
                    <td>$${formatCurrency(totalPremium / totalTrades)}</td>
                </tr>
            `;
        }

        function renderWeeklyCards(weeklyData) {
            const container = document.getElementById('weeklyCardsContainer');
            
            if (weeklyData.length === 0) {
                container.innerHTML = '<div style="text-align: center; color: #666; padding: 40px; grid-column: 1/-1;">No data available for selected range</div>';
                return;
            }
            
            container.innerHTML = weeklyData.map(week => {
                const weekLabel = formatWeekRange(week.weekStart);
                const avgPerTrade = week.trades > 0 ? week.premium / week.trades : 0;
                const color = week.premium >= 0 ? '#00ff88' : '#ff4444';
                
                return `
                    <div class="metric-card" style="border-left: 4px solid ${color};">
                        <div style="font-size: 0.85rem; color: #888; margin-bottom: 8px;">${weekLabel}</div>
                        <div style="font-size: 2rem; font-weight: 700; color: ${color}; margin-bottom: 10px;">
                            $${formatCurrency(week.premium).split('.')[0]}
                        </div>
                        <div style="font-size: 0.9rem; color: #666;">
                            ${week.trades} trade${week.trades !== 1 ? 's' : ''}<br>
                            <span style="color: #888;">Avg: $${formatCurrency(avgPerTrade)}</span>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function toggleTheme() {
            document.body.classList.toggle('light-mode');
            
            if (document.body.classList.contains('light-mode')) {
                localStorage.setItem('theme', 'light');
            } else {
                localStorage.setItem('theme', 'dark');
            }
        }

        function loadTheme() {
            const savedTheme = localStorage.getItem('theme');
            if (savedTheme === 'light') {
                document.body.classList.add('light-mode');
            }
        }

        function formatDate(dateString) {
            const date = new Date(dateString + 'T00:00:00');
            return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
        }

        function formatCurrency(amount) {
            // Format number with commas and 2 decimal places
            return amount.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
        }

        function editTrade(index) {
            editingIndex = index;
            editingFromArray = 'open';
            editingFromGroup = -1;
            populateEditModal(trades[index]);
            document.getElementById('editModal').classList.add('active');
        }

        function populateEditModal(trade) {
            document.getElementById('editTradeRef').value = trade.tradeRef || '';
            document.getElementById('editSymbol').value = trade.symbol;
            document.getElementById('editContracts').value = trade.contracts;
            document.getElementById('editStrike').value = trade.strike;
            document.getElementById('editPremium').value = trade.premium;
            document.getElementById('editAction').value = trade.action;
            document.getElementById('editType').value = trade.type;
            document.getElementById('editDateOpened').value = trade.dateOpened;
            document.getElementById('editExpDate').value = trade.expDate;
            document.getElementById('editPriceAtAction').value = trade.priceAtAction;
            document.getElementById('editInfo').value = trade.info || '';
        }

        function closeEditModal() {
            document.getElementById('editModal').classList.remove('active');
            editingIndex = -1;
            editingFromArray = 'open';
            editingFromGroup = -1;
        }

        function saveEdit() {
            if (editingIndex >= 0) {
                const updatedTrade = {
                    tradeRef: document.getElementById('editTradeRef').value.trim(),
                    symbol: document.getElementById('editSymbol').value.toUpperCase().trim(),
                    contracts: parseInt(document.getElementById('editContracts').value),
                    strike: parseFloat(document.getElementById('editStrike').value),
                    premium: parseFloat(document.getElementById('editPremium').value),
                    action: document.getElementById('editAction').value,
                    type: document.getElementById('editType').value,
                    dateOpened: document.getElementById('editDateOpened').value,
                    expDate: document.getElementById('editExpDate').value,
                    priceAtAction: parseFloat(document.getElementById('editPriceAtAction').value),
                    info: document.getElementById('editInfo').value
                };
                
                // Update groupId
                updatedTrade.groupId = `${updatedTrade.symbol}-${updatedTrade.strike}-${updatedTrade.type}-${updatedTrade.expDate}`;
                
                // Get the trade ID to sync across all arrays
                let tradeId;
                if (editingFromArray === 'open') {
                    tradeId = trades[editingIndex].id;
                } else if (editingFromArray === 'closed') {
                    tradeId = closedTrades[editingIndex].id;
                }
                
                // Sync changes across ALL arrays using the helper function
                if (tradeId) {
                    syncTradeAcrossAllArrays(tradeId, updatedTrade);
                }
                
                saveUserData();
                renderOpenTrades();
                renderStockPositions();
                if (currentTab === 'all') {
                    renderAllTrades();
                } else if (currentTab === 'groups') {
                    renderGroups();
                }
                updateStats();
                closeEditModal();
                alert('Trade updated successfully');
            }
        }

        function openCloseModal(index) {
            closingIndex = index;
            const trade = trades[index];
            document.getElementById('closeDate').value = new Date().toISOString().split('T')[0];
            document.getElementById('closingPremium').value = '0';
            document.getElementById('closingNotes').value = '';
            document.getElementById('closeModal').classList.add('active');
        }

        function closeCloseModal() {
            document.getElementById('closeModal').classList.remove('active');
            closingIndex = -1;
        }

        function openRollModal(index) {
            rollingIndex = index;
            const trade = trades[index];
            
            // Pre-fill with current values
            document.getElementById('rollCloseDate').value = new Date().toISOString().split('T')[0];
            document.getElementById('rollClosingPremium').value = '';
            document.getElementById('rollNewStrike').value = trade.strike;
            document.getElementById('rollNewPremium').value = '';
            document.getElementById('rollNewExpDate').value = '';
            document.getElementById('rollPriceAtAction').value = '';
            document.getElementById('rollNewType').value = trade.type;
            document.getElementById('rollNotes').value = '';
            
            document.getElementById('rollModal').classList.add('active');
        }

        function closeRollModal() {
            document.getElementById('rollModal').classList.remove('active');
            rollingIndex = -1;
        }

        function confirmRoll() {
            if (rollingIndex >= 0) {
                const originalTrade = trades[rollingIndex];
                const rollCloseDate = document.getElementById('rollCloseDate').value;
                const rollClosingPremium = parseFloat(document.getElementById('rollClosingPremium').value) || 0;
                const rollNewStrike = parseFloat(document.getElementById('rollNewStrike').value);
                const rollNewPremium = parseFloat(document.getElementById('rollNewPremium').value);
                const rollNewExpDate = document.getElementById('rollNewExpDate').value;
                const rollPriceAtAction = parseFloat(document.getElementById('rollPriceAtAction').value);
                const rollNewType = document.getElementById('rollNewType').value;
                const rollNotes = document.getElementById('rollNotes').value;
                
                // Minimal validation - only require strike and exp date
                if (!rollNewStrike || !rollNewExpDate) {
                    alert('Please enter at least a new strike and expiration date');
                    return;
                }
                
                // 1. Mark original trade as closed AND rolled
                originalTrade.status = 'closed';
                originalTrade.dateClosed = rollCloseDate;
                originalTrade.isRolled = true; // Mark as part of roll chain
                
                // 2. Create closing trade (buying back the original)
                const closingTrade = {
                    id: Date.now() + Math.random(),
                    tradeRef: originalTrade.tradeRef || '', // Inherit tradeRef
                    account: originalTrade.account || '', // Inherit account
                    groupId: originalTrade.groupId,
                    symbol: originalTrade.symbol,
                    contracts: originalTrade.contracts,
                    strike: originalTrade.strike,
                    premium: rollClosingPremium,
                    action: originalTrade.action === 'sell' ? 'buy' : 'sell',
                    type: originalTrade.type,
                    dateOpened: null, // BUY legs don't have open date for display
                    expDate: originalTrade.expDate, // Keep original expDate for weekly premium assignment!
                    priceAtAction: rollPriceAtAction,
                    info: rollNotes ? `Roll close: ${rollNotes}` : 'Rolled - closing leg',
                    status: 'closed',
                    dateClosed: rollCloseDate, // Only closed date matters for buybacks
                    isClosingTrade: true,
                    isRolled: true // Mark as part of roll chain
                };
                
                // 3. Create new opening trade (selling the new option)
                const newOpeningTrade = {
                    id: Date.now() + Math.random() + 1,
                    tradeRef: originalTrade.tradeRef || '', // Inherit tradeRef
                    account: originalTrade.account || '', // Inherit account
                    groupId: `${originalTrade.symbol}-${rollNewStrike}-${rollNewType}-${rollNewExpDate}`,
                    symbol: originalTrade.symbol,
                    contracts: originalTrade.contracts,
                    strike: rollNewStrike,
                    premium: rollNewPremium || 0,
                    action: 'sell',
                    type: rollNewType,
                    dateOpened: rollCloseDate,
                    expDate: rollNewExpDate,
                    priceAtAction: rollPriceAtAction || 0,
                    info: rollNotes ? `Rolled: ${rollNotes}` : 'Rolled - new leg',
                    status: 'open',
                    isRolled: true // Mark this position as rolled
                };
                
                // Move original and closing to closed trades
                closedTrades.push(originalTrade);
                closedTrades.push(closingTrade);
                
                // Remove original from open trades
                trades.splice(rollingIndex, 1);
                
                // Add new opening trade to open trades
                trades.push(newOpeningTrade);
                
                // Find existing group with same Trade Ref # or create new one
                let existingGroup = null;
                if (originalTrade.tradeRef && originalTrade.tradeRef.trim()) {
                    // Look for a group containing trades with the same tradeRef
                    existingGroup = tradeGroups.find(g => 
                        g.trades && g.trades.some(t => t.tradeRef === originalTrade.tradeRef)
                    );
                }
                
                if (existingGroup) {
                    // Add to existing group (only the closed trades, not the new opening trade)
                    console.log('Adding roll to existing group:', existingGroup.name);
                    existingGroup.trades.push(originalTrade);
                    existingGroup.trades.push(closingTrade);
                    // Don't add newOpeningTrade to group - it stays in the open trades array
                } else {
                    // Create a new trade group for the roll (only closed trades)
                    console.log('Creating new roll group');
                    const rollGroup = {
                        id: Date.now(),
                        name: originalTrade.tradeRef ? `Trade Ref: ${originalTrade.tradeRef}` : `${originalTrade.symbol} Roll - ${originalTrade.strike} to ${rollNewStrike} ${rollNewType.toUpperCase()}`,
                        trades: [originalTrade, closingTrade],
                        created: new Date().toISOString()
                    };
                    
                    tradeGroups.push(rollGroup);
                }
                
                saveData();
                renderOpenTrades();
                if (currentTab === 'all') {
                    renderAllTrades();
                } else if (currentTab === 'groups') {
                    renderGroups();
                }
                updateStats();
                updateLastRefDisplay();
                closeRollModal();
                alert('Position rolled successfully! Check Closed Groups to see the complete roll.');
            }
        }

        function confirmClose() {
            if (closingIndex < 0) {
                alert('Error: No trade selected to close');
                return;
            }
            
            if (closingIndex >= trades.length) {
                alert('Error: Trade index out of bounds');
                return;
            }
            
            const openingTrade = trades[closingIndex];
            const closeDate = document.getElementById('closeDate').value;
            const closingPremium = parseFloat(document.getElementById('closingPremium').value) || 0;
            const closingNotes = document.getElementById('closingNotes').value;
            
            if (!closeDate) {
                alert('Please enter a close date');
                return;
            }
            
            console.log('Closing trade:', openingTrade);
            console.log('Close date:', closeDate, 'Closing premium:', closingPremium);
            
            // Mark the original trade as closed
            openingTrade.status = 'closed';
            openingTrade.dateClosed = closeDate;
            openingTrade.closePrice = closingPremium;
            
            // Create a separate closing trade entry (buying back the option)
            const closingTrade = {
                id: Date.now() + Math.random(),
                tradeRef: openingTrade.tradeRef || '', // Inherit tradeRef
                account: openingTrade.account || '', // Inherit account
                groupId: openingTrade.groupId,
                symbol: openingTrade.symbol,
                contracts: openingTrade.contracts,
                strike: openingTrade.strike,
                premium: closingPremium,
                action: openingTrade.action === 'sell' ? 'buy' : 'sell', // Opposite action
                type: openingTrade.type,
                dateOpened: closeDate,
                expDate: openingTrade.expDate,
                priceAtAction: openingTrade.priceAtAction,
                info: closingNotes || 'Closing trade',
                status: 'closed',
                dateClosed: closeDate,
                isClosingTrade: true,
                isRolled: openingTrade.isRolled || false, // Inherit rolled status from opening trade
                isCoveredCall: openingTrade.isCoveredCall || false,
                linkedStockId: openingTrade.linkedStockId
            };
            
            // Move opening trade to closed trades
            closedTrades.push(openingTrade);
            
            // Add closing trade to closed trades
            closedTrades.push(closingTrade);
            
            // Remove from open trades
            trades.splice(closingIndex, 1);
            
            console.log('Trade closed and moved to closedTrades');
            console.log('Open trades remaining:', trades.length);
            
            // If this was a covered call, update the stock position
            if (openingTrade.isCoveredCall && openingTrade.linkedStockId) {
                const stock = stockPositions.find(s => s.id === openingTrade.linkedStockId);
                if (stock && stock.coveredCalls) {
                    // Find and mark the call as closed in the stock's coveredCalls array
                    const callInStock = stock.coveredCalls.find(c => 
                        c.strike === openingTrade.strike && 
                        c.expDate === openingTrade.expDate &&
                        c.dateOpened === openingTrade.dateOpened
                    );
                    if (callInStock) {
                        callInStock.status = 'closed';
                        callInStock.dateClosed = closeDate;
                        callInStock.closePrice = closingPremium;
                        console.log('Updated covered call status in stock position');
                    }
                }
            }
            
            // Find existing group with same Trade Ref # or create new one
            let existingGroup = null;
            if (openingTrade.tradeRef && openingTrade.tradeRef.trim()) {
                // Look for a group containing trades with the same tradeRef
                existingGroup = tradeGroups.find(g => 
                    g.trades && g.trades.some(t => t.tradeRef === openingTrade.tradeRef)
                );
            }
            
            if (existingGroup) {
                // Add to existing group
                console.log('Adding close to existing group:', existingGroup.name);
                existingGroup.trades.push(openingTrade);
                existingGroup.trades.push(closingTrade);
            } else {
                // Auto-create a new trade group with both trades
                console.log('Creating new close group');
                const group = {
                    id: Date.now(),
                    name: openingTrade.tradeRef ? `Trade Ref: ${openingTrade.tradeRef}` : `${openingTrade.symbol} ${openingTrade.strike} ${openingTrade.type.toUpperCase()} - ${formatDate(openingTrade.dateOpened)} to ${formatDate(closeDate)}`,
                    trades: [openingTrade, closingTrade],
                    created: new Date().toISOString()
                };
                
                tradeGroups.push(group);
            }
            
            saveData();
            renderTables();
            renderOpenTrades();
            renderStockPositions(); // Update stock positions in case it was a covered call
            if (currentTab === 'all') {
                renderAllTrades();
            } else if (currentTab === 'groups') {
                renderGroups();
            }
            updateStats();
            updateLastRefDisplay();
            closeCloseModal();
            
            alert('‚úÖ Position closed successfully!\n\nThe trade has been moved to closed trades and grouped appropriately.');
        }

        function reopenTrade(index) {
            if (confirm('Reopen this position?')) {
                const trade = closedTrades[index];
                trade.status = 'open';
                delete trade.dateClosed;
                delete trade.closingPremium;
                delete trade.closingNotes;
                
                trades.push(trade);
                closedTrades.splice(index, 1);
                
                saveData();
                renderTables();
                updateStats();
            }
        }

        function removeTradeFromAllGroups(tradeToRemove) {
            // Find and remove this trade from all groups
            tradeGroups.forEach((group, groupIndex) => {
                if (!group.trades || !Array.isArray(group.trades)) return;
                
                // Find matching trade in this group
                const tradeIndex = group.trades.findIndex(t => 
                    t.symbol === tradeToRemove.symbol && 
                    t.dateOpened === tradeToRemove.dateOpened && 
                    t.strike === tradeToRemove.strike &&
                    t.premium === tradeToRemove.premium &&
                    t.action === tradeToRemove.action
                );
                
                if (tradeIndex !== -1) {
                    console.log('Removing trade from group:', group.name);
                    group.trades.splice(tradeIndex, 1);
                    
                    // If group is now empty, remove the entire group
                    if (group.trades.length === 0) {
                        console.log('Group is empty, removing group:', group.name);
                        tradeGroups.splice(groupIndex, 1);
                    }
                }
            });
        }

        let assigningIndex = -1;

        function assignStock(index) {
            assigningIndex = index;
            const put = trades[index];
            
            // Pre-fill modal
            document.getElementById('assignDate').value = new Date().toISOString().split('T')[0];
            document.getElementById('assignmentPrice').value = put.strike;
            document.getElementById('assignmentNotes').value = '';
            
            // Show modal
            document.getElementById('assignModal').style.display = 'flex';
        }

        function closeAssignModal() {
            document.getElementById('assignModal').style.display = 'none';
            assigningIndex = -1;
        }

        let sellingCallForStock = -1;

        function openSellCallModal(stockIndex) {
            sellingCallForStock = stockIndex;
            const stock = stockPositions[stockIndex];
            
            // Pre-fill modal
            document.getElementById('callDateOpened').value = new Date().toISOString().split('T')[0];
            document.getElementById('callExpDate').value = '';
            document.getElementById('callStrike').value = stock.costBasis;
            document.getElementById('callPremium').value = '';
            document.getElementById('callNotes').value = '';
            
            // Show modal
            document.getElementById('sellCallModal').style.display = 'flex';
        }

        function closeSellCallModal() {
            document.getElementById('sellCallModal').style.display = 'none';
            sellingCallForStock = -1;
        }

        function confirmSellCall() {
            console.log('confirmSellCall called, sellingCallForStock:', sellingCallForStock);
            
            if (sellingCallForStock < 0) {
                console.log('No stock selected');
                alert('Error: No stock position selected');
                return;
            }
            
            const stock = stockPositions[sellingCallForStock];
            console.log('Stock:', stock);
            
            const strike = parseFloat(document.getElementById('callStrike').value);
            const premium = parseFloat(document.getElementById('callPremium').value);
            const expDate = document.getElementById('callExpDate').value;
            const dateOpened = document.getElementById('callDateOpened').value;
            const notes = document.getElementById('callNotes').value;
            
            console.log('Values:', {strike, premium, expDate, dateOpened, notes});
            
            if (!strike || strike <= 0) {
                alert('Please enter a valid strike price');
                return;
            }
            if (!premium || premium < 0) {
                alert('Please enter a valid premium (use 0 if no premium collected)');
                return;
            }
            if (!expDate) {
                alert('Please select an expiration date');
                return;
            }
            if (!dateOpened) {
                alert('Please select the date the call was opened');
                return;
            }
            
            const contracts = stock.shares / 100;
            const premiumTotal = premium * contracts * 100;
            
            // Add to stock's covered calls array
            const call = {
                id: Date.now(),
                strike: strike,
                premium: premiumTotal,
                premiumPerShare: premium,
                expDate: expDate,
                dateOpened: dateOpened,
                notes: notes,
                status: 'open'
            };
            stock.coveredCalls.push(call);
            console.log('Added call to stock.coveredCalls:', call);
            
            // Create call trade for All Trades tracking AND open positions
            const callTrade = {
                id: Date.now() + Math.random(),
                symbol: stock.symbol,
                action: 'sell',
                type: 'call',
                contracts: contracts,
                strike: strike,
                premium: premium,
                dateOpened: dateOpened,
                expDate: expDate,
                priceAtAction: stock.assignedPrice || stock.costBasis,
                tradeRef: stock.tradeRef || '',
                account: stock.account || '',
                info: notes || `Covered call on ${stock.shares} shares`,
                status: 'open',
                isCoveredCall: true,
                linkedStockId: stock.id,
                linkedStockPositionIndex: sellingCallForStock
            };
            trades.push(callTrade);
            console.log('Added call trade to trades array:', callTrade);
            console.log('Total trades now:', trades.length);
            
            // Save and render
            saveData();
            closeSellCallModal();
            renderTables();
            renderStockPositions();
            updateStats();
            
            alert(`‚úÖ Covered Call Sold!\n\n${contracts} call contract(s) at $${strike.toFixed(2)}\nPremium: $${formatCurrency(premiumTotal)}\n\nThe call now appears in:\n- Stock Positions (covered calls)\n- Open Positions\n- All Trades`);
        }

        function confirmAssign() {
            if (assigningIndex < 0) return;
            
            const put = trades[assigningIndex];
            const assignDate = document.getElementById('assignDate').value;
            const assignmentPrice = parseFloat(document.getElementById('assignmentPrice').value);
            const assignmentNotes = document.getElementById('assignmentNotes').value;
            
            if (!assignDate || !assignmentPrice || assignmentPrice <= 0) {
                alert('Please enter valid assignment date and price');
                return;
            }
            
            // Create stock position
            const stockPosition = {
                id: Date.now(),
                symbol: put.symbol,
                shares: put.contracts * 100,
                costBasis: put.strike,
                assignedPrice: assignmentPrice,
                totalCost: put.strike * put.contracts * 100,
                totalValue: assignmentPrice * put.contracts * 100,
                assignedDate: assignDate,
                originalPutId: put.id,
                originalPut: {
                    strike: put.strike,
                    premium: put.premium,
                    contracts: put.contracts,
                    dateOpened: put.dateOpened,
                    tradeRef: put.tradeRef,
                    premiumCollected: put.premium * put.contracts * 100
                },
                coveredCalls: [],
                account: put.account || '',
                tradeRef: put.tradeRef || '',
                status: 'holding'
            };
            
            // Mark put as assigned
            put.status = 'assigned';
            put.dateClosed = assignDate;
            put.assignmentPrice = assignmentPrice;
            put.closingNotes = assignmentNotes || `Stock assigned at $${assignmentPrice.toFixed(2)}`;
            
            // Move put to closed trades
            closedTrades.push(put);
            trades.splice(assigningIndex, 1);
            
            // Add to stock positions
            stockPositions.push(stockPosition);
            
            // Create "ASSIGNMENT" trade entry for All Trades tracking
            const assignmentTrade = {
                id: Date.now() + Math.random(),
                symbol: put.symbol,
                action: 'assignment',
                type: 'stock',
                contracts: put.contracts,
                shares: put.contracts * 100,
                strike: put.strike,
                assignedPrice: assignmentPrice,
                premium: 0,
                priceAtAction: assignmentPrice,
                dateOpened: assignDate,
                expDate: assignDate,
                tradeRef: put.tradeRef,
                account: put.account,
                info: assignmentNotes || `Assigned ${put.contracts * 100} shares at $${assignmentPrice.toFixed(2)}`,
                status: 'closed',
                dateClosed: assignDate,
                isAssignment: true
            };
            closedTrades.push(assignmentTrade);
            
            // Save and render
            saveData();
            renderTables();
            renderStockPositions();
            updateStats();
            closeAssignModal();
            
            alert(`${stockPosition.shares} shares of ${stockPosition.symbol} assigned at $${assignmentPrice.toFixed(2)} per share!`);
        }

        // Called Out Functions
        let callingOutIndex = -1;

        function openCalledOutModal(index) {
            callingOutIndex = index;
            const call = trades[index];
            
            // Pre-fill with today's date and strike price
            document.getElementById('calledOutDate').value = new Date().toISOString().split('T')[0];
            document.getElementById('calledOutPrice').value = call.strike;
            document.getElementById('calledOutNotes').value = '';
            
            document.getElementById('calledOutModal').classList.add('active');
        }

        function closeCalledOutModal() {
            document.getElementById('calledOutModal').classList.remove('active');
            callingOutIndex = -1;
        }

        function calledOutFromAll(index) {
            // Find the actual trade in the trades array
            const allTrades = [...trades, ...closedTrades.filter(t => !t.isClosingTrade)];
            const trade = allTrades[index];
            
            if (!trade) {
                alert('Trade not found');
                return;
            }
            
            // Find index in trades array
            const tradeIndex = trades.findIndex(t => t.id === trade.id);
            if (tradeIndex >= 0) {
                openCalledOutModal(tradeIndex);
            } else {
                alert('Can only call out open positions');
            }
        }

        function confirmCalledOut() {
            if (callingOutIndex < 0) return;
            
            const call = trades[callingOutIndex];
            const calledOutDate = document.getElementById('calledOutDate').value;
            const calledOutPrice = parseFloat(document.getElementById('calledOutPrice').value);
            const calledOutNotes = document.getElementById('calledOutNotes').value;
            
            if (!calledOutDate || !calledOutPrice || calledOutPrice <= 0) {
                alert('Please enter valid date and price');
                return;
            }
            
            // Mark call as closed and called away
            call.status = 'closed';
            call.dateClosed = calledOutDate;
            call.calledOutPrice = calledOutPrice;
            call.closingNotes = calledOutNotes || `Stock called away at $${calledOutPrice.toFixed(2)}`;
            call.isCalledAway = true;
            
            // Move call to closed trades
            closedTrades.push(call);
            trades.splice(callingOutIndex, 1);
            
            // Create "CALLED AWAY" trade entry for tracking
            const calledAwayTrade = {
                id: Date.now() + Math.random(),
                symbol: call.symbol,
                action: 'called_away',
                type: 'stock',
                contracts: call.contracts,
                shares: call.contracts * 100,
                strike: call.strike,
                calledOutPrice: calledOutPrice,
                premium: 0,
                priceAtAction: calledOutPrice,
                dateOpened: calledOutDate,
                expDate: calledOutDate,
                tradeRef: call.tradeRef,
                account: call.account,
                info: calledOutNotes || `${call.contracts * 100} shares called away at $${calledOutPrice.toFixed(2)}`,
                status: 'closed',
                dateClosed: calledOutDate,
                isCalledAway: true
            };
            closedTrades.push(calledAwayTrade);
            
            // Save and render
            saveUserData();
            renderOpenTrades();
            renderAllTrades();
            updateStats();
            closeCalledOutModal();
            
            alert(`${call.contracts * 100} shares of ${call.symbol} called away at $${calledOutPrice.toFixed(2)} per share!`);
        }

        function renderStockPositions() {
            const tbody = document.getElementById('stockPositionsBody');
            if (!tbody) {
                console.error('Stock Positions tbody not found!');
                return;
            }
            
            console.log('Rendering Stock Positions, count:', stockPositions.length);
            console.log('Stock Positions data:', stockPositions);
            
            if (stockPositions.length === 0) {
                tbody.innerHTML = `
                    <tr>
                        <td colspan="10" style="text-align: center; color: #666; padding: 40px;">
                            No stock positions yet. Assign a put to create a stock position.
                        </td>
                    </tr>
                `;
                return;
            }
            
            tbody.innerHTML = stockPositions.map((stock, index) => {
                // Safety checks for missing data
                if (!stock.coveredCalls) stock.coveredCalls = [];
                if (!stock.originalPut) {
                    console.error('Stock position missing originalPut:', stock);
                    return '';
                }
                
                const callsCount = stock.coveredCalls.length;
                const totalCallPremiums = stock.coveredCalls.reduce((sum, call) => sum + call.premium, 0);
                const putPremium = stock.originalPut.premiumCollected || 0;
                const runningPL = putPremium + totalCallPremiums;
                
                // Build covered calls list
                let callsList = '';
                if (callsCount > 0) {
                    callsList = stock.coveredCalls.map(call => `
                        <div style="padding: 5px 0; border-bottom: 1px solid #333;">
                            <strong>$${call.strike.toFixed(2)} Call</strong> - 
                            Exp: ${formatDate(call.expDate)} - 
                            <span style="color: #00ff88;">+$${formatCurrency(call.premium)}</span>
                            ${call.notes ? `<br><span style="font-size: 0.8rem; color: #888;">${call.notes}</span>` : ''}
                        </div>
                    `).join('');
                }
                
                return `
                    <tr>
                        <td>${makeSymbolClickable(stock.symbol, false)}</td>
                        <td><strong>${stock.shares}</strong></td>
                        <td>$${stock.costBasis.toFixed(2)}</td>
                        <td><strong style="color: #ff8844;">$${stock.assignedPrice.toFixed(2)}</strong></td>
                        <td><strong>$${stock.totalValue.toLocaleString()}</strong></td>
                        <td>${formatDate(stock.assignedDate)}</td>
                        <td>
                            <div style="padding: 5px; background: #1a1a1a; border-radius: 4px; margin-bottom: 5px;">
                                <strong style="color: #888;">Original PUT</strong><br>
                                Strike: $${stock.originalPut.strike.toFixed(2)}<br>
                                Premium: <span style="color: #00ff88;">+$${formatCurrency(stock.originalPut.premiumCollected)}</span><br>
                                Opened: ${formatDate(stock.originalPut.dateOpened)}<br>
                                <span style="font-size: 0.8rem; color: #888;">Ref: ${stock.originalPut.tradeRef || '-'}</span>
                            </div>
                        </td>
                        <td>
                            <div style="max-height: 200px; overflow-y: auto;">
                                ${callsCount > 0 ? `
                                    <strong style="color: #4488ff;">${callsCount} Covered Call${callsCount !== 1 ? 's' : ''}</strong><br>
                                    <strong style="color: #00ff88;">Total: +$${totalCallPremiums.toFixed(2)}</strong>
                                    <div style="margin-top: 5px; font-size: 0.85rem;">
                                        ${callsList}
                                    </div>
                                ` : '<span style="color: #666;">No calls yet</span>'}
                            </div>
                        </td>
                        <td>${stock.account || '-'}</td>
                        <td>
                            <div class="action-buttons">
                                <button class="btn-small" style="background: #4488ff; color: #fff;" onclick="openSellCallModal(${index})">Sell Call</button>
                                <button class="btn-small" style="background: #00ff88; color: #000;" onclick="calledAway(${index})">Called Away</button>
                                <button class="btn-small danger" onclick="deleteStockPosition(${index})">Delete</button>
                            </div>
                            <div style="margin-top: 8px; font-size: 0.9rem; padding: 5px; background: #1a1a1a; border-radius: 4px;">
                                <strong class="${runningPL >= 0 ? 'positive-value' : 'negative-value'}">
                                    Running P&L: ${runningPL >= 0 ? '+' : ''}$${formatCurrency(runningPL)}
                                </strong>
                            </div>
                        </td>
                    </tr>
                `;
            }).join('');
        }

        let callingAwayStock = -1;

        function calledAway(index) {
            callingAwayStock = index;
            const stock = stockPositions[index];
            
            // Pre-fill modal
            document.getElementById('calledAwayDate').value = new Date().toISOString().split('T')[0];
            document.getElementById('salePrice').value = stock.costBasis;
            document.getElementById('calledAwayNotes').value = '';
            
            // Show modal
            document.getElementById('calledAwayModal').style.display = 'flex';
        }

        function closeCalledAwayModal() {
            document.getElementById('calledAwayModal').style.display = 'none';
            callingAwayStock = -1;
        }

        function confirmCalledAway() {
            if (callingAwayStock < 0) return;
            
            const stock = stockPositions[callingAwayStock];
            const calledAwayDate = document.getElementById('calledAwayDate').value;
            const salePriceNum = parseFloat(document.getElementById('salePrice').value);
            const notes = document.getElementById('calledAwayNotes').value;
            
            if (!calledAwayDate || !salePriceNum || salePriceNum <= 0) {
                alert('Please enter valid date and sale price');
                return;
            }
            
            // Calculate full cycle P&L
            const putPremium = stock.originalPut.premiumCollected;
            const callPremiums = stock.coveredCalls.reduce((sum, call) => sum + call.premium, 0);
            const stockProfit = (salePriceNum - stock.assignedPrice) * stock.shares;
            const totalPL = putPremium + callPremiums + stockProfit;
            
            // Close any open covered calls (they're being exercised)
            // Method 1: Find by linkedStockId
            let openCoveredCalls = trades.filter(t => 
                t.linkedStockId === stock.id &&
                t.type === 'call' &&
                t.action === 'sell' &&
                t.isCoveredCall
            );
            
            // Method 2: If no calls found by ID, find by symbol and tradeRef
            if (openCoveredCalls.length === 0 && stock.tradeRef) {
                openCoveredCalls = trades.filter(t => 
                    t.symbol === stock.symbol &&
                    t.type === 'call' &&
                    t.action === 'sell' &&
                    t.isCoveredCall &&
                    t.tradeRef === stock.tradeRef
                );
            }
            
            // Method 3: If still no calls found, find by symbol only (less safe but catches edge cases)
            if (openCoveredCalls.length === 0) {
                openCoveredCalls = trades.filter(t => 
                    t.symbol === stock.symbol &&
                    t.type === 'call' &&
                    t.action === 'sell' &&
                    t.isCoveredCall
                );
            }
            
            console.log(`Found ${openCoveredCalls.length} open covered calls for ${stock.symbol}:`, openCoveredCalls);
            
            // Close each covered call
            openCoveredCalls.forEach(call => {
                console.log('Closing call:', call);
                
                // Mark call as closed (exercised)
                call.status = 'closed';
                call.dateClosed = calledAwayDate;
                call.closingNotes = `Exercised - Stock called away at $${salePriceNum.toFixed(2)}`;
                call.closePrice = 0; // No cost to close, stock was called away
                
                // Move to closed trades
                closedTrades.push(call);
            });
            
            // Remove closed calls from open trades array
            openCoveredCalls.forEach(call => {
                const callIndex = trades.findIndex(t => t.id === call.id);
                if (callIndex >= 0) {
                    console.log('Removing call from trades at index:', callIndex);
                    trades.splice(callIndex, 1);
                } else {
                    console.log('Warning: Could not find call in trades array:', call);
                }
            });
            
            console.log(`Closed and removed ${openCoveredCalls.length} covered calls`);
            console.log('Remaining open trades:', trades.length);
            
            // Create "CALLED AWAY" trade entry
            const calledAwayTrade = {
                id: Date.now() + Math.random(),
                symbol: stock.symbol,
                action: 'called-away',
                type: 'stock',
                contracts: stock.shares / 100,
                shares: stock.shares,
                strike: salePriceNum,
                premium: 0,
                priceAtAction: salePriceNum,
                dateOpened: calledAwayDate,
                expDate: calledAwayDate,
                tradeRef: stock.tradeRef,
                account: stock.account,
                info: notes || `Called away at $${salePriceNum.toFixed(2)} - Total P&L: $${totalPL.toFixed(2)}`,
                status: 'closed',
                dateClosed: calledAwayDate,
                isCalledAway: true,
                fullCyclePL: totalPL,
                cycleDetails: {
                    putPremium: putPremium,
                    callPremiums: callPremiums,
                    stockProfit: stockProfit,
                    assignedPrice: stock.assignedPrice,
                    salePrice: salePriceNum
                }
            };
            closedTrades.push(calledAwayTrade);
            
            // Create or update Closed Group with ALL wheel cycle trades
            if (stock.tradeRef && stock.tradeRef.trim()) {
                // Find all trades related to this wheel cycle by Trade Ref
                const wheelTrades = [];
                
                // 1. Find the original assigned PUT
                const assignedPut = closedTrades.find(t => 
                    t.symbol === stock.symbol &&
                    t.type === 'put' &&
                    t.status === 'assigned' &&
                    t.tradeRef === stock.tradeRef
                );
                if (assignedPut) wheelTrades.push(assignedPut);
                
                // 2. Find the ASSIGNMENT trade
                const assignmentTrade = closedTrades.find(t =>
                    t.symbol === stock.symbol &&
                    t.isAssignment &&
                    t.tradeRef === stock.tradeRef
                );
                if (assignmentTrade) wheelTrades.push(assignmentTrade);
                
                // 3. Find all covered CALL trades for this symbol/tradeRef
                const coveredCalls = closedTrades.filter(t =>
                    t.symbol === stock.symbol &&
                    t.type === 'call' &&
                    t.action === 'sell' &&
                    t.tradeRef === stock.tradeRef &&
                    !t.isClosingTrade // Exclude closing trades (buy backs)
                );
                wheelTrades.push(...coveredCalls);
                
                // 4. Add the CALLED AWAY trade
                wheelTrades.push(calledAwayTrade);
                
                // Find existing group or create new one
                let existingGroup = tradeGroups.find(g => 
                    g.trades && g.trades.some(t => t.tradeRef === stock.tradeRef)
                );
                
                if (existingGroup) {
                    // Add missing trades to existing group
                    console.log('Adding wheel cycle trades to existing group:', existingGroup.name);
                    wheelTrades.forEach(wt => {
                        if (!existingGroup.trades.find(et => et.id === wt.id)) {
                            existingGroup.trades.push(wt);
                        }
                    });
                } else {
                    // Create new wheel cycle group
                    console.log('Creating new wheel cycle group for Trade Ref:', stock.tradeRef);
                    const newGroup = {
                        id: Date.now(),
                        name: `Trade Ref: ${stock.tradeRef} - Full Wheel Cycle`,
                        trades: wheelTrades,
                        symbol: stock.symbol,
                        dateOpened: stock.originalPut.dateOpened,
                        dateClosed: calledAwayDate
                    };
                    tradeGroups.push(newGroup);
                }
            }
            
            // Remove from active positions
            stockPositions.splice(callingAwayStock, 1);
            
            // Save and render
            saveData();
            closeCalledAwayModal();
            renderStockPositions();
            renderGroups();
            updateStats();
            
            alert(`‚úÖ Stock Called Away!\n\n` +
                  `Symbol: ${stock.symbol}\n` +
                  `Shares: ${stock.shares}\n` +
                  `Assigned Price: $${stock.assignedPrice.toFixed(2)}\n` +
                  `Sale Price: $${salePriceNum.toFixed(2)}\n\n` +
                  `Put Premium: +$${formatCurrency(putPremium)}\n` +
                  `Call Premiums: +$${formatCurrency(callPremiums)}\n` +
                  `Stock Profit: ${stockProfit >= 0 ? '+' : ''}$${formatCurrency(Math.abs(stockProfit))}\n\n` +
                  `üí∞ Total Wheel Cycle P&L: ${totalPL >= 0 ? '+' : ''}$${formatCurrency(Math.abs(totalPL))}\n\n` +
                  `Check All Trades > Assigned filter to see complete cycle!`);
        }

        function deleteStockPosition(index) {
            if (!confirm('Delete this stock position? This will also remove all related trades (assigned put, assignment, covered calls).')) return;
            
            const stock = stockPositions[index];
            console.log('Deleting stock position:', stock);
            
            // 1. Delete the original assigned PUT from closedTrades
            const assignedPutIndex = closedTrades.findIndex(t => 
                t.id === stock.originalPutId || 
                (t.symbol === stock.symbol && 
                 t.type === 'put' && 
                 t.status === 'assigned' && 
                 t.tradeRef === stock.tradeRef)
            );
            if (assignedPutIndex !== -1) {
                console.log('Removing assigned PUT from closedTrades');
                closedTrades.splice(assignedPutIndex, 1);
            }
            
            // 2. Delete the ASSIGNMENT trade from closedTrades
            const assignmentTradeIndex = closedTrades.findIndex(t => 
                t.symbol === stock.symbol && 
                t.isAssignment && 
                t.tradeRef === stock.tradeRef
            );
            if (assignmentTradeIndex !== -1) {
                console.log('Removing ASSIGNMENT trade from closedTrades');
                closedTrades.splice(assignmentTradeIndex, 1);
            }
            
            // 3. Delete all covered CALLS related to this stock (both open and closed)
            // Remove from open trades
            let removedOpenCalls = 0;
            for (let i = trades.length - 1; i >= 0; i--) {
                const t = trades[i];
                if (t.linkedStockId === stock.id || 
                    (t.symbol === stock.symbol && 
                     t.type === 'call' && 
                     t.action === 'sell' && 
                     t.isCoveredCall && 
                     t.tradeRef === stock.tradeRef)) {
                    console.log('Removing open covered CALL:', t);
                    trades.splice(i, 1);
                    removedOpenCalls++;
                }
            }
            
            // Remove from closed trades
            let removedClosedCalls = 0;
            for (let i = closedTrades.length - 1; i >= 0; i--) {
                const t = closedTrades[i];
                if (t.linkedStockId === stock.id || 
                    (t.symbol === stock.symbol && 
                     t.type === 'call' && 
                     t.action === 'sell' && 
                     t.isCoveredCall && 
                     t.tradeRef === stock.tradeRef)) {
                    console.log('Removing closed covered CALL:', t);
                    closedTrades.splice(i, 1);
                    removedClosedCalls++;
                }
            }
            
            // 4. Remove all these trades from any groups
            if (stock.tradeRef && stock.tradeRef.trim()) {
                tradeGroups.forEach((group, groupIndex) => {
                    if (!group.trades || !Array.isArray(group.trades)) return;
                    
                    // Remove all trades with this tradeRef
                    const originalLength = group.trades.length;
                    group.trades = group.trades.filter(t => t.tradeRef !== stock.tradeRef);
                    
                    const removed = originalLength - group.trades.length;
                    if (removed > 0) {
                        console.log(`Removed ${removed} trades from group:`, group.name);
                    }
                    
                    // If group is now empty, mark it for deletion
                    if (group.trades.length === 0) {
                        console.log('Group is empty, will be removed:', group.name);
                    }
                });
                
                // Remove empty groups
                tradeGroups = tradeGroups.filter(g => g.trades && g.trades.length > 0);
            }
            
            // 5. Finally, delete the stock position itself
            stockPositions.splice(index, 1);
            
            console.log(`Deleted stock position and ${removedOpenCalls} open calls, ${removedClosedCalls} closed calls`);
            
            saveData();
            renderStockPositions();
            renderOpenTrades();
            renderAllTrades();
            renderGroups();
            updateStats();
            
            alert(`‚úÖ Stock position deleted!\n\nAlso removed:\n- Assigned PUT\n- Assignment trade\n- ${removedOpenCalls + removedClosedCalls} covered call(s)\n- Related group entries`);
        }

        function deleteTrade(index) {
            // Temporarily removing confirm to test if that's the issue
            if (true) { // Always proceed for now
                console.log('Deleting trade at index:', index);
                
                const tradeToDelete = trades[index];
                
                // Save for undo
                lastDeletedTrade = {...tradeToDelete};
                lastDeletedFrom = 'open';
                lastDeletedGroupInfo = null;
                
                // Remove from trades array
                trades.splice(index, 1);
                
                // Also remove from any groups
                removeTradeFromAllGroups(tradeToDelete);
                
                console.log('Trades after delete:', trades.length, 'trades remaining');
                saveData();
                renderOpenTrades();
                if (currentTab === 'all') {
                    renderAllTrades();
                } else if (currentTab === 'groups') {
                    renderGroups();
                }
                updateStats();
                showUndoButton();
                alert('Trade deleted successfully');
            }
        }

        function deleteClosedTrade(index) {
            if (confirm('Are you sure you want to delete this closed position? This cannot be undone.')) {
                const tradeToDelete = closedTrades[index];
                closedTrades.splice(index, 1);
                
                // Also remove from any groups
                removeTradeFromAllGroups(tradeToDelete);
                
                saveData();
                renderAllTrades();
                if (currentTab === 'groups') {
                    renderGroups();
                }
                updateStats();
            }
        }

        function deleteTradeFromAll(index, isOpen) {
            // Temporarily removing confirm to test
            if (true) { // Always proceed for now
                // Reconstruct allTrades EXACTLY as in renderAllTrades
                const openTrades = trades.map(t => ({...t, isOpen: true}));
                const closedTradesArray = closedTrades.map(t => ({...t, isOpen: false}));
                
                // Also get trades from groups that might not be in closedTrades
                const groupTrades = [];
                tradeGroups.forEach(group => {
                    if (group.trades && Array.isArray(group.trades)) {
                        group.trades.forEach(trade => {
                            const alreadyExists = openTrades.some(t => 
                                t.symbol === trade.symbol && 
                                t.dateOpened === trade.dateOpened && 
                                t.strike === trade.strike &&
                                t.premium === trade.premium &&
                                t.action === trade.action
                            ) || closedTradesArray.some(t => 
                                t.symbol === trade.symbol && 
                                t.dateOpened === trade.dateOpened && 
                                t.strike === trade.strike &&
                                t.premium === trade.premium &&
                                t.action === trade.action
                            );
                            
                            if (!alreadyExists) {
                                groupTrades.push({...trade, isOpen: trade.status === 'open'});
                            }
                        });
                    }
                });
                
                const allTrades = [...openTrades, ...closedTradesArray, ...groupTrades];
                
                // Sort by date opened (most recent first) - SAME AS renderAllTrades
                allTrades.sort((a, b) => new Date(b.dateOpened) - new Date(a.dateOpened));
                
                const tradeToDelete = allTrades[index];
                
                console.log('Deleting from All Trades, index:', index);
                console.log('Trade to delete:', tradeToDelete);
                
                if (!tradeToDelete) {
                    alert('Error: Could not find trade to delete');
                    return;
                }
                
                // Save for undo
                lastDeletedTrade = {...tradeToDelete};
                lastDeletedGroupInfo = null;
                
                if (tradeToDelete.isOpen) {
                    // Find and delete from open trades
                    const openIndex = trades.findIndex(t => 
                        t.symbol === tradeToDelete.symbol && 
                        t.dateOpened === tradeToDelete.dateOpened && 
                        t.strike === tradeToDelete.strike &&
                        t.premium === tradeToDelete.premium &&
                        t.action === tradeToDelete.action
                    );
                    console.log('Found in open trades at index:', openIndex);
                    if (openIndex !== -1) {
                        lastDeletedFrom = 'open';
                        trades.splice(openIndex, 1);
                    }
                } else {
                    // Find and delete from closed trades
                    const closedIndex = closedTrades.findIndex(t => 
                        t.symbol === tradeToDelete.symbol && 
                        t.dateOpened === tradeToDelete.dateOpened && 
                        t.strike === tradeToDelete.strike &&
                        t.premium === tradeToDelete.premium &&
                        t.action === tradeToDelete.action
                    );
                    console.log('Found in closed trades at index:', closedIndex);
                    if (closedIndex !== -1) {
                        lastDeletedFrom = 'closed';
                        closedTrades.splice(closedIndex, 1);
                    }
                }
                
                // Also remove from any groups
                removeTradeFromAllGroups(tradeToDelete);
                
                saveData();
                renderAllTrades();
                renderOpenTrades(); // Also update open positions view
                if (currentTab === 'groups') {
                    renderGroups();
                }
                updateStats();
                showUndoButton();
                alert('Trade deleted successfully');
            }
        }

        function editTradeFromAll(index, isOpen) {
            // Reconstruct allTrades EXACTLY as in renderAllTrades
            const openTrades = trades.map(t => ({...t, isOpen: true}));
            const closedTradesArray = closedTrades.map(t => ({...t, isOpen: false}));
            
            // Also get trades from groups
            const groupTrades = [];
            tradeGroups.forEach(group => {
                if (group.trades && Array.isArray(group.trades)) {
                    group.trades.forEach(trade => {
                        const alreadyExists = openTrades.some(t => 
                            t.symbol === trade.symbol && 
                            t.dateOpened === trade.dateOpened && 
                            t.strike === trade.strike &&
                            t.premium === trade.premium &&
                            t.action === trade.action
                        ) || closedTradesArray.some(t => 
                            t.symbol === trade.symbol && 
                            t.dateOpened === trade.dateOpened && 
                            t.strike === trade.strike &&
                            t.premium === trade.premium &&
                            t.action === trade.action
                        );
                        
                        if (!alreadyExists) {
                            groupTrades.push({...trade, isOpen: trade.status === 'open'});
                        }
                    });
                }
            });
            
            const allTrades = [...openTrades, ...closedTradesArray, ...groupTrades];
            
            // Sort by date opened (most recent first) - SAME AS renderAllTrades
            allTrades.sort((a, b) => new Date(b.dateOpened) - new Date(a.dateOpened));
            
            const tradeToEdit = allTrades[index];
            
            if (!tradeToEdit) {
                alert('Error: Could not find trade to edit');
                return;
            }
            
            // Find the actual index in the correct array
            if (tradeToEdit.isOpen) {
                const openIndex = trades.findIndex(t => 
                    t.symbol === tradeToEdit.symbol && 
                    t.dateOpened === tradeToEdit.dateOpened && 
                    t.strike === tradeToEdit.strike &&
                    t.premium === tradeToEdit.premium &&
                    t.action === tradeToEdit.action
                );
                if (openIndex !== -1) {
                    editingIndex = openIndex;
                    editingFromArray = 'open';
                    populateEditModal(trades[openIndex]);
                }
            } else {
                const closedIndex = closedTrades.findIndex(t => 
                    t.symbol === tradeToEdit.symbol && 
                    t.dateOpened === tradeToEdit.dateOpened && 
                    t.strike === tradeToEdit.strike &&
                    t.premium === tradeToEdit.premium &&
                    t.action === tradeToEdit.action
                );
                if (closedIndex !== -1) {
                    editingIndex = closedIndex;
                    editingFromArray = 'closed';
                    populateEditModal(closedTrades[closedIndex]);
                }
            }
            
            document.getElementById('editModal').classList.add('active');
        }

        function rollTradeFromAll(index) {
            console.log('rollTradeFromAll called with index:', index);
            const allTrades = [...trades.map(t => ({...t, isOpen: true})), ...closedTrades.map(t => ({...t, isOpen: false}))];
            console.log('allTrades length:', allTrades.length);
            
            // Sort by date opened (most recent first) - SAME AS renderAllTrades
            allTrades.sort((a, b) => new Date(b.dateOpened) - new Date(a.dateOpened));
            
            const tradeToRoll = allTrades[index];
            console.log('tradeToRoll:', tradeToRoll);
            
            // Find the actual index in the open trades array
            if (tradeToRoll && tradeToRoll.isOpen) {
                const openIndex = trades.findIndex(t => 
                    t.symbol === tradeToRoll.symbol && 
                    t.dateOpened === tradeToRoll.dateOpened && 
                    t.strike === tradeToRoll.strike &&
                    t.premium === tradeToRoll.premium
                );
                console.log('Found openIndex:', openIndex);
                if (openIndex !== -1) {
                    openRollModal(openIndex);
                } else {
                    console.error('Could not find trade in open trades array');
                    alert('Error: Could not find this trade. Please try from Open Positions tab.');
                }
            } else {
                console.error('Trade is not open or not found');
                alert('This trade is not open and cannot be rolled.');
            }
        }

        function closeTradeFromAll(index) {
            console.log('closeTradeFromAll called with index:', index);
            const allTrades = [...trades.map(t => ({...t, isOpen: true})), ...closedTrades.map(t => ({...t, isOpen: false}))];
            console.log('allTrades length:', allTrades.length);
            
            // Sort by date opened (most recent first) - SAME AS renderAllTrades
            allTrades.sort((a, b) => new Date(b.dateOpened) - new Date(a.dateOpened));
            
            const tradeToClose = allTrades[index];
            console.log('tradeToClose:', tradeToClose);
            
            // Find the actual index in the open trades array
            if (tradeToClose && tradeToClose.isOpen) {
                const openIndex = trades.findIndex(t => 
                    t.symbol === tradeToClose.symbol && 
                    t.dateOpened === tradeToClose.dateOpened && 
                    t.strike === tradeToClose.strike &&
                    t.premium === tradeToClose.premium
                );
                console.log('Found openIndex:', openIndex);
                if (openIndex !== -1) {
                    openCloseModal(openIndex);
                } else {
                    console.error('Could not find trade in open trades array');
                    alert('Error: Could not find this trade. Please try from Open Positions tab.');
                }
            } else {
                console.error('Trade is not open or not found');
                alert('This trade is not open and cannot be closed.');
            }
        }

        function saveData() {
            if (currentUser) {
                localStorage.setItem(getUserStorageKey('wheelTrades'), JSON.stringify(trades));
                localStorage.setItem(getUserStorageKey('wheelClosedTrades'), JSON.stringify(closedTrades));
                localStorage.setItem(getUserStorageKey('wheelTradeGroups'), JSON.stringify(tradeGroups));
                localStorage.setItem(getUserStorageKey('stockPositions'), JSON.stringify(stockPositions));
            } else {
                localStorage.setItem('wheelTrades', JSON.stringify(trades));
                localStorage.setItem('wheelClosedTrades', JSON.stringify(closedTrades));
                localStorage.setItem('wheelTradeGroups', JSON.stringify(tradeGroups));
                localStorage.setItem('stockPositions', JSON.stringify(stockPositions));
            }
        }

        function loadData() {
            // Use user-specific keys if logged in
            const getKey = (key) => currentUser ? getUserStorageKey(key) : key;
            
            const savedTrades = localStorage.getItem(getKey('wheelTrades'));
            const savedClosedTrades = localStorage.getItem(getKey('wheelClosedTrades'));
            const savedTradeGroups = localStorage.getItem(getKey('wheelTradeGroups'));
            const savedStockPositions = localStorage.getItem(getKey('stockPositions'));
            
            if (savedTrades) {
                try {
                    trades = JSON.parse(savedTrades);
                    if (!Array.isArray(trades)) trades = [];
                } catch (e) {
                    console.error('Error loading trades:', e);
                    trades = [];
                }
            }
            if (savedClosedTrades) {
                try {
                    closedTrades = JSON.parse(savedClosedTrades);
                    if (!Array.isArray(closedTrades)) closedTrades = [];
                } catch (e) {
                    console.error('Error loading closed trades:', e);
                    closedTrades = [];
                }
            }
            if (savedTradeGroups) {
                try {
                    tradeGroups = JSON.parse(savedTradeGroups);
                    if (!Array.isArray(tradeGroups)) tradeGroups = [];
                    // Filter out invalid groups
                    tradeGroups = tradeGroups.filter(g => g.trades && Array.isArray(g.trades) && g.trades.length > 0);
                } catch (e) {
                    console.error('Error loading trade groups:', e);
                    tradeGroups = [];
                }
            }
            if (savedStockPositions) {
                try {
                    stockPositions = JSON.parse(savedStockPositions);
                    if (!Array.isArray(stockPositions)) stockPositions = [];
                } catch (e) {
                    console.error('Error loading stock positions:', e);
                    stockPositions = [];
                }
            }
            
            renderTables();
            updateStats();
        }

        function downloadTemplate() {
            // Create sample data for the template
            const templateData = [
                {
                    'Symbol': 'AAPL',
                    'Contracts': 1,
                    'Strike': 150.00,
                    'Premium': 2.50,
                    'Action': 'sell',
                    'Type': 'put',
                    'Status': 'open',
                    'Date Opened': '2024-12-01',
                    'Exp Date': '2024-12-15',
                    'Price At Action': 152.50,
                    'Info': 'Opening position',
                    'Trade Ref': '1',
                    'Account': 'Main'
                },
                {
                    'Symbol': 'AAPL',
                    'Contracts': 1,
                    'Strike': 150.00,
                    'Premium': 0.50,
                    'Action': 'buy',
                    'Type': 'put',
                    'Status': 'closed',
                    'Date Opened': '2024-12-10',
                    'Date Closed': '2024-12-10',
                    'Exp Date': '2024-12-15',
                    'Price At Action': 148.00,
                    'Info': 'Closing position - profit',
                    'Trade Ref': '1',
                    'Account': 'Main'
                },
                {
                    'Symbol': 'TSLA',
                    'Contracts': 2,
                    'Strike': 220.00,
                    'Premium': 3.00,
                    'Action': 'sell',
                    'Type': 'put',
                    'Status': 'closed',
                    'Date Opened': '2024-11-20',
                    'Date Closed': '2024-11-28',
                    'Exp Date': '2024-12-20',
                    'Price At Action': 225.00,
                    'Info': 'Expired worthless - kept full premium',
                    'Trade Ref': '2',
                    'Account': 'IRA'
                },
                {
                    'Symbol': 'MSFT',
                    'Contracts': 1,
                    'Strike': 0,
                    'Premium': 1.25,
                    'Action': 'sell',
                    'Type': 'put',
                    'Status': 'closed',
                    'Date Opened': '2024-11-15',
                    'Date Closed': '2024-11-22',
                    'Exp Date': '',
                    'Price At Action': 0,
                    'Info': 'Expired worthless - no strike/exp needed',
                    'Trade Ref': '4',
                    'Account': 'Main'
                },
                {
                    'Symbol': 'NVDA',
                    'Contracts': 1,
                    'Strike': 155.00,
                    'Premium': 0.99,
                    'Action': 'sell',
                    'Type': 'put',
                    'Status': 'open',
                    'Date Opened': '2024-11-25',
                    'Exp Date': '2024-12-05',
                    'Price At Action': 172.65,
                    'Info': 'Currently open position',
                    'Trade Ref': '5',
                    'Account': 'Roth IRA'
                }
            ];

            // Load SheetJS if not already loaded
            if (typeof XLSX === 'undefined') {
                const script = document.createElement('script');
                script.src = 'https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js';
                document.head.appendChild(script);
                
                script.onload = () => {
                    generateAndDownloadTemplate(templateData);
                };
                script.onerror = () => {
                    alert('Failed to load Excel library. Please try again.');
                };
            } else {
                generateAndDownloadTemplate(templateData);
            }
        }

        function generateAndDownloadTemplate(templateData) {
            // Create worksheet from data
            const worksheet = XLSX.utils.json_to_sheet(templateData);
            
            // Set column widths
            worksheet['!cols'] = [
                { wch: 10 },  // Symbol
                { wch: 10 },  // Contracts
                { wch: 10 },  // Strike
                { wch: 10 },  // Premium
                { wch: 10 },  // Action
                { wch: 8 },   // Type
                { wch: 10 },  // Status
                { wch: 15 },  // Date Opened
                { wch: 15 },  // Date Closed
                { wch: 15 },  // Exp Date
                { wch: 15 },  // Price At Action
                { wch: 30 },  // Info
                { wch: 12 },  // Trade Ref
                { wch: 12 }   // Account
            ];
            
            // Create workbook
            const workbook = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(workbook, worksheet, 'Trades');
            
            // Add instructions sheet
            const instructions = [
                ['IMPORT TEMPLATE INSTRUCTIONS'],
                [''],
                ['Required Columns:'],
                ['- Symbol: Stock ticker (e.g., AAPL, TSLA)'],
                ['- Contracts: Number of contracts (e.g., 1, 2)'],
                ['- Premium: Premium per share (e.g., 2.50)'],
                ['- Action: sell or buy'],
                ['- Type: put or call'],
                ['- Status: open or closed'],
                ['- Date Opened: Format YYYY-MM-DD (e.g., 2024-12-01)'],
                [''],
                ['Optional Columns:'],
                ['- Strike: Strike price (can be 0 or blank for expired worthless)'],
                ['- Exp Date: Format YYYY-MM-DD (can be blank if expired/not applicable)'],
                ['- Date Closed: Format YYYY-MM-DD (required if Status is closed)'],
                ['- Price At Action: Stock price when trade opened'],
                ['- Info: Notes about the trade'],
                ['- Trade Ref: Reference number to link trades (e.g., 1, 2, 3)'],
                ['- Account: Account name (e.g., Main, IRA, Roth IRA)'],
                [''],
                ['Status Field (NEW!):'],
                ['- open: Position is currently open'],
                ['- closed: Position has been closed (include Date Closed)'],
                ['- This ensures positions import with correct status'],
                [''],
                ['Strike & Exp Date:'],
                ['- Can use $0.00 or leave blank for expired worthless positions'],
                ['- Exp Date can be blank if not applicable'],
                ['- System will handle missing/zero values'],
                [''],
                ['Action Types:'],
                ['- sell: Opens or reopens a position (use Status to indicate open/closed)'],
                ['- buy: Closes a position (use Status=closed and Date Closed)'],
                [''],
                ['Examples in the "Trades" sheet:'],
                ['1. AAPL - Sell put (Status=open), then buy back (Status=closed)'],
                ['2. TSLA - Sell put that expired worthless (Status=closed, Date Closed)'],
                ['3. MSFT - Expired worthless with $0 strike and no exp date'],
                ['4. NVDA - Currently open position (Status=open)'],
                [''],
                ['Tips:'],
                ['- Use Trade Ref numbers to link related trades (1, 2, 3, etc.)'],
                ['- Always set Status=closed for completed trades'],
                ['- Add Date Closed for all closed trades'],
                ['- Rows are processed in order, so put trades chronologically'],
                ['- Delete these example rows and add your own trades'],
                ['- Save as .xlsx or .csv format']
            ];
            
            const instructionsSheet = XLSX.utils.aoa_to_sheet(instructions);
            instructionsSheet['!cols'] = [{ wch: 70 }];
            XLSX.utils.book_append_sheet(workbook, instructionsSheet, 'Instructions');
            
            // Download file
            XLSX.writeFile(workbook, 'options_tracker_template.xlsx');
        }

        function exportData() {
            // Check if user wants Excel or JSON
            if (confirm('Export as Excel?\n\nClick OK for Excel (.xlsx)\nClick Cancel for JSON (.json)')) {
                exportToExcel();
            } else {
                exportToJSON();
            }
        }

        function exportToJSON() {
            const data = {
                openTrades: trades,
                closedTrades: closedTrades,
                tradeGroups: tradeGroups,
                stockPositions: stockPositions,
                exportDate: new Date().toISOString()
            };
            const dataStr = JSON.stringify(data, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `wheel_trades_${new Date().toISOString().split('T')[0]}.json`;
            link.click();
        }

        function exportToExcel() {
            // Load SheetJS if not already loaded
            if (typeof XLSX === 'undefined') {
                const script = document.createElement('script');
                script.src = 'https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js';
                document.head.appendChild(script);
                
                script.onload = () => {
                    generateExcelExport();
                };
                script.onerror = () => {
                    alert('Failed to load Excel library. Exporting as JSON instead.');
                    exportToJSON();
                };
            } else {
                generateExcelExport();
            }
        }

        function generateExcelExport() {
            const workbook = XLSX.utils.book_new();
            
            // === OPEN TRADES SHEET ===
            const openTradesData = trades.map(trade => {
                const cashRequired = calculateCashRequired(trade);
                const returnPercent = calculateReturnPercent(trade);
                const otm = calculateOTM(trade);
                const pl = calculatePL(trade, true);
                
                return {
                    'Status': 'OPEN',
                    'Symbol': trade.symbol,
                    'Contracts': trade.contracts,
                    'Strike': trade.strike,
                    'Premium': trade.premium,
                    'Action': trade.action,
                    'Type': trade.type,
                    'Date Opened': trade.dateOpened,
                    'Exp Date': trade.expDate,
                    'Days to Exp': calculateDaysToExpiration(trade.expDate),
                    'Cash Required': cashRequired,
                    'Return %': parseFloat(returnPercent),
                    'Price @ Action': trade.priceAtAction || 0,
                    '% OTM': parseFloat(otm),
                    'P&L': pl,
                    'Info': trade.info || '',
                    'Trade Ref': trade.tradeRef || '',
                    'Account': trade.account || '',
                    'Is Rolled': trade.isRolled ? 'Yes' : 'No',
                    'Is Covered Call': trade.isCoveredCall ? 'Yes' : 'No'
                };
            });
            
            if (openTradesData.length > 0) {
                const openSheet = XLSX.utils.json_to_sheet(openTradesData);
                openSheet['!cols'] = [
                    { wch: 8 }, { wch: 10 }, { wch: 10 }, { wch: 10 }, { wch: 10 },
                    { wch: 8 }, { wch: 8 }, { wch: 12 }, { wch: 12 }, { wch: 10 },
                    { wch: 15 }, { wch: 10 }, { wch: 15 }, { wch: 10 }, { wch: 12 },
                    { wch: 30 }, { wch: 10 }, { wch: 12 }, { wch: 10 }, { wch: 12 }
                ];
                XLSX.utils.book_append_sheet(workbook, openSheet, 'Open Trades');
            }
            
            // === CLOSED TRADES SHEET ===
            const closedTradesData = closedTrades.filter(t => !t.isClosingTrade).map(trade => {
                const cashRequired = calculateCashRequired(trade);
                const returnPercent = calculateReturnPercent(trade);
                const pl = calculatePL(trade, true);
                const daysHeld = trade.dateClosed && trade.dateOpened ? 
                    Math.round((new Date(trade.dateClosed) - new Date(trade.dateOpened)) / (1000 * 60 * 60 * 24)) : 0;
                
                return {
                    'Status': 'CLOSED',
                    'Symbol': trade.symbol,
                    'Contracts': trade.contracts,
                    'Strike': trade.strike,
                    'Premium Collected': trade.premium,
                    'Closing Cost': trade.closePrice || trade.closingPremium || 0,
                    'Action': trade.action,
                    'Type': trade.type,
                    'Date Opened': trade.dateOpened,
                    'Date Closed': trade.dateClosed || '',
                    'Days Held': daysHeld,
                    'Exp Date': trade.expDate,
                    'Cash Required': cashRequired,
                    'Return %': parseFloat(returnPercent),
                    'P&L': pl,
                    'Price @ Action': trade.priceAtAction || 0,
                    'Info': trade.closingNotes || trade.info || '',
                    'Trade Ref': trade.tradeRef || '',
                    'Account': trade.account || '',
                    'Is Rolled': trade.isRolled ? 'Yes' : 'No',
                    'Is Assignment': trade.isAssignment ? 'Yes' : 'No',
                    'Is Called Away': trade.isCalledAway ? 'Yes' : 'No'
                };
            });
            
            if (closedTradesData.length > 0) {
                const closedSheet = XLSX.utils.json_to_sheet(closedTradesData);
                closedSheet['!cols'] = [
                    { wch: 8 }, { wch: 10 }, { wch: 10 }, { wch: 10 }, { wch: 15 },
                    { wch: 12 }, { wch: 8 }, { wch: 8 }, { wch: 12 }, { wch: 12 },
                    { wch: 10 }, { wch: 12 }, { wch: 15 }, { wch: 10 }, { wch: 12 },
                    { wch: 15 }, { wch: 30 }, { wch: 10 }, { wch: 12 }, { wch: 10 },
                    { wch: 12 }, { wch: 12 }
                ];
                XLSX.utils.book_append_sheet(workbook, closedSheet, 'Closed Trades');
            }
            
            // === ALL TRADES SHEET (Combined) ===
            const allTradesData = [
                ...trades.map(t => ({...t, status: 'OPEN', isOpen: true})),
                ...closedTrades.filter(t => !t.isClosingTrade).map(t => ({...t, status: 'CLOSED', isOpen: false}))
            ].sort((a, b) => new Date(b.dateOpened) - new Date(a.dateOpened))
            .map(trade => {
                const cashRequired = calculateCashRequired(trade);
                const returnPercent = calculateReturnPercent(trade);
                const pl = calculatePL(trade, true);
                const daysHeld = trade.dateClosed && trade.dateOpened ? 
                    Math.round((new Date(trade.dateClosed) - new Date(trade.dateOpened)) / (1000 * 60 * 60 * 24)) : 
                    (trade.isOpen ? Math.round((new Date() - new Date(trade.dateOpened)) / (1000 * 60 * 60 * 24)) : 0);
                
                return {
                    'Status': trade.status,
                    'Symbol': trade.symbol,
                    'Contracts': trade.contracts,
                    'Strike': trade.strike,
                    'Premium': trade.premium,
                    'Close Price': trade.closePrice || trade.closingPremium || '',
                    'Action': trade.action,
                    'Type': trade.type,
                    'Date Opened': trade.dateOpened,
                    'Date Closed': trade.dateClosed || '',
                    'Days Held': daysHeld,
                    'Exp Date': trade.expDate,
                    'Cash Required': cashRequired,
                    'Return %': parseFloat(returnPercent),
                    'P&L': pl,
                    'Info': trade.closingNotes || trade.info || '',
                    'Trade Ref': trade.tradeRef || '',
                    'Account': trade.account || ''
                };
            });
            
            if (allTradesData.length > 0) {
                const allSheet = XLSX.utils.json_to_sheet(allTradesData);
                allSheet['!cols'] = [
                    { wch: 8 }, { wch: 10 }, { wch: 10 }, { wch: 10 }, { wch: 10 },
                    { wch: 12 }, { wch: 8 }, { wch: 8 }, { wch: 12 }, { wch: 12 },
                    { wch: 10 }, { wch: 12 }, { wch: 15 }, { wch: 10 }, { wch: 12 },
                    { wch: 30 }, { wch: 10 }, { wch: 12 }
                ];
                XLSX.utils.book_append_sheet(workbook, allSheet, 'All Trades');
            }
            
            // === STOCK POSITIONS SHEET ===
            if (stockPositions.length > 0) {
                const stockData = stockPositions.map(stock => {
                    const callsCount = stock.coveredCalls ? stock.coveredCalls.length : 0;
                    const totalCallPremiums = stock.coveredCalls ? 
                        stock.coveredCalls.reduce((sum, call) => sum + call.premium, 0) : 0;
                    const putPremium = stock.originalPut ? stock.originalPut.premiumCollected : 0;
                    const runningPL = putPremium + totalCallPremiums;
                    
                    return {
                        'Symbol': stock.symbol,
                        'Shares': stock.shares,
                        'Cost Basis': stock.costBasis,
                        'Assigned Price': stock.assignedPrice,
                        'Total Cost': stock.totalCost,
                        'Total Value': stock.totalValue,
                        'Assigned Date': stock.assignedDate,
                        'Put Strike': stock.originalPut ? stock.originalPut.strike : '',
                        'Put Premium': putPremium,
                        'Covered Calls': callsCount,
                        'Call Premiums': totalCallPremiums,
                        'Running P&L': runningPL,
                        'Trade Ref': stock.tradeRef || '',
                        'Account': stock.account || ''
                    };
                });
                
                const stockSheet = XLSX.utils.json_to_sheet(stockData);
                stockSheet['!cols'] = [
                    { wch: 10 }, { wch: 10 }, { wch: 12 }, { wch: 15 }, { wch: 12 },
                    { wch: 12 }, { wch: 15 }, { wch: 10 }, { wch: 12 }, { wch: 12 },
                    { wch: 15 }, { wch: 15 }, { wch: 10 }, { wch: 12 }
                ];
                XLSX.utils.book_append_sheet(workbook, stockSheet, 'Stock Positions');
            }
            
            // === SUMMARY SHEET ===
            // For Total P&L, sum all individual leg P&Ls (including rolled trades)
            const totalPL = trades.reduce((sum, t) => sum + calculatePL(t, true), 0) + 
                           closedTrades.filter(t => !t.isClosingTrade).reduce((sum, t) => sum + calculatePL(t, true), 0);
            const totalCollateral = trades.reduce((sum, t) => sum + calculateCashRequired(t), 0);
            const openCount = trades.length;
            
            // Calculate Win Rate based on CLOSED TRADE GROUPS
            const closedGroups = tradeGroups.filter(group => {
                return !group.trades.some(t => trades.some(openTrade => openTrade.id === t.id));
            });
            
            let winningTrades = 0;
            let losingTrades = 0;
            
            closedGroups.forEach(group => {
                let groupPL = 0;
                let hasAssignment = false;
                let hasCalledAway = false;
                
                group.trades.forEach(trade => {
                    if (trade.isAssignment) hasAssignment = true;
                    if (trade.isCalledAway) hasCalledAway = true;
                    // Use forDisplay=true to get each leg's premium for rolled trades
                    groupPL += calculatePL(trade, true);
                });
                
                if (hasAssignment || hasCalledAway) {
                    losingTrades++;
                } else if (groupPL > 0) {
                    winningTrades++;
                } else if (groupPL < 0) {
                    losingTrades++;
                }
            });
            
            const closedCount = closedGroups.length;
            const winRate = closedCount > 0 ? ((winningTrades / closedCount) * 100).toFixed(1) : 0;
            
            const summaryData = [
                ['Options Wheel Strategy Tracker - Export Summary'],
                ['Export Date', new Date().toLocaleString()],
                [''],
                ['Portfolio Summary'],
                ['Total P&L', totalPL.toFixed(2)],
                ['Total Collateral', totalCollateral.toFixed(2)],
                ['Open Positions', openCount],
                ['Closed Positions', closedCount],
                ['Stock Positions', stockPositions.length],
                [''],
                ['Performance'],
                ['Win Rate', winRate + '%'],
                ['Winning Trades', winningTrades],
                ['Losing Trades', losingTrades],
                [''],
                ['Sheet Contents'],
                ['- Open Trades: All currently open positions'],
                ['- Closed Trades: All closed positions (excluding closing legs)'],
                ['- All Trades: Combined view sorted by date'],
                ['- Stock Positions: Assigned stock from puts'],
                ['- Summary: This overview page']
            ];
            
            const summarySheet = XLSX.utils.aoa_to_sheet(summaryData);
            summarySheet['!cols'] = [{ wch: 30 }, { wch: 20 }];
            XLSX.utils.book_append_sheet(workbook, summarySheet, 'Summary');
            
            // Download file
            const fileName = `wheel_trades_export_${new Date().toISOString().split('T')[0]}.xlsx`;
            XLSX.writeFile(workbook, fileName);
            
            alert(`‚úÖ Export successful!\n\n${openCount} open trades\n${closedCount} closed trades\n${stockPositions.length} stock positions\n\nFile: ${fileName}`);
        }


        function importData() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json,.xlsx,.xls,.csv';
            input.onchange = async (e) => {
                const file = e.target.files[0];
                const fileName = file.name.toLowerCase();
                
                // Check file type
                if (fileName.endsWith('.json')) {
                    // JSON import (existing functionality)
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        try {
                            const imported = JSON.parse(event.target.result);
                            const openCount = imported.openTrades?.length || 0;
                            const closedCount = imported.closedTrades?.length || 0;
                            const stockCount = imported.stockPositions?.length || 0;
                            
                            if (confirm(`Import ${openCount} open trades, ${closedCount} closed trades, and ${stockCount} stock positions? This will replace current data.`)) {
                                trades = imported.openTrades || imported || [];
                                closedTrades = imported.closedTrades || [];
                                tradeGroups = imported.tradeGroups || [];
                                stockPositions = imported.stockPositions || [];
                                saveData();
                                renderTables();
                                renderStockPositions();
                                updateStats();
                            }
                        } catch (error) {
                            alert('Error importing JSON file. Please check the file format.');
                        }
                    };
                    reader.readAsText(file);
                } else if (fileName.endsWith('.xlsx') || fileName.endsWith('.xls') || fileName.endsWith('.csv')) {
                    // Excel/CSV import
                    importFromExcelCSV(file);
                } else {
                    alert('Please select a JSON, Excel (.xlsx, .xls), or CSV file.');
                }
            };
            input.click();
        }

        async function importFromExcelCSV(file) {
            try {
                // Load SheetJS library if not already loaded
                if (typeof XLSX === 'undefined') {
                    const script = document.createElement('script');
                    script.src = 'https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js';
                    document.head.appendChild(script);
                    
                    await new Promise((resolve, reject) => {
                        script.onload = resolve;
                        script.onerror = () => reject(new Error('Failed to load Excel library'));
                    });
                }

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const data = new Uint8Array(e.target.result);
                        const workbook = XLSX.read(data, { type: 'array' });
                        
                        // Read first sheet
                        const sheetName = workbook.SheetNames[0];
                        const worksheet = workbook.Sheets[sheetName];
                        const jsonData = XLSX.utils.sheet_to_json(worksheet);
                        
                        console.log('Imported rows:', jsonData.length);
                        console.log('Sample data:', jsonData[0]);
                        
                        if (jsonData.length === 0) {
                            alert('No data found in the file.');
                            return;
                        }
                        
                        // Validate and convert to trades
                        const result = convertExcelToTrades(jsonData);
                        
                        if (result.errors.length > 0) {
                            alert(`Found ${result.errors.length} errors:\n\n${result.errors.slice(0, 5).join('\n')}\n\n${result.errors.length > 5 ? '...and more' : ''}`);
                            return;
                        }
                        
                        // Show preview
                        const openCount = result.openTrades.length;
                        const closedCount = result.closedTrades.length;
                        const groupCount = result.tradeGroups.length;
                        
                        if (confirm(`Import Preview:\n\n` +
                            `‚úÖ ${openCount} open positions\n` +
                            `‚úÖ ${closedCount} closed trades\n` +
                            `‚úÖ ${groupCount} trade groups\n\n` +
                            `This will REPLACE all current data. Continue?`)) {
                            
                            trades = result.openTrades;
                            closedTrades = result.closedTrades;
                            tradeGroups = result.tradeGroups;
                            stockPositions = []; // Reset stock positions
                            
                            saveData();
                            renderTables();
                            renderStockPositions();
                            updateStats();
                            updateLastRefDisplay();
                            
                            alert(`‚úÖ Import successful!\n\n${openCount} open positions\n${closedCount} closed trades\n${groupCount} groups created`);
                        }
                    } catch (error) {
                        console.error('Import error:', error);
                        alert('Error reading Excel/CSV file: ' + error.message);
                    }
                };
                reader.readAsArrayBuffer(file);
            } catch (error) {
                alert('Error importing file: ' + error.message);
            }
        }

        function convertExcelToTrades(rows) {
            const openTrades = [];
            const closedTrades = [];
            const tradeGroups = [];
            const errors = [];
            const tradesByRef = {}; // Track trades by ref number
            
            rows.forEach((row, index) => {
                const rowNum = index + 2; // +2 because row 1 is header, and Excel is 1-indexed
                
                try {
                    // Required fields
                    const symbol = String(row.Symbol || row.symbol || '').trim().toUpperCase();
                    const contracts = parseInt(row.Contracts || row.contracts);
                    const premium = parseFloat(row.Premium || row.premium);
                    const action = String(row.Action || row.action || '').toLowerCase();
                    const type = String(row.Type || row.type || '').toLowerCase();
                    const dateOpened = row['Date Opened'] || row.dateOpened || row['Date_Opened'];
                    const status = String(row.Status || row.status || 'open').toLowerCase();
                    
                    // Optional fields (can be blank/zero)
                    const strike = parseFloat(row.Strike || row.strike || 0);
                    const expDate = row['Exp Date'] || row.expDate || row['Exp_Date'] || '';
                    const priceAtAction = parseFloat(row['Price At Action'] || row.priceAtAction || row['Price_At_Action'] || 0);
                    const info = String(row.Info || row.info || row.Notes || row.notes || '');
                    const tradeRef = String(row['Trade Ref'] || row.tradeRef || row['Trade_Ref'] || '').trim();
                    const account = String(row.Account || row.account || '');
                    const dateClosed = row['Date Closed'] || row.dateClosed || row['Date_Closed'] || '';
                    const closePrice = parseFloat(row['Close Price'] || row.closePrice || row['Close_Price'] || 0);
                    
                    // Validation
                    if (!symbol) {
                        errors.push(`Row ${rowNum}: Missing symbol`);
                        return;
                    }
                    if (!contracts || isNaN(contracts)) {
                        errors.push(`Row ${rowNum}: Invalid contracts`);
                        return;
                    }
                    if (isNaN(premium)) {
                        errors.push(`Row ${rowNum}: Invalid premium`);
                        return;
                    }
                    if (action !== 'sell' && action !== 'buy') {
                        errors.push(`Row ${rowNum}: Action must be 'sell' or 'buy'`);
                        return;
                    }
                    if (type !== 'put' && type !== 'call') {
                        errors.push(`Row ${rowNum}: Type must be 'put' or 'call'`);
                        return;
                    }
                    if (status !== 'open' && status !== 'closed') {
                        errors.push(`Row ${rowNum}: Status must be 'open' or 'closed'`);
                        return;
                    }
                    if (!dateOpened) {
                        errors.push(`Row ${rowNum}: Missing Date Opened`);
                        return;
                    }
                    if (status === 'closed' && !dateClosed) {
                        errors.push(`Row ${rowNum}: Status is 'closed' but no Date Closed provided`);
                        return;
                    }
                    
                    // Format dates
                    const formattedDateOpened = formatExcelDate(dateOpened);
                    const formattedExpDate = expDate ? formatExcelDate(expDate) : formattedDateOpened;
                    const formattedDateClosed = dateClosed ? formatExcelDate(dateClosed) : '';
                    
                    // Create trade object
                    const trade = {
                        id: Date.now() + Math.random(),
                        symbol,
                        contracts,
                        strike: strike || 0,
                        premium,
                        action,
                        type,
                        dateOpened: formattedDateOpened,
                        expDate: formattedExpDate,
                        priceAtAction,
                        info,
                        tradeRef,
                        account,
                        groupId: `${symbol}-${strike}-${type}-${formattedExpDate}`,
                        status: status
                    };
                    
                    // Handle based on Status field
                    if (status === 'closed') {
                        trade.dateClosed = formattedDateClosed;
                        trade.closePrice = closePrice || premium; // Use closePrice if provided, else use premium
                        
                        // Add to closedTrades
                        closedTrades.push(trade);
                        
                        // If it's a BUY action, mark as closing trade
                        if (action === 'buy') {
                            trade.isClosingTrade = true;
                        }
                        
                        // Create or update group if tradeRef exists
                        if (tradeRef) {
                            let group = tradeGroups.find(g => g.name === `Trade Ref: ${tradeRef}`);
                            if (group) {
                                group.trades.push(trade);
                            } else {
                                tradeGroups.push({
                                    id: Date.now() + Math.random(),
                                    name: `Trade Ref: ${tradeRef}`,
                                    trades: [trade],
                                    created: new Date().toISOString()
                                });
                            }
                        }
                    } else {
                        // Status is 'open'
                        openTrades.push(trade);
                    }
                    
                } catch (error) {
                    errors.push(`Row ${rowNum}: ${error.message}`);
                }
            });
            
            return { openTrades, closedTrades, tradeGroups, errors };
        }

        function formatExcelDate(dateValue) {
            // Handle Excel serial date numbers
            if (typeof dateValue === 'number') {
                const date = XLSX.SSF.parse_date_code(dateValue);
                return `${date.y}-${String(date.m).padStart(2, '0')}-${String(date.d).padStart(2, '0')}`;
            }
            
            // Handle date objects
            if (dateValue instanceof Date) {
                return dateValue.toISOString().split('T')[0];
            }
            
            // Handle string dates (YYYY-MM-DD, MM/DD/YYYY, etc.)
            const str = String(dateValue).trim();
            
            // Check if already in YYYY-MM-DD format
            if (/^\d{4}-\d{2}-\d{2}$/.test(str)) {
                return str;
            }
            
            // Try to parse as date
            const parsed = new Date(str);
            if (!isNaN(parsed.getTime())) {
                return parsed.toISOString().split('T')[0];
            }
            
            return str; // Return as-is if can't parse
        }
    </script>
</body>
</html>
